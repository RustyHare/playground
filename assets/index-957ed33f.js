var e$ = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports); var Cq = e$((Ci, Ti) => {
    (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && i(s) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function i(r) { if (r.ep) return; r.ep = !0; const o = n(r); fetch(r.href, o) } })();/**
* @vue/shared v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function bp(t) { const e = Object.create(null); for (const n of t.split(",")) e[n] = 1; return n => n in e } const We = {}, Co = [], _n = () => { }, t$ = () => !1, bu = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Op = t => t.startsWith("onUpdate:"), ht = Object.assign, Sp = (t, e) => { const n = t.indexOf(e); n > -1 && t.splice(n, 1) }, n$ = Object.prototype.hasOwnProperty, Ne = (t, e) => n$.call(t, e), be = Array.isArray, To = t => Ou(t) === "[object Map]", rO = t => Ou(t) === "[object Set]", xe = t => typeof t == "function", it = t => typeof t == "string", pr = t => typeof t == "symbol", Ye = t => t !== null && typeof t == "object", oO = t => (Ye(t) || xe(t)) && xe(t.then) && xe(t.catch), sO = Object.prototype.toString, Ou = t => sO.call(t), i$ = t => Ou(t).slice(8, -1), lO = t => Ou(t) === "[object Object]", xp = t => it(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ws = bp(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Su = t => { const e = Object.create(null); return n => e[n] || (e[n] = t(n)) }, r$ = /-(\w)/g, xn = Su(t => t.replace(r$, (e, n) => n ? n.toUpperCase() : "")), o$ = /\B([A-Z])/g, Jr = Su(t => t.replace(o$, "-$1").toLowerCase()), xu = Su(t => t.charAt(0).toUpperCase() + t.slice(1)), df = Su(t => t ? `on${xu(t)}` : ""), lr = (t, e) => !Object.is(t, e), pf = (t, ...e) => { for (let n = 0; n < t.length; n++)t[n](...e) }, aO = (t, e, n, i = !1) => { Object.defineProperty(t, e, { configurable: !0, enumerable: !1, writable: i, value: n }) }, s$ = t => { const e = parseFloat(t); return isNaN(e) ? t : e }, l$ = t => { const e = it(t) ? Number(t) : NaN; return isNaN(e) ? t : e }; let um; const cO = () => um || (um = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function wp(t) { if (be(t)) { const e = {}; for (let n = 0; n < t.length; n++) { const i = t[n], r = it(i) ? f$(i) : wp(i); if (r) for (const o in r) e[o] = r[o] } return e } else if (it(t) || Ye(t)) return t } const a$ = /;(?![^(]*\))/g, c$ = /:([^]+)/, u$ = /\/\*[^]*?\*\//g; function f$(t) { const e = {}; return t.replace(u$, "").split(a$).forEach(n => { if (n) { const i = n.split(c$); i.length > 1 && (e[i[0].trim()] = i[1].trim()) } }), e } function Cp(t) { let e = ""; if (it(t)) e = t; else if (be(t)) for (let n = 0; n < t.length; n++) { const i = Cp(t[n]); i && (e += i + " ") } else if (Ye(t)) for (const n in t) t[n] && (e += n + " "); return e.trim() } const h$ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", d$ = bp(h$); function uO(t) { return !!t || t === "" } const fO = t => !!(t && t.__v_isRef === !0), Mh = t => it(t) ? t : t == null ? "" : be(t) || Ye(t) && (t.toString === sO || !xe(t.toString)) ? fO(t) ? Mh(t.value) : JSON.stringify(t, hO, 2) : String(t), hO = (t, e) => fO(e) ? hO(t, e.value) : To(e) ? { [`Map(${e.size})`]: [...e.entries()].reduce((n, [i, r], o) => (n[gf(i, o) + " =>"] = r, n), {}) } : rO(e) ? { [`Set(${e.size})`]: [...e.values()].map(n => gf(n)) } : pr(e) ? gf(e) : Ye(e) && !be(e) && !lO(e) ? String(e) : e, gf = (t, e = "") => { var n; return pr(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t };/**
* @vue/reactivity v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ln; class p$ { constructor(e = !1) { this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = ln, !e && ln && (this.index = (ln.scopes || (ln.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let e, n; if (this.scopes) for (e = 0, n = this.scopes.length; e < n; e++)this.scopes[e].pause(); for (e = 0, n = this.effects.length; e < n; e++)this.effects[e].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let e, n; if (this.scopes) for (e = 0, n = this.scopes.length; e < n; e++)this.scopes[e].resume(); for (e = 0, n = this.effects.length; e < n; e++)this.effects[e].resume() } } run(e) { if (this._active) { const n = ln; try { return ln = this, e() } finally { ln = n } } } on() { ln = this } off() { ln = this.parent } stop(e) { if (this._active) { let n, i; for (n = 0, i = this.effects.length; n < i; n++)this.effects[n].stop(); for (n = 0, i = this.cleanups.length; n < i; n++)this.cleanups[n](); if (this.scopes) for (n = 0, i = this.scopes.length; n < i; n++)this.scopes[n].stop(!0); if (!this.detached && this.parent && !e) { const r = this.parent.scopes.pop(); r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) } this.parent = void 0, this._active = !1 } } } function g$() { return ln } let qe; const mf = new WeakSet; class dO { constructor(e) { this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, ln && ln.active && ln.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, mf.has(this) && (mf.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || gO(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, fm(this), mO(this); const e = qe, n = Rn; qe = this, Rn = !0; try { return this.fn() } finally { vO(this), qe = e, Rn = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let e = this.deps; e; e = e.nextDep)kp(e); this.deps = this.depsTail = void 0, fm(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? mf.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Eh(this) && this.run() } get dirty() { return Eh(this) } } let pO = 0, Hs, Fs; function gO(t, e = !1) { if (t.flags |= 8, e) { t.next = Fs, Fs = t; return } t.next = Hs, Hs = t } function Tp() { pO++ } function $p() { if (--pO > 0) return; if (Fs) { let e = Fs; for (Fs = void 0; e;) { const n = e.next; e.next = void 0, e.flags &= -9, e = n } } let t; for (; Hs;) { let e = Hs; for (Hs = void 0; e;) { const n = e.next; if (e.next = void 0, e.flags &= -9, e.flags & 1) try { e.trigger() } catch (i) { t || (t = i) } e = n } } if (t) throw t } function mO(t) { for (let e = t.deps; e; e = e.nextDep)e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e } function vO(t) { let e, n = t.depsTail, i = n; for (; i;) { const r = i.prevDep; i.version === -1 ? (i === n && (n = r), kp(i), m$(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = r } t.deps = e, t.depsTail = n } function Eh(t) { for (let e = t.deps; e; e = e.nextDep)if (e.dep.version !== e.version || e.dep.computed && (yO(e.dep.computed) || e.dep.version !== e.version)) return !0; return !!t._dirty } function yO(t) { if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === sl)) return; t.globalVersion = sl; const e = t.dep; if (t.flags |= 2, e.version > 0 && !t.isSSR && t.deps && !Eh(t)) { t.flags &= -3; return } const n = qe, i = Rn; qe = t, Rn = !0; try { mO(t); const r = t.fn(t._value); (e.version === 0 || lr(r, t._value)) && (t._value = r, e.version++) } catch (r) { throw e.version++, r } finally { qe = n, Rn = i, vO(t), t.flags &= -3 } } function kp(t, e = !1) { const { dep: n, prevSub: i, nextSub: r } = t; if (i && (i.nextSub = r, t.prevSub = void 0), r && (r.prevSub = i, t.nextSub = void 0), n.subs === t && (n.subs = i), !n.subs && n.computed) { n.computed.flags &= -5; for (let o = n.computed.deps; o; o = o.nextDep)kp(o, !0) } !e && !--n.sc && n.map && n.map.delete(n.key) } function m$(t) { const { prevDep: e, nextDep: n } = t; e && (e.nextDep = n, t.prevDep = void 0), n && (n.prevDep = e, t.nextDep = void 0) } let Rn = !0; const bO = []; function gr() { bO.push(Rn), Rn = !1 } function mr() { const t = bO.pop(); Rn = t === void 0 ? !0 : t } function fm(t) { const { cleanup: e } = t; if (t.cleanup = void 0, e) { const n = qe; qe = void 0; try { e() } finally { qe = n } } } let sl = 0; class v$ { constructor(e, n) { this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Pp { constructor(e) { this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(e) { if (!qe || !Rn || qe === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== qe) n = this.activeLink = new v$(qe, this), qe.deps ? (n.prevDep = qe.depsTail, qe.depsTail.nextDep = n, qe.depsTail = n) : qe.deps = qe.depsTail = n, OO(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const i = n.nextDep; i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = qe.depsTail, n.nextDep = void 0, qe.depsTail.nextDep = n, qe.depsTail = n, qe.deps === n && (qe.deps = i) } return n } trigger(e) { this.version++, sl++, this.notify(e) } notify(e) { Tp(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { $p() } } } function OO(t) { if (t.dep.sc++, t.sub.flags & 4) { const e = t.dep.computed; if (e && !t.dep.subs) { e.flags |= 20; for (let i = e.deps; i; i = i.nextDep)OO(i) } const n = t.dep.subs; n !== t && (t.prevSub = n, n && (n.nextSub = t)), t.dep.subs = t } } const Oc = new WeakMap, Lr = Symbol(""), _h = Symbol(""), ll = Symbol(""); function Rt(t, e, n) { if (Rn && qe) { let i = Oc.get(t); i || Oc.set(t, i = new Map); let r = i.get(n); r || (i.set(n, r = new Pp), r.map = i, r.key = n), r.track() } } function $i(t, e, n, i, r, o) { const s = Oc.get(t); if (!s) { sl++; return } const l = a => { a && a.trigger() }; if (Tp(), e === "clear") s.forEach(l); else { const a = be(t), c = a && xp(n); if (a && n === "length") { const u = Number(i); s.forEach((f, h) => { (h === "length" || h === ll || !pr(h) && h >= u) && l(f) }) } else switch (n !== void 0 && l(s.get(n)), c && l(s.get(ll)), e) { case "add": a ? c && l(s.get("length")) : (l(s.get(Lr)), To(t) && l(s.get(_h))); break; case "delete": a || (l(s.get(Lr)), To(t) && l(s.get(_h))); break; case "set": To(t) && l(s.get(Lr)); break } } $p() } function y$(t, e) { const n = Oc.get(t); return n && n.get(e) } function lo(t) { const e = Re(t); return e === t ? e : (Rt(e, "iterate", ll), In(t) ? e : e.map(Lt)) } function Ap(t) { return Rt(t = Re(t), "iterate", ll), t } const b$ = { __proto__: null, [Symbol.iterator]() { return vf(this, Symbol.iterator, Lt) }, concat(...t) { return lo(this).concat(...t.map(e => be(e) ? lo(e) : e)) }, entries() { return vf(this, "entries", t => (t[1] = Lt(t[1]), t)) }, every(t, e) { return di(this, "every", t, e, void 0, arguments) }, filter(t, e) { return di(this, "filter", t, e, n => n.map(Lt), arguments) }, find(t, e) { return di(this, "find", t, e, Lt, arguments) }, findIndex(t, e) { return di(this, "findIndex", t, e, void 0, arguments) }, findLast(t, e) { return di(this, "findLast", t, e, Lt, arguments) }, findLastIndex(t, e) { return di(this, "findLastIndex", t, e, void 0, arguments) }, forEach(t, e) { return di(this, "forEach", t, e, void 0, arguments) }, includes(...t) { return yf(this, "includes", t) }, indexOf(...t) { return yf(this, "indexOf", t) }, join(t) { return lo(this).join(t) }, lastIndexOf(...t) { return yf(this, "lastIndexOf", t) }, map(t, e) { return di(this, "map", t, e, void 0, arguments) }, pop() { return ms(this, "pop") }, push(...t) { return ms(this, "push", t) }, reduce(t, ...e) { return hm(this, "reduce", t, e) }, reduceRight(t, ...e) { return hm(this, "reduceRight", t, e) }, shift() { return ms(this, "shift") }, some(t, e) { return di(this, "some", t, e, void 0, arguments) }, splice(...t) { return ms(this, "splice", t) }, toReversed() { return lo(this).toReversed() }, toSorted(t) { return lo(this).toSorted(t) }, toSpliced(...t) { return lo(this).toSpliced(...t) }, unshift(...t) { return ms(this, "unshift", t) }, values() { return vf(this, "values", Lt) } }; function vf(t, e, n) { const i = Ap(t), r = i[e](); return i !== t && !In(t) && (r._next = r.next, r.next = () => { const o = r._next(); return o.value && (o.value = n(o.value)), o }), r } const O$ = Array.prototype; function di(t, e, n, i, r, o) { const s = Ap(t), l = s !== t && !In(t), a = s[e]; if (a !== O$[e]) { const f = a.apply(t, o); return l ? Lt(f) : f } let c = n; s !== t && (l ? c = function (f, h) { return n.call(this, Lt(f), h, t) } : n.length > 2 && (c = function (f, h) { return n.call(this, f, h, t) })); const u = a.call(s, c, i); return l && r ? r(u) : u } function hm(t, e, n, i) { const r = Ap(t); let o = n; return r !== t && (In(t) ? n.length > 3 && (o = function (s, l, a) { return n.call(this, s, l, a, t) }) : o = function (s, l, a) { return n.call(this, s, Lt(l), a, t) }), r[e](o, ...i) } function yf(t, e, n) { const i = Re(t); Rt(i, "iterate", ll); const r = i[e](...n); return (r === -1 || r === !1) && Rp(n[0]) ? (n[0] = Re(n[0]), i[e](...n)) : r } function ms(t, e, n = []) { gr(), Tp(); const i = Re(t)[e].apply(t, n); return $p(), mr(), i } const S$ = bp("__proto__,__v_isRef,__isVue"), SO = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(pr)); function x$(t) { pr(t) || (t = String(t)); const e = Re(this); return Rt(e, "has", t), e.hasOwnProperty(t) } class xO { constructor(e = !1, n = !1) { this._isReadonly = e, this._isShallow = n } get(e, n, i) { const r = this._isReadonly, o = this._isShallow; if (n === "__v_isReactive") return !r; if (n === "__v_isReadonly") return r; if (n === "__v_isShallow") return o; if (n === "__v_raw") return i === (r ? o ? D$ : $O : o ? TO : CO).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0; const s = be(e); if (!r) { let a; if (s && (a = b$[n])) return a; if (n === "hasOwnProperty") return x$ } const l = Reflect.get(e, n, mt(e) ? e : i); return (pr(n) ? SO.has(n) : S$(n)) || (r || Rt(e, "get", n), o) ? l : mt(l) ? s && xp(n) ? l : l.value : Ye(l) ? r ? kO(l) : eo(l) : l } } class wO extends xO { constructor(e = !1) { super(!1, e) } set(e, n, i, r) { let o = e[n]; if (!this._isShallow) { const a = Hr(o); if (!In(i) && !Hr(i) && (o = Re(o), i = Re(i)), !be(e) && mt(o) && !mt(i)) return a ? !1 : (o.value = i, !0) } const s = be(e) && xp(n) ? Number(n) < e.length : Ne(e, n), l = Reflect.set(e, n, i, mt(e) ? e : r); return e === Re(r) && (s ? lr(i, o) && $i(e, "set", n, i) : $i(e, "add", n, i)), l } deleteProperty(e, n) { const i = Ne(e, n); e[n]; const r = Reflect.deleteProperty(e, n); return r && i && $i(e, "delete", n, void 0), r } has(e, n) { const i = Reflect.has(e, n); return (!pr(n) || !SO.has(n)) && Rt(e, "has", n), i } ownKeys(e) { return Rt(e, "iterate", be(e) ? "length" : Lr), Reflect.ownKeys(e) } } class w$ extends xO { constructor(e = !1) { super(!0, e) } set(e, n) { return !0 } deleteProperty(e, n) { return !0 } } const C$ = new wO, T$ = new w$, $$ = new wO(!0), Mp = t => t, wu = t => Reflect.getPrototypeOf(t); function ta(t, e, n = !1, i = !1) { t = t.__v_raw; const r = Re(t), o = Re(e); n || (lr(e, o) && Rt(r, "get", e), Rt(r, "get", o)); const { has: s } = wu(r), l = i ? Mp : n ? Ip : Lt; if (s.call(r, e)) return l(t.get(e)); if (s.call(r, o)) return l(t.get(o)); t !== r && t.get(e) } function na(t, e = !1) { const n = this.__v_raw, i = Re(n), r = Re(t); return e || (lr(t, r) && Rt(i, "has", t), Rt(i, "has", r)), t === r ? n.has(t) : n.has(t) || n.has(r) } function ia(t, e = !1) { return t = t.__v_raw, !e && Rt(Re(t), "iterate", Lr), Reflect.get(t, "size", t) } function dm(t, e = !1) { !e && !In(t) && !Hr(t) && (t = Re(t)); const n = Re(this); return wu(n).has.call(n, t) || (n.add(t), $i(n, "add", t, t)), this } function pm(t, e, n = !1) { !n && !In(e) && !Hr(e) && (e = Re(e)); const i = Re(this), { has: r, get: o } = wu(i); let s = r.call(i, t); s || (t = Re(t), s = r.call(i, t)); const l = o.call(i, t); return i.set(t, e), s ? lr(e, l) && $i(i, "set", t, e) : $i(i, "add", t, e), this } function gm(t) { const e = Re(this), { has: n, get: i } = wu(e); let r = n.call(e, t); r || (t = Re(t), r = n.call(e, t)), i && i.call(e, t); const o = e.delete(t); return r && $i(e, "delete", t, void 0), o } function mm() { const t = Re(this), e = t.size !== 0, n = t.clear(); return e && $i(t, "clear", void 0, void 0), n } function ra(t, e) { return function (i, r) { const o = this, s = o.__v_raw, l = Re(s), a = e ? Mp : t ? Ip : Lt; return !t && Rt(l, "iterate", Lr), s.forEach((c, u) => i.call(r, a(c), a(u), o)) } } function oa(t, e, n) { return function (...i) { const r = this.__v_raw, o = Re(r), s = To(o), l = t === "entries" || t === Symbol.iterator && s, a = t === "keys" && s, c = r[t](...i), u = n ? Mp : e ? Ip : Lt; return !e && Rt(o, "iterate", a ? _h : Lr), { next() { const { value: f, done: h } = c.next(); return h ? { value: f, done: h } : { value: l ? [u(f[0]), u(f[1])] : u(f), done: h } }, [Symbol.iterator]() { return this } } } } function zi(t) { return function (...e) { return t === "delete" ? !1 : t === "clear" ? void 0 : this } } function k$() { const t = { get(o) { return ta(this, o) }, get size() { return ia(this) }, has: na, add: dm, set: pm, delete: gm, clear: mm, forEach: ra(!1, !1) }, e = { get(o) { return ta(this, o, !1, !0) }, get size() { return ia(this) }, has: na, add(o) { return dm.call(this, o, !0) }, set(o, s) { return pm.call(this, o, s, !0) }, delete: gm, clear: mm, forEach: ra(!1, !0) }, n = { get(o) { return ta(this, o, !0) }, get size() { return ia(this, !0) }, has(o) { return na.call(this, o, !0) }, add: zi("add"), set: zi("set"), delete: zi("delete"), clear: zi("clear"), forEach: ra(!0, !1) }, i = { get(o) { return ta(this, o, !0, !0) }, get size() { return ia(this, !0) }, has(o) { return na.call(this, o, !0) }, add: zi("add"), set: zi("set"), delete: zi("delete"), clear: zi("clear"), forEach: ra(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(o => { t[o] = oa(o, !1, !1), n[o] = oa(o, !0, !1), e[o] = oa(o, !1, !0), i[o] = oa(o, !0, !0) }), [t, n, e, i] } const [P$, A$, M$, E$] = k$(); function Ep(t, e) { const n = e ? t ? E$ : M$ : t ? A$ : P$; return (i, r, o) => r === "__v_isReactive" ? !t : r === "__v_isReadonly" ? t : r === "__v_raw" ? i : Reflect.get(Ne(n, r) && r in i ? n : i, r, o) } const _$ = { get: Ep(!1, !1) }, R$ = { get: Ep(!1, !0) }, I$ = { get: Ep(!0, !1) }, CO = new WeakMap, TO = new WeakMap, $O = new WeakMap, D$ = new WeakMap; function B$(t) { switch (t) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function L$(t) { return t.__v_skip || !Object.isExtensible(t) ? 0 : B$(i$(t)) } function eo(t) { return Hr(t) ? t : _p(t, !1, C$, _$, CO) } function Q$(t) { return _p(t, !1, $$, R$, TO) } function kO(t) { return _p(t, !0, T$, I$, $O) } function _p(t, e, n, i, r) { if (!Ye(t) || t.__v_raw && !(e && t.__v_isReactive)) return t; const o = r.get(t); if (o) return o; const s = L$(t); if (s === 0) return t; const l = new Proxy(t, s === 2 ? i : n); return r.set(t, l), l } function js(t) { return Hr(t) ? js(t.__v_raw) : !!(t && t.__v_isReactive) } function Hr(t) { return !!(t && t.__v_isReadonly) } function In(t) { return !!(t && t.__v_isShallow) } function Rp(t) { return t ? !!t.__v_raw : !1 } function Re(t) { const e = t && t.__v_raw; return e ? Re(e) : t } function N$(t) { return !Ne(t, "__v_skip") && Object.isExtensible(t) && aO(t, "__v_skip", !0), t } const Lt = t => Ye(t) ? eo(t) : t, Ip = t => Ye(t) ? kO(t) : t; function mt(t) { return t ? t.__v_isRef === !0 : !1 } function he(t) { return PO(t, !1) } function oe(t) { return PO(t, !0) } function PO(t, e) { return mt(t) ? t : new z$(t, e) } class z$ { constructor(e, n) { this.dep = new Pp, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : Re(e), this._value = n ? e : Lt(e), this.__v_isShallow = n } get value() { return this.dep.track(), this._value } set value(e) { const n = this._rawValue, i = this.__v_isShallow || In(e) || Hr(e); e = i ? e : Re(e), lr(e, n) && (this._rawValue = e, this._value = i ? e : Lt(e), this.dep.trigger()) } } function gt(t) { return mt(t) ? t.value : t } const W$ = { get: (t, e, n) => e === "__v_raw" ? t : gt(Reflect.get(t, e, n)), set: (t, e, n, i) => { const r = t[e]; return mt(r) && !mt(n) ? (r.value = n, !0) : Reflect.set(t, e, n, i) } }; function AO(t) { return js(t) ? t : new Proxy(t, W$) } class H$ { constructor(e, n, i) { this._object = e, this._key = n, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0 } get value() { const e = this._object[this._key]; return this._value = e === void 0 ? this._defaultValue : e } set value(e) { this._object[this._key] = e } get dep() { return y$(Re(this._object), this._key) } } class F$ { constructor(e) { this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } } function Rh(t, e, n) { return mt(t) ? t : xe(t) ? new F$(t) : Ye(t) && arguments.length > 1 ? j$(t, e, n) : he(t) } function j$(t, e, n) { const i = t[e]; return mt(i) ? i : new H$(t, e, n) } class q$ { constructor(e, n, i) { this.fn = e, this.setter = n, this._value = void 0, this.dep = new Pp(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = sl - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i } notify() { if (this.flags |= 16, !(this.flags & 8) && qe !== this) return gO(this, !0), !0 } get value() { const e = this.dep.track(); return yO(this), e && (e.version = this.dep.version), this._value } set value(e) { this.setter && this.setter(e) } } function V$(t, e, n = !1) { let i, r; return xe(t) ? i = t : (i = t.get, r = t.set), new q$(i, r, n) } const sa = {}, Sc = new WeakMap; let kr; function X$(t, e = !1, n = kr) { if (n) { let i = Sc.get(n); i || Sc.set(n, i = []), i.push(t) } } function U$(t, e, n = We) { const { immediate: i, deep: r, once: o, scheduler: s, augmentJob: l, call: a } = n, c = w => r ? w : In(w) || r === !1 || r === 0 ? wi(w, 1) : wi(w); let u, f, h, d, p = !1, g = !1; if (mt(t) ? (f = () => t.value, p = In(t)) : js(t) ? (f = () => c(t), p = !0) : be(t) ? (g = !0, p = t.some(w => js(w) || In(w)), f = () => t.map(w => { if (mt(w)) return w.value; if (js(w)) return c(w); if (xe(w)) return a ? a(w, 2) : w() })) : xe(t) ? e ? f = a ? () => a(t, 2) : t : f = () => { if (h) { gr(); try { h() } finally { mr() } } const w = kr; kr = u; try { return a ? a(t, 3, [d]) : t(d) } finally { kr = w } } : f = _n, e && r) { const w = f, y = r === !0 ? 1 / 0 : r; f = () => wi(w(), y) } const m = g$(), v = () => { u.stop(), m && Sp(m.effects, u) }; if (o && e) { const w = e; e = (...y) => { w(...y), v() } } let b = g ? new Array(t.length).fill(sa) : sa; const x = w => { if (!(!(u.flags & 1) || !u.dirty && !w)) if (e) { const y = u.run(); if (r || p || (g ? y.some((C, O) => lr(C, b[O])) : lr(y, b))) { h && h(); const C = kr; kr = u; try { const O = [y, b === sa ? void 0 : g && b[0] === sa ? [] : b, d]; a ? a(e, 3, O) : e(...O), b = y } finally { kr = C } } } else u.run() }; return l && l(x), u = new dO(f), u.scheduler = s ? () => s(x, !1) : x, d = w => X$(w, !1, u), h = u.onStop = () => { const w = Sc.get(u); if (w) { if (a) a(w, 4); else for (const y of w) y(); Sc.delete(u) } }, e ? i ? x(!0) : b = u.run() : s ? s(x.bind(null, !0), !0) : u.run(), v.pause = u.pause.bind(u), v.resume = u.resume.bind(u), v.stop = v, v } function wi(t, e = 1 / 0, n) { if (e <= 0 || !Ye(t) || t.__v_skip || (n = n || new Set, n.has(t))) return t; if (n.add(t), e--, mt(t)) wi(t.value, e, n); else if (be(t)) for (let i = 0; i < t.length; i++)wi(t[i], e, n); else if (rO(t) || To(t)) t.forEach(i => { wi(i, e, n) }); else if (lO(t)) { for (const i in t) wi(t[i], e, n); for (const i of Object.getOwnPropertySymbols(t)) Object.prototype.propertyIsEnumerable.call(t, i) && wi(t[i], e, n) } return t }/**
* @vue/runtime-core v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function zl(t, e, n, i) { try { return i ? t(...i) : t() } catch (r) { Cu(r, e, n) } } function Bn(t, e, n, i) { if (xe(t)) { const r = zl(t, e, n, i); return r && oO(r) && r.catch(o => { Cu(o, e, n) }), r } if (be(t)) { const r = []; for (let o = 0; o < t.length; o++)r.push(Bn(t[o], e, n, i)); return r } } function Cu(t, e, n, i = !0) { const r = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: s } = e && e.appContext.config || We; if (e) { let l = e.parent; const a = e.proxy, c = `https://vuejs.org/error-reference/#runtime-${n}`; for (; l;) { const u = l.ec; if (u) { for (let f = 0; f < u.length; f++)if (u[f](t, a, c) === !1) return } l = l.parent } if (o) { gr(), zl(o, null, 10, [t, a, c]), mr(); return } } G$(t, n, r, i, s) } function G$(t, e, n, i = !0, r = !1) { if (r) throw t; console.error(t) } const Qt = []; let Xn = -1; const $o = []; let Fi = null, po = 0; const MO = Promise.resolve(); let xc = null; function ri(t) { const e = xc || MO; return t ? e.then(this ? t.bind(this) : t) : e } function K$(t) { let e = Xn + 1, n = Qt.length; for (; e < n;) { const i = e + n >>> 1, r = Qt[i], o = al(r); o < t || o === t && r.flags & 2 ? e = i + 1 : n = i } return e } function Dp(t) { if (!(t.flags & 1)) { const e = al(t), n = Qt[Qt.length - 1]; !n || !(t.flags & 2) && e >= al(n) ? Qt.push(t) : Qt.splice(K$(e), 0, t), t.flags |= 1, EO() } } function EO() { xc || (xc = MO.then(RO)) } function Y$(t) { be(t) ? $o.push(...t) : Fi && t.id === -1 ? Fi.splice(po + 1, 0, t) : t.flags & 1 || ($o.push(t), t.flags |= 1), EO() } function vm(t, e, n = Xn + 1) { for (; n < Qt.length; n++) { const i = Qt[n]; if (i && i.flags & 2) { if (t && i.id !== t.uid) continue; Qt.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2) } } } function _O(t) { if ($o.length) { const e = [...new Set($o)].sort((n, i) => al(n) - al(i)); if ($o.length = 0, Fi) { Fi.push(...e); return } for (Fi = e, po = 0; po < Fi.length; po++) { const n = Fi[po]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } Fi = null, po = 0 } } const al = t => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id; function RO(t) { const e = _n; try { for (Xn = 0; Xn < Qt.length; Xn++) { const n = Qt[Xn]; n && !(n.flags & 8) && (n.flags & 4 && (n.flags &= -2), zl(n, n.i, n.i ? 15 : 14), n.flags & 4 || (n.flags &= -2)) } } finally { for (; Xn < Qt.length; Xn++) { const n = Qt[Xn]; n && (n.flags &= -2) } Xn = -1, Qt.length = 0, _O(), xc = null, (Qt.length || $o.length) && RO() } } let Gt = null, IO = null; function wc(t) { const e = Gt; return Gt = t, IO = t && t.type.__scopeId || null, e } function kn(t, e = Gt, n) { if (!e || t._n) return t; const i = (...r) => { i._d && Am(-1); const o = wc(e); let s; try { s = t(...r) } finally { wc(o), i._d && Am(1) } return s }; return i._n = !0, i._c = !0, i._d = !0, i } function Bp(t, e) { if (Gt === null) return t; const n = Au(Gt), i = t.dirs || (t.dirs = []); for (let r = 0; r < e.length; r++) { let [o, s, l, a = We] = e[r]; o && (xe(o) && (o = { mounted: o, updated: o }), o.deep && wi(s), i.push({ dir: o, instance: n, value: s, oldValue: void 0, arg: l, modifiers: a })) } return t } function Or(t, e, n, i) { const r = t.dirs, o = e && e.dirs; for (let s = 0; s < r.length; s++) { const l = r[s]; o && (l.oldValue = o[s].value); let a = l.dir[i]; a && (gr(), Bn(a, n, 8, [t.el, l, t, e]), mr()) } } const DO = Symbol("_vte"), BO = t => t.__isTeleport, qs = t => t && (t.disabled || t.disabled === ""), Z$ = t => t && (t.defer || t.defer === ""), ym = t => typeof SVGElement < "u" && t instanceof SVGElement, bm = t => typeof MathMLElement == "function" && t instanceof MathMLElement, Ih = (t, e) => { const n = t && t.to; return it(n) ? e ? e(n) : null : n }, J$ = { name: "Teleport", __isTeleport: !0, process(t, e, n, i, r, o, s, l, a, c) { const { mc: u, pc: f, pbc: h, o: { insert: d, querySelector: p, createText: g, createComment: m } } = c, v = qs(e.props); let { shapeFlag: b, children: x, dynamicChildren: w } = e; if (t == null) { const y = e.el = g(""), C = e.anchor = g(""); d(y, n, i), d(C, n, i); const O = (M, A) => { b & 16 && (r && r.isCE && (r.ce._teleportTarget = M), u(x, M, A, r, o, s, l, a)) }, P = () => { const M = e.target = Ih(e.props, p), A = QO(M, e, g, d); M && (s !== "svg" && ym(M) ? s = "svg" : s !== "mathml" && bm(M) && (s = "mathml"), v || (O(M, A), Ga(e))) }; v && (O(n, C), Ga(e)), Z$(e.props) ? jt(P, o) : P() } else { e.el = t.el, e.targetStart = t.targetStart; const y = e.anchor = t.anchor, C = e.target = t.target, O = e.targetAnchor = t.targetAnchor, P = qs(t.props), M = P ? n : C, A = P ? y : O; if (s === "svg" || ym(C) ? s = "svg" : (s === "mathml" || bm(C)) && (s = "mathml"), w ? (h(t.dynamicChildren, w, M, r, o, s, l), Np(t, e, !0)) : a || f(t, e, M, A, r, o, s, l, !1), v) P ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : la(e, n, y, c, 1); else if ((e.props && e.props.to) !== (t.props && t.props.to)) { const B = e.target = Ih(e.props, p); B && la(e, B, null, c, 0) } else P && la(e, C, O, c, 1); Ga(e) } }, remove(t, e, n, { um: i, o: { remove: r } }, o) { const { shapeFlag: s, children: l, anchor: a, targetStart: c, targetAnchor: u, target: f, props: h } = t; if (f && (r(c), r(u)), o && r(a), s & 16) { const d = o || !qs(h); for (let p = 0; p < l.length; p++) { const g = l[p]; i(g, e, n, d, !!g.dynamicChildren) } } }, move: la, hydrate: ek }; function la(t, e, n, { o: { insert: i }, m: r }, o = 2) { o === 0 && i(t.targetAnchor, e, n); const { el: s, anchor: l, shapeFlag: a, children: c, props: u } = t, f = o === 2; if (f && i(s, e, n), (!f || qs(u)) && a & 16) for (let h = 0; h < c.length; h++)r(c[h], e, n, 2); f && i(l, e, n) } function ek(t, e, n, i, r, o, { o: { nextSibling: s, parentNode: l, querySelector: a, insert: c, createText: u } }, f) { const h = e.target = Ih(e.props, a); if (h) { const d = h._lpa || h.firstChild; if (e.shapeFlag & 16) if (qs(e.props)) e.anchor = f(s(t), e, l(t), n, i, r, o), e.targetStart = d, e.targetAnchor = d && s(d); else { e.anchor = s(t); let p = d; for (; p;) { if (p && p.nodeType === 8) { if (p.data === "teleport start anchor") e.targetStart = p; else if (p.data === "teleport anchor") { e.targetAnchor = p, h._lpa = e.targetAnchor && s(e.targetAnchor); break } } p = s(p) } e.targetAnchor || QO(h, e, u, c), f(d && s(d), e, h, n, i, r, o) } Ga(e) } return e.anchor && s(e.anchor) } const LO = J$; function Ga(t) { const e = t.ctx; if (e && e.ut) { let n = t.targetStart; for (; n && n !== t.targetAnchor;)n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling; e.ut() } } function QO(t, e, n, i) { const r = e.targetStart = n(""), o = e.targetAnchor = n(""); return r[DO] = o, t && (i(r, t), i(o, t)), o } const ji = Symbol("_leaveCb"), aa = Symbol("_enterCb"); function tk() { const t = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return vt(() => { t.isMounted = !0 }), At(() => { t.isUnmounting = !0 }), t } const gn = [Function, Array], NO = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: gn, onEnter: gn, onAfterEnter: gn, onEnterCancelled: gn, onBeforeLeave: gn, onLeave: gn, onAfterLeave: gn, onLeaveCancelled: gn, onBeforeAppear: gn, onAppear: gn, onAfterAppear: gn, onAppearCancelled: gn }, zO = t => { const e = t.subTree; return e.component ? zO(e.component) : e }, nk = { name: "BaseTransition", props: NO, setup(t, { slots: e }) { const n = vr(), i = tk(); return () => { const r = e.default && FO(e.default(), !0); if (!r || !r.length) return; const o = WO(r), s = Re(t), { mode: l } = s; if (i.isLeaving) return bf(o); const a = Om(o); if (!a) return bf(o); let c = Dh(a, s, i, n, h => c = h); a.type !== Ut && cl(a, c); const u = n.subTree, f = u && Om(u); if (f && f.type !== Ut && !Ar(a, f) && zO(n).type !== Ut) { const h = Dh(f, s, i, n); if (cl(f, h), l === "out-in" && a.type !== Ut) return i.isLeaving = !0, h.afterLeave = () => { i.isLeaving = !1, n.job.flags & 8 || n.update(), delete h.afterLeave }, bf(o); l === "in-out" && a.type !== Ut && (h.delayLeave = (d, p, g) => { const m = HO(i, f); m[String(f.key)] = f, d[ji] = () => { p(), d[ji] = void 0, delete c.delayedLeave }, c.delayedLeave = g }) } return o } } }; function WO(t) { let e = t[0]; if (t.length > 1) { for (const n of t) if (n.type !== Ut) { e = n; break } } return e } const ik = nk; function HO(t, e) { const { leavingVNodes: n } = t; let i = n.get(e.type); return i || (i = Object.create(null), n.set(e.type, i)), i } function Dh(t, e, n, i, r) { const { appear: o, mode: s, persisted: l = !1, onBeforeEnter: a, onEnter: c, onAfterEnter: u, onEnterCancelled: f, onBeforeLeave: h, onLeave: d, onAfterLeave: p, onLeaveCancelled: g, onBeforeAppear: m, onAppear: v, onAfterAppear: b, onAppearCancelled: x } = e, w = String(t.key), y = HO(n, t), C = (M, A) => { M && Bn(M, i, 9, A) }, O = (M, A) => { const B = A[1]; C(M, A), be(M) ? M.every(R => R.length <= 1) && B() : M.length <= 1 && B() }, P = { mode: s, persisted: l, beforeEnter(M) { let A = a; if (!n.isMounted) if (o) A = m || a; else return; M[ji] && M[ji](!0); const B = y[w]; B && Ar(t, B) && B.el[ji] && B.el[ji](), C(A, [M]) }, enter(M) { let A = c, B = u, R = f; if (!n.isMounted) if (o) A = v || c, B = b || u, R = x || f; else return; let X = !1; const K = M[aa] = _ => { X || (X = !0, _ ? C(R, [M]) : C(B, [M]), P.delayedLeave && P.delayedLeave(), M[aa] = void 0) }; A ? O(A, [M, K]) : K() }, leave(M, A) { const B = String(t.key); if (M[aa] && M[aa](!0), n.isUnmounting) return A(); C(h, [M]); let R = !1; const X = M[ji] = K => { R || (R = !0, A(), K ? C(g, [M]) : C(p, [M]), M[ji] = void 0, y[B] === t && delete y[B]) }; y[B] = t, d ? O(d, [M, X]) : X() }, clone(M) { const A = Dh(M, e, n, i, r); return r && r(A), A } }; return P } function bf(t) { if (Tu(t)) return t = Pi(t), t.children = null, t } function Om(t) { if (!Tu(t)) return BO(t.type) && t.children ? WO(t.children) : t; const { shapeFlag: e, children: n } = t; if (n) { if (e & 16) return n[0]; if (e & 32 && xe(n.default)) return n.default() } } function cl(t, e) { t.shapeFlag & 6 && t.component ? (t.transition = e, cl(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e } function FO(t, e = !1, n) { let i = [], r = 0; for (let o = 0; o < t.length; o++) { let s = t[o]; const l = n == null ? s.key : String(n) + String(s.key != null ? s.key : o); s.type === et ? (s.patchFlag & 128 && r++, i = i.concat(FO(s.children, e, l))) : (e || s.type !== Ut) && i.push(l != null ? Pi(s, { key: l }) : s) } if (r > 1) for (let o = 0; o < i.length; o++)i[o].patchFlag = -2; return i }/*! #__NO_SIDE_EFFECTS__ */function ue(t, e) { return xe(t) ? (() => ht({ name: t.name }, e, { setup: t }))() : t } function jO(t) { t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0] } function Bh(t, e, n, i, r = !1) { if (be(t)) { t.forEach((p, g) => Bh(p, e && (be(e) ? e[g] : e), n, i, r)); return } if (Vs(i) && !r) return; const o = i.shapeFlag & 4 ? Au(i.component) : i.el, s = r ? null : o, { i: l, r: a } = t, c = e && e.r, u = l.refs === We ? l.refs = {} : l.refs, f = l.setupState, h = Re(f), d = f === We ? () => !1 : p => Ne(h, p); if (c != null && c !== a && (it(c) ? (u[c] = null, d(c) && (f[c] = null)) : mt(c) && (c.value = null)), xe(a)) zl(a, l, 12, [s, u]); else { const p = it(a), g = mt(a); if (p || g) { const m = () => { if (t.f) { const v = p ? d(a) ? f[a] : u[a] : a.value; r ? be(v) && Sp(v, o) : be(v) ? v.includes(o) || v.push(o) : p ? (u[a] = [o], d(a) && (f[a] = u[a])) : (a.value = [o], t.k && (u[t.k] = a.value)) } else p ? (u[a] = s, d(a) && (f[a] = s)) : g && (a.value = s, t.k && (u[t.k] = s)) }; s ? (m.id = -1, jt(m, n)) : m() } } } const Vs = t => !!t.type.__asyncLoader, Tu = t => t.type.__isKeepAlive; function rk(t, e) { qO(t, "a", e) } function ok(t, e) { qO(t, "da", e) } function qO(t, e, n = Ct) { const i = t.__wdc || (t.__wdc = () => { let r = n; for (; r;) { if (r.isDeactivated) return; r = r.parent } return t() }); if ($u(e, i, n), n) { let r = n.parent; for (; r && r.parent;)Tu(r.parent.vnode) && sk(i, e, n, r), r = r.parent } } function sk(t, e, n, i) { const r = $u(e, t, i, !0); Wl(() => { Sp(i[e], r) }, n) } function $u(t, e, n = Ct, i = !1) { if (n) { const r = n[t] || (n[t] = []), o = e.__weh || (e.__weh = (...s) => { gr(); const l = Hl(n), a = Bn(e, n, t, s); return l(), mr(), a }); return i ? r.unshift(o) : r.push(o), o } } const _i = t => (e, n = Ct) => { (!Pu || t === "sp") && $u(t, (...i) => e(...i), n) }, VO = _i("bm"), vt = _i("m"), XO = _i("bu"), is = _i("u"), At = _i("bum"), Wl = _i("um"), lk = _i("sp"), ak = _i("rtg"), ck = _i("rtc"); function uk(t, e = Ct) { $u("ec", t, e) } const fk = "components", hk = "directives", dk = Symbol.for("v-ndc"); function pk(t) { return gk(hk, t) } function gk(t, e, n = !0, i = !1) { const r = Gt || Ct; if (r) { const o = r.type; if (t === fk) { const l = rP(o, !1); if (l && (l === e || l === xn(e) || l === xu(xn(e)))) return o } const s = Sm(r[t] || o[t], e) || Sm(r.appContext[t], e); return !s && i ? o : s } } function Sm(t, e) { return t && (t[e] || t[xn(e)] || t[xu(xn(e))]) } const Lh = t => t ? u1(t) ? Au(t) : Lh(t.parent) : null, Xs = ht(Object.create(null), { $: t => t, $el: t => t.vnode.el, $data: t => t.data, $props: t => t.props, $attrs: t => t.attrs, $slots: t => t.slots, $refs: t => t.refs, $parent: t => Lh(t.parent), $root: t => Lh(t.root), $host: t => t.ce, $emit: t => t.emit, $options: t => Lp(t), $forceUpdate: t => t.f || (t.f = () => { Dp(t.update) }), $nextTick: t => t.n || (t.n = ri.bind(t.proxy)), $watch: t => Bk.bind(t) }), Of = (t, e) => t !== We && !t.__isScriptSetup && Ne(t, e), mk = { get({ _: t }, e) { if (e === "__v_skip") return !0; const { ctx: n, setupState: i, data: r, props: o, accessCache: s, type: l, appContext: a } = t; let c; if (e[0] !== "$") { const d = s[e]; if (d !== void 0) switch (d) { case 1: return i[e]; case 2: return r[e]; case 4: return n[e]; case 3: return o[e] } else { if (Of(i, e)) return s[e] = 1, i[e]; if (r !== We && Ne(r, e)) return s[e] = 2, r[e]; if ((c = t.propsOptions[0]) && Ne(c, e)) return s[e] = 3, o[e]; if (n !== We && Ne(n, e)) return s[e] = 4, n[e]; Qh && (s[e] = 0) } } const u = Xs[e]; let f, h; if (u) return e === "$attrs" && Rt(t.attrs, "get", ""), u(t); if ((f = l.__cssModules) && (f = f[e])) return f; if (n !== We && Ne(n, e)) return s[e] = 4, n[e]; if (h = a.config.globalProperties, Ne(h, e)) return h[e] }, set({ _: t }, e, n) { const { data: i, setupState: r, ctx: o } = t; return Of(r, e) ? (r[e] = n, !0) : i !== We && Ne(i, e) ? (i[e] = n, !0) : Ne(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (o[e] = n, !0) }, has({ _: { data: t, setupState: e, accessCache: n, ctx: i, appContext: r, propsOptions: o } }, s) { let l; return !!n[s] || t !== We && Ne(t, s) || Of(e, s) || (l = o[0]) && Ne(l, s) || Ne(i, s) || Ne(Xs, s) || Ne(r.config.globalProperties, s) }, defineProperty(t, e, n) { return n.get != null ? t._.accessCache[e] = 0 : Ne(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n) } }; function xm(t) { return be(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t } let Qh = !0; function vk(t) { const e = Lp(t), n = t.proxy, i = t.ctx; Qh = !1, e.beforeCreate && wm(e.beforeCreate, t, "bc"); const { data: r, computed: o, methods: s, watch: l, provide: a, inject: c, created: u, beforeMount: f, mounted: h, beforeUpdate: d, updated: p, activated: g, deactivated: m, beforeDestroy: v, beforeUnmount: b, destroyed: x, unmounted: w, render: y, renderTracked: C, renderTriggered: O, errorCaptured: P, serverPrefetch: M, expose: A, inheritAttrs: B, components: R, directives: X, filters: K } = e; if (c && yk(c, i, null), s) for (const W in s) { const G = s[W]; xe(G) && (i[W] = G.bind(n)) } if (r) { const W = r.call(n, n); Ye(W) && (t.data = eo(W)) } if (Qh = !0, o) for (const W in o) { const G = o[W], ae = xe(G) ? G.bind(n, n) : xe(G.get) ? G.get.bind(n, n) : _n, ge = !xe(G) && xe(G.set) ? G.set.bind(n) : _n, J = E({ get: ae, set: ge }); Object.defineProperty(i, W, { enumerable: !0, configurable: !0, get: () => J.value, set: ce => J.value = ce }) } if (l) for (const W in l) UO(l[W], i, n, W); if (a) { const W = xe(a) ? a.call(n) : a; Reflect.ownKeys(W).forEach(G => { en(G, W[G]) }) } u && wm(u, t, "c"); function j(W, G) { be(G) ? G.forEach(ae => W(ae.bind(n))) : G && W(G.bind(n)) } if (j(VO, f), j(vt, h), j(XO, d), j(is, p), j(rk, g), j(ok, m), j(uk, P), j(ck, C), j(ak, O), j(At, b), j(Wl, w), j(lk, M), be(A)) if (A.length) { const W = t.exposed || (t.exposed = {}); A.forEach(G => { Object.defineProperty(W, G, { get: () => n[G], set: ae => n[G] = ae }) }) } else t.exposed || (t.exposed = {}); y && t.render === _n && (t.render = y), B != null && (t.inheritAttrs = B), R && (t.components = R), X && (t.directives = X), M && jO(t) } function yk(t, e, n = _n) { be(t) && (t = Nh(t)); for (const i in t) { const r = t[i]; let o; Ye(r) ? "default" in r ? o = Ke(r.from || i, r.default, !0) : o = Ke(r.from || i) : o = Ke(r), mt(o) ? Object.defineProperty(e, i, { enumerable: !0, configurable: !0, get: () => o.value, set: s => o.value = s }) : e[i] = o } } function wm(t, e, n) { Bn(be(t) ? t.map(i => i.bind(e.proxy)) : t.bind(e.proxy), e, n) } function UO(t, e, n, i) { let r = i.includes(".") ? s1(n, i) : () => n[i]; if (it(t)) { const o = e[t]; xe(o) && Te(r, o) } else if (xe(t)) Te(r, t.bind(n)); else if (Ye(t)) if (be(t)) t.forEach(o => UO(o, e, n, i)); else { const o = xe(t.handler) ? t.handler.bind(n) : e[t.handler]; xe(o) && Te(r, o, t) } } function Lp(t) { const e = t.type, { mixins: n, extends: i } = e, { mixins: r, optionsCache: o, config: { optionMergeStrategies: s } } = t.appContext, l = o.get(e); let a; return l ? a = l : !r.length && !n && !i ? a = e : (a = {}, r.length && r.forEach(c => Cc(a, c, s, !0)), Cc(a, e, s)), Ye(e) && o.set(e, a), a } function Cc(t, e, n, i = !1) { const { mixins: r, extends: o } = e; o && Cc(t, o, n, !0), r && r.forEach(s => Cc(t, s, n, !0)); for (const s in e) if (!(i && s === "expose")) { const l = bk[s] || n && n[s]; t[s] = l ? l(t[s], e[s]) : e[s] } return t } const bk = { data: Cm, props: Tm, emits: Tm, methods: _s, computed: _s, beforeCreate: Bt, created: Bt, beforeMount: Bt, mounted: Bt, beforeUpdate: Bt, updated: Bt, beforeDestroy: Bt, beforeUnmount: Bt, destroyed: Bt, unmounted: Bt, activated: Bt, deactivated: Bt, errorCaptured: Bt, serverPrefetch: Bt, components: _s, directives: _s, watch: Sk, provide: Cm, inject: Ok }; function Cm(t, e) { return e ? t ? function () { return ht(xe(t) ? t.call(this, this) : t, xe(e) ? e.call(this, this) : e) } : e : t } function Ok(t, e) { return _s(Nh(t), Nh(e)) } function Nh(t) { if (be(t)) { const e = {}; for (let n = 0; n < t.length; n++)e[t[n]] = t[n]; return e } return t } function Bt(t, e) { return t ? [...new Set([].concat(t, e))] : e } function _s(t, e) { return t ? ht(Object.create(null), t, e) : e } function Tm(t, e) { return t ? be(t) && be(e) ? [...new Set([...t, ...e])] : ht(Object.create(null), xm(t), xm(e ?? {})) : e } function Sk(t, e) { if (!t) return e; if (!e) return t; const n = ht(Object.create(null), t); for (const i in e) n[i] = Bt(t[i], e[i]); return n } function GO() { return { app: null, config: { isNativeTag: t$, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let xk = 0; function wk(t, e) { return function (i, r = null) { xe(i) || (i = ht({}, i)), r != null && !Ye(r) && (r = null); const o = GO(), s = new WeakSet, l = []; let a = !1; const c = o.app = { _uid: xk++, _component: i, _props: r, _container: null, _context: o, _instance: null, version: sP, get config() { return o.config }, set config(u) { }, use(u, ...f) { return s.has(u) || (u && xe(u.install) ? (s.add(u), u.install(c, ...f)) : xe(u) && (s.add(u), u(c, ...f))), c }, mixin(u) { return o.mixins.includes(u) || o.mixins.push(u), c }, component(u, f) { return f ? (o.components[u] = f, c) : o.components[u] }, directive(u, f) { return f ? (o.directives[u] = f, c) : o.directives[u] }, mount(u, f, h) { if (!a) { const d = c._ceVNode || $(i, r); return d.appContext = o, h === !0 ? h = "svg" : h === !1 && (h = void 0), f && e ? e(d, u) : t(d, u, h), a = !0, c._container = u, u.__vue_app__ = c, Au(d.component) } }, onUnmount(u) { l.push(u) }, unmount() { a && (Bn(l, c._instance, 16), t(null, c._container), delete c._container.__vue_app__) }, provide(u, f) { return o.provides[u] = f, c }, runWithContext(u) { const f = ko; ko = c; try { return u() } finally { ko = f } } }; return c } } let ko = null; function en(t, e) { if (Ct) { let n = Ct.provides; const i = Ct.parent && Ct.parent.provides; i === n && (n = Ct.provides = Object.create(i)), n[t] = e } } function Ke(t, e, n = !1) { const i = Ct || Gt; if (i || ko) { const r = ko ? ko._context.provides : i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0; if (r && t in r) return r[t]; if (arguments.length > 1) return n && xe(e) ? e.call(i && i.proxy) : e } } const KO = {}, YO = () => Object.create(KO), ZO = t => Object.getPrototypeOf(t) === KO; function Ck(t, e, n, i = !1) { const r = {}, o = YO(); t.propsDefaults = Object.create(null), JO(t, e, r, o); for (const s in t.propsOptions[0]) s in r || (r[s] = void 0); n ? t.props = i ? r : Q$(r) : t.type.props ? t.props = r : t.props = o, t.attrs = o } function Tk(t, e, n, i) { const { props: r, attrs: o, vnode: { patchFlag: s } } = t, l = Re(r), [a] = t.propsOptions; let c = !1; if ((i || s > 0) && !(s & 16)) { if (s & 8) { const u = t.vnode.dynamicProps; for (let f = 0; f < u.length; f++) { let h = u[f]; if (ku(t.emitsOptions, h)) continue; const d = e[h]; if (a) if (Ne(o, h)) d !== o[h] && (o[h] = d, c = !0); else { const p = xn(h); r[p] = zh(a, l, p, d, t, !1) } else d !== o[h] && (o[h] = d, c = !0) } } } else { JO(t, e, r, o) && (c = !0); let u; for (const f in l) (!e || !Ne(e, f) && ((u = Jr(f)) === f || !Ne(e, u))) && (a ? n && (n[f] !== void 0 || n[u] !== void 0) && (r[f] = zh(a, l, f, void 0, t, !0)) : delete r[f]); if (o !== l) for (const f in o) (!e || !Ne(e, f)) && (delete o[f], c = !0) } c && $i(t.attrs, "set", "") } function JO(t, e, n, i) { const [r, o] = t.propsOptions; let s = !1, l; if (e) for (let a in e) { if (Ws(a)) continue; const c = e[a]; let u; r && Ne(r, u = xn(a)) ? !o || !o.includes(u) ? n[u] = c : (l || (l = {}))[u] = c : ku(t.emitsOptions, a) || (!(a in i) || c !== i[a]) && (i[a] = c, s = !0) } if (o) { const a = Re(n), c = l || We; for (let u = 0; u < o.length; u++) { const f = o[u]; n[f] = zh(r, a, f, c[f], t, !Ne(c, f)) } } return s } function zh(t, e, n, i, r, o) { const s = t[n]; if (s != null) { const l = Ne(s, "default"); if (l && i === void 0) { const a = s.default; if (s.type !== Function && !s.skipFactory && xe(a)) { const { propsDefaults: c } = r; if (n in c) i = c[n]; else { const u = Hl(r); i = c[n] = a.call(null, e), u() } } else i = a; r.ce && r.ce._setProp(n, i) } s[0] && (o && !l ? i = !1 : s[1] && (i === "" || i === Jr(n)) && (i = !0)) } return i } const $k = new WeakMap; function e1(t, e, n = !1) { const i = n ? $k : e.propsCache, r = i.get(t); if (r) return r; const o = t.props, s = {}, l = []; let a = !1; if (!xe(t)) { const u = f => { a = !0; const [h, d] = e1(f, e, !0); ht(s, h), d && l.push(...d) }; !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u) } if (!o && !a) return Ye(t) && i.set(t, Co), Co; if (be(o)) for (let u = 0; u < o.length; u++) { const f = xn(o[u]); $m(f) && (s[f] = We) } else if (o) for (const u in o) { const f = xn(u); if ($m(f)) { const h = o[u], d = s[f] = be(h) || xe(h) ? { type: h } : ht({}, h), p = d.type; let g = !1, m = !0; if (be(p)) for (let v = 0; v < p.length; ++v) { const b = p[v], x = xe(b) && b.name; if (x === "Boolean") { g = !0; break } else x === "String" && (m = !1) } else g = xe(p) && p.name === "Boolean"; d[0] = g, d[1] = m, (g || Ne(d, "default")) && l.push(f) } } const c = [s, l]; return Ye(t) && i.set(t, c), c } function $m(t) { return t[0] !== "$" && !Ws(t) } const t1 = t => t[0] === "_" || t === "$stable", Qp = t => be(t) ? t.map(Gn) : [Gn(t)], kk = (t, e, n) => { if (e._n) return e; const i = kn((...r) => Qp(e(...r)), n); return i._c = !1, i }, n1 = (t, e, n) => { const i = t._ctx; for (const r in t) { if (t1(r)) continue; const o = t[r]; if (xe(o)) e[r] = kk(r, o, i); else if (o != null) { const s = Qp(o); e[r] = () => s } } }, i1 = (t, e) => { const n = Qp(e); t.slots.default = () => n }, r1 = (t, e, n) => { for (const i in e) (n || i !== "_") && (t[i] = e[i]) }, Pk = (t, e, n) => { const i = t.slots = YO(); if (t.vnode.shapeFlag & 32) { const r = e._; r ? (r1(i, e, n), n && aO(i, "_", r, !0)) : n1(e, i) } else e && i1(t, e) }, Ak = (t, e, n) => { const { vnode: i, slots: r } = t; let o = !0, s = We; if (i.shapeFlag & 32) { const l = e._; l ? n && l === 1 ? o = !1 : r1(r, e, n) : (o = !e.$stable, n1(e, r)), s = e } else e && (i1(t, e), s = { default: 1 }); if (o) for (const l in r) !t1(l) && s[l] == null && delete r[l] }, jt = Fk; function Mk(t) { return Ek(t) } function Ek(t, e) { const n = cO(); n.__VUE__ = !0; const { insert: i, remove: r, patchProp: o, createElement: s, createText: l, createComment: a, setText: c, setElementText: u, parentNode: f, nextSibling: h, setScopeId: d = _n, insertStaticContent: p } = t, g = (T, k, D, V = null, q = null, L = null, I = void 0, Q = null, H = !!k.dynamicChildren) => { if (T === k) return; T && !Ar(T, k) && (V = U(T), ce(T, q, L, !0), T = null), k.patchFlag === -2 && (H = !1, k.dynamicChildren = null); const { type: N, ref: te, shapeFlag: Y } = k; switch (N) { case rs: m(T, k, D, V); break; case Ut: v(T, k, D, V); break; case wf: T == null && b(k, D, V, I); break; case et: R(T, k, D, V, q, L, I, Q, H); break; default: Y & 1 ? y(T, k, D, V, q, L, I, Q, H) : Y & 6 ? X(T, k, D, V, q, L, I, Q, H) : (Y & 64 || Y & 128) && N.process(T, k, D, V, q, L, I, Q, H, Pe) }te != null && q && Bh(te, T && T.ref, L, k || T, !k) }, m = (T, k, D, V) => { if (T == null) i(k.el = l(k.children), D, V); else { const q = k.el = T.el; k.children !== T.children && c(q, k.children) } }, v = (T, k, D, V) => { T == null ? i(k.el = a(k.children || ""), D, V) : k.el = T.el }, b = (T, k, D, V) => { [T.el, T.anchor] = p(T.children, k, D, V, T.el, T.anchor) }, x = ({ el: T, anchor: k }, D, V) => { let q; for (; T && T !== k;)q = h(T), i(T, D, V), T = q; i(k, D, V) }, w = ({ el: T, anchor: k }) => { let D; for (; T && T !== k;)D = h(T), r(T), T = D; r(k) }, y = (T, k, D, V, q, L, I, Q, H) => { k.type === "svg" ? I = "svg" : k.type === "math" && (I = "mathml"), T == null ? C(k, D, V, q, L, I, Q, H) : M(T, k, q, L, I, Q, H) }, C = (T, k, D, V, q, L, I, Q) => { let H, N; const { props: te, shapeFlag: Y, transition: re, dirs: fe } = T; if (H = T.el = s(T.type, L, te && te.is, te), Y & 8 ? u(H, T.children) : Y & 16 && P(T.children, H, null, V, q, Sf(T, L), I, Q), fe && Or(T, null, V, "created"), O(H, T, T.scopeId, I, V), te) { for (const Ee in te) Ee !== "value" && !Ws(Ee) && o(H, Ee, null, te[Ee], L, V); "value" in te && o(H, "value", null, te.value, L), (N = te.onVnodeBeforeMount) && Wn(N, V, T) } fe && Or(T, null, V, "beforeMount"); const Se = _k(q, re); Se && re.beforeEnter(H), i(H, k, D), ((N = te && te.onVnodeMounted) || Se || fe) && jt(() => { N && Wn(N, V, T), Se && re.enter(H), fe && Or(T, null, V, "mounted") }, q) }, O = (T, k, D, V, q) => { if (D && d(T, D), V) for (let L = 0; L < V.length; L++)d(T, V[L]); if (q) { let L = q.subTree; if (k === L || a1(L.type) && (L.ssContent === k || L.ssFallback === k)) { const I = q.vnode; O(T, I, I.scopeId, I.slotScopeIds, q.parent) } } }, P = (T, k, D, V, q, L, I, Q, H = 0) => { for (let N = H; N < T.length; N++) { const te = T[N] = Q ? qi(T[N]) : Gn(T[N]); g(null, te, k, D, V, q, L, I, Q) } }, M = (T, k, D, V, q, L, I) => { const Q = k.el = T.el; let { patchFlag: H, dynamicChildren: N, dirs: te } = k; H |= T.patchFlag & 16; const Y = T.props || We, re = k.props || We; let fe; if (D && Sr(D, !1), (fe = re.onVnodeBeforeUpdate) && Wn(fe, D, k, T), te && Or(k, T, D, "beforeUpdate"), D && Sr(D, !0), (Y.innerHTML && re.innerHTML == null || Y.textContent && re.textContent == null) && u(Q, ""), N ? A(T.dynamicChildren, N, Q, D, V, Sf(k, q), L) : I || G(T, k, Q, null, D, V, Sf(k, q), L, !1), H > 0) { if (H & 16) B(Q, Y, re, D, q); else if (H & 2 && Y.class !== re.class && o(Q, "class", null, re.class, q), H & 4 && o(Q, "style", Y.style, re.style, q), H & 8) { const Se = k.dynamicProps; for (let Ee = 0; Ee < Se.length; Ee++) { const ye = Se[Ee], Fe = Y[ye], je = re[ye]; (je !== Fe || ye === "value") && o(Q, ye, Fe, je, q, D) } } H & 1 && T.children !== k.children && u(Q, k.children) } else !I && N == null && B(Q, Y, re, D, q); ((fe = re.onVnodeUpdated) || te) && jt(() => { fe && Wn(fe, D, k, T), te && Or(k, T, D, "updated") }, V) }, A = (T, k, D, V, q, L, I) => { for (let Q = 0; Q < k.length; Q++) { const H = T[Q], N = k[Q], te = H.el && (H.type === et || !Ar(H, N) || H.shapeFlag & 70) ? f(H.el) : D; g(H, N, te, null, V, q, L, I, !0) } }, B = (T, k, D, V, q) => { if (k !== D) { if (k !== We) for (const L in k) !Ws(L) && !(L in D) && o(T, L, k[L], null, q, V); for (const L in D) { if (Ws(L)) continue; const I = D[L], Q = k[L]; I !== Q && L !== "value" && o(T, L, Q, I, q, V) } "value" in D && o(T, "value", k.value, D.value, q) } }, R = (T, k, D, V, q, L, I, Q, H) => { const N = k.el = T ? T.el : l(""), te = k.anchor = T ? T.anchor : l(""); let { patchFlag: Y, dynamicChildren: re, slotScopeIds: fe } = k; fe && (Q = Q ? Q.concat(fe) : fe), T == null ? (i(N, D, V), i(te, D, V), P(k.children || [], D, te, q, L, I, Q, H)) : Y > 0 && Y & 64 && re && T.dynamicChildren ? (A(T.dynamicChildren, re, D, q, L, I, Q), (k.key != null || q && k === q.subTree) && Np(T, k, !0)) : G(T, k, D, te, q, L, I, Q, H) }, X = (T, k, D, V, q, L, I, Q, H) => { k.slotScopeIds = Q, T == null ? k.shapeFlag & 512 ? q.ctx.activate(k, D, V, I, H) : K(k, D, V, q, L, I, H) : _(T, k, H) }, K = (T, k, D, V, q, L, I) => { const Q = T.component = Jk(T, V, q); if (Tu(T) && (Q.ctx.renderer = Pe), eP(Q, !1, I), Q.asyncDep) { if (q && q.registerDep(Q, j, I), !T.el) { const H = Q.subTree = $(Ut); v(null, H, k, D) } } else j(Q, T, k, D, q, L, I) }, _ = (T, k, D) => { const V = k.component = T.component; if (Wk(T, k, D)) if (V.asyncDep && !V.asyncResolved) { W(V, k, D); return } else V.next = k, V.update(); else k.el = T.el, V.vnode = k }, j = (T, k, D, V, q, L, I) => { const Q = () => { if (T.isMounted) { let { next: Y, bu: re, u: fe, parent: Se, vnode: Ee } = T; { const Ot = o1(T); if (Ot) { Y && (Y.el = Ee.el, W(T, Y, I)), Ot.asyncDep.then(() => { T.isUnmounted || Q() }); return } } let ye = Y, Fe; Sr(T, !1), Y ? (Y.el = Ee.el, W(T, Y, I)) : Y = Ee, re && pf(re), (Fe = Y.props && Y.props.onVnodeBeforeUpdate) && Wn(Fe, Se, Y, Ee), Sr(T, !0); const je = xf(T), Dt = T.subTree; T.subTree = je, g(Dt, je, f(Dt.el), U(Dt), T, q, L), Y.el = je.el, ye === null && Hk(T, je.el), fe && jt(fe, q), (Fe = Y.props && Y.props.onVnodeUpdated) && jt(() => Wn(Fe, Se, Y, Ee), q) } else { let Y; const { el: re, props: fe } = k, { bm: Se, m: Ee, parent: ye, root: Fe, type: je } = T, Dt = Vs(k); if (Sr(T, !1), Se && pf(Se), !Dt && (Y = fe && fe.onVnodeBeforeMount) && Wn(Y, ye, k), Sr(T, !0), re && Me) { const Ot = () => { T.subTree = xf(T), Me(re, T.subTree, T, q, null) }; Dt && je.__asyncHydrate ? je.__asyncHydrate(re, T, Ot) : Ot() } else { Fe.ce && Fe.ce._injectChildStyle(je); const Ot = T.subTree = xf(T); g(null, Ot, D, V, T, q, L), k.el = Ot.el } if (Ee && jt(Ee, q), !Dt && (Y = fe && fe.onVnodeMounted)) { const Ot = k; jt(() => Wn(Y, ye, Ot), q) } (k.shapeFlag & 256 || ye && Vs(ye.vnode) && ye.vnode.shapeFlag & 256) && T.a && jt(T.a, q), T.isMounted = !0, k = D = V = null } }; T.scope.on(); const H = T.effect = new dO(Q); T.scope.off(); const N = T.update = H.run.bind(H), te = T.job = H.runIfDirty.bind(H); te.i = T, te.id = T.uid, H.scheduler = () => Dp(te), Sr(T, !0), N() }, W = (T, k, D) => { k.component = T; const V = T.vnode.props; T.vnode = k, T.next = null, Tk(T, k.props, V, D), Ak(T, k.children, D), gr(), vm(T), mr() }, G = (T, k, D, V, q, L, I, Q, H = !1) => { const N = T && T.children, te = T ? T.shapeFlag : 0, Y = k.children, { patchFlag: re, shapeFlag: fe } = k; if (re > 0) { if (re & 128) { ge(N, Y, D, V, q, L, I, Q, H); return } else if (re & 256) { ae(N, Y, D, V, q, L, I, Q, H); return } } fe & 8 ? (te & 16 && Ae(N, q, L), Y !== N && u(D, Y)) : te & 16 ? fe & 16 ? ge(N, Y, D, V, q, L, I, Q, H) : Ae(N, q, L, !0) : (te & 8 && u(D, ""), fe & 16 && P(Y, D, V, q, L, I, Q, H)) }, ae = (T, k, D, V, q, L, I, Q, H) => { T = T || Co, k = k || Co; const N = T.length, te = k.length, Y = Math.min(N, te); let re; for (re = 0; re < Y; re++) { const fe = k[re] = H ? qi(k[re]) : Gn(k[re]); g(T[re], fe, D, null, q, L, I, Q, H) } N > te ? Ae(T, q, L, !0, !1, Y) : P(k, D, V, q, L, I, Q, H, Y) }, ge = (T, k, D, V, q, L, I, Q, H) => { let N = 0; const te = k.length; let Y = T.length - 1, re = te - 1; for (; N <= Y && N <= re;) { const fe = T[N], Se = k[N] = H ? qi(k[N]) : Gn(k[N]); if (Ar(fe, Se)) g(fe, Se, D, null, q, L, I, Q, H); else break; N++ } for (; N <= Y && N <= re;) { const fe = T[Y], Se = k[re] = H ? qi(k[re]) : Gn(k[re]); if (Ar(fe, Se)) g(fe, Se, D, null, q, L, I, Q, H); else break; Y--, re-- } if (N > Y) { if (N <= re) { const fe = re + 1, Se = fe < te ? k[fe].el : V; for (; N <= re;)g(null, k[N] = H ? qi(k[N]) : Gn(k[N]), D, Se, q, L, I, Q, H), N++ } } else if (N > re) for (; N <= Y;)ce(T[N], q, L, !0), N++; else { const fe = N, Se = N, Ee = new Map; for (N = Se; N <= re; N++) { const pt = k[N] = H ? qi(k[N]) : Gn(k[N]); pt.key != null && Ee.set(pt.key, N) } let ye, Fe = 0; const je = re - Se + 1; let Dt = !1, Ot = 0; const Ni = new Array(je); for (N = 0; N < je; N++)Ni[N] = 0; for (N = fe; N <= Y; N++) { const pt = T[N]; if (Fe >= je) { ce(pt, q, L, !0); continue } let tn; if (pt.key != null) tn = Ee.get(pt.key); else for (ye = Se; ye <= re; ye++)if (Ni[ye - Se] === 0 && Ar(pt, k[ye])) { tn = ye; break } tn === void 0 ? ce(pt, q, L, !0) : (Ni[tn - Se] = N + 1, tn >= Ot ? Ot = tn : Dt = !0, g(pt, k[tn], D, null, q, L, I, Q, H), Fe++) } const ps = Dt ? Rk(Ni) : Co; for (ye = ps.length - 1, N = je - 1; N >= 0; N--) { const pt = Se + N, tn = k[pt], so = pt + 1 < te ? k[pt + 1].el : V; Ni[N] === 0 ? g(null, tn, D, so, q, L, I, Q, H) : Dt && (ye < 0 || N !== ps[ye] ? J(tn, D, so, 2) : ye--) } } }, J = (T, k, D, V, q = null) => { const { el: L, type: I, transition: Q, children: H, shapeFlag: N } = T; if (N & 6) { J(T.component.subTree, k, D, V); return } if (N & 128) { T.suspense.move(k, D, V); return } if (N & 64) { I.move(T, k, D, Pe); return } if (I === et) { i(L, k, D); for (let Y = 0; Y < H.length; Y++)J(H[Y], k, D, V); i(T.anchor, k, D); return } if (I === wf) { x(T, k, D); return } if (V !== 2 && N & 1 && Q) if (V === 0) Q.beforeEnter(L), i(L, k, D), jt(() => Q.enter(L), q); else { const { leave: Y, delayLeave: re, afterLeave: fe } = Q, Se = () => i(L, k, D), Ee = () => { Y(L, () => { Se(), fe && fe() }) }; re ? re(L, Se, Ee) : Ee() } else i(L, k, D) }, ce = (T, k, D, V = !1, q = !1) => { const { type: L, props: I, ref: Q, children: H, dynamicChildren: N, shapeFlag: te, patchFlag: Y, dirs: re, cacheIndex: fe } = T; if (Y === -2 && (q = !1), Q != null && Bh(Q, null, D, T, !0), fe != null && (k.renderCache[fe] = void 0), te & 256) { k.ctx.deactivate(T); return } const Se = te & 1 && re, Ee = !Vs(T); let ye; if (Ee && (ye = I && I.onVnodeBeforeUnmount) && Wn(ye, k, T), te & 6) Qe(T.component, D, V); else { if (te & 128) { T.suspense.unmount(D, V); return } Se && Or(T, null, k, "beforeUnmount"), te & 64 ? T.type.remove(T, k, D, Pe, V) : N && !N.hasOnce && (L !== et || Y > 0 && Y & 64) ? Ae(N, k, D, !1, !0) : (L === et && Y & 384 || !q && te & 16) && Ae(H, k, D), V && Oe(T) } (Ee && (ye = I && I.onVnodeUnmounted) || Se) && jt(() => { ye && Wn(ye, k, T), Se && Or(T, null, k, "unmounted") }, D) }, Oe = T => { const { type: k, el: D, anchor: V, transition: q } = T; if (k === et) { Le(D, V); return } if (k === wf) { w(T); return } const L = () => { r(D), q && !q.persisted && q.afterLeave && q.afterLeave() }; if (T.shapeFlag & 1 && q && !q.persisted) { const { leave: I, delayLeave: Q } = q, H = () => I(D, L); Q ? Q(T.el, L, H) : H() } else L() }, Le = (T, k) => { let D; for (; T !== k;)D = h(T), r(T), T = D; r(k) }, Qe = (T, k, D) => { const { bum: V, scope: q, job: L, subTree: I, um: Q, m: H, a: N } = T; km(H), km(N), V && pf(V), q.stop(), L && (L.flags |= 8, ce(I, T, k, D)), Q && jt(Q, k), jt(() => { T.isUnmounted = !0 }, k), k && k.pendingBranch && !k.isUnmounted && T.asyncDep && !T.asyncResolved && T.suspenseId === k.pendingId && (k.deps--, k.deps === 0 && k.resolve()) }, Ae = (T, k, D, V = !1, q = !1, L = 0) => { for (let I = L; I < T.length; I++)ce(T[I], k, D, V, q) }, U = T => { if (T.shapeFlag & 6) return U(T.component.subTree); if (T.shapeFlag & 128) return T.suspense.next(); const k = h(T.anchor || T.el), D = k && k[DO]; return D ? h(D) : k }; let pe = !1; const ve = (T, k, D) => { T == null ? k._vnode && ce(k._vnode, null, null, !0) : g(k._vnode || null, T, k, null, null, null, D), k._vnode = T, pe || (pe = !0, vm(), _O(), pe = !1) }, Pe = { p: g, um: ce, m: J, r: Oe, mt: K, mc: P, pc: G, pbc: A, n: U, o: t }; let Ie, Me; return e && ([Ie, Me] = e(Pe)), { render: ve, hydrate: Ie, createApp: wk(ve, Ie) } } function Sf({ type: t, props: e }, n) { return n === "svg" && t === "foreignObject" || n === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n } function Sr({ effect: t, job: e }, n) { n ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5) } function _k(t, e) { return (!t || t && !t.pendingBranch) && e && !e.persisted } function Np(t, e, n = !1) { const i = t.children, r = e.children; if (be(i) && be(r)) for (let o = 0; o < i.length; o++) { const s = i[o]; let l = r[o]; l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = qi(r[o]), l.el = s.el), !n && l.patchFlag !== -2 && Np(s, l)), l.type === rs && (l.el = s.el) } } function Rk(t) { const e = t.slice(), n = [0]; let i, r, o, s, l; const a = t.length; for (i = 0; i < a; i++) { const c = t[i]; if (c !== 0) { if (r = n[n.length - 1], t[r] < c) { e[i] = r, n.push(i); continue } for (o = 0, s = n.length - 1; o < s;)l = o + s >> 1, t[n[l]] < c ? o = l + 1 : s = l; c < t[n[o]] && (o > 0 && (e[i] = n[o - 1]), n[o] = i) } } for (o = n.length, s = n[o - 1]; o-- > 0;)n[o] = s, s = e[s]; return n } function o1(t) { const e = t.subTree.component; if (e) return e.asyncDep && !e.asyncResolved ? e : o1(e) } function km(t) { if (t) for (let e = 0; e < t.length; e++)t[e].flags |= 8 } const Ik = Symbol.for("v-scx"), Dk = () => Ke(Ik); function hn(t, e) { return zp(t, null, e) } function Te(t, e, n) { return zp(t, e, n) } function zp(t, e, n = We) { const { immediate: i, deep: r, flush: o, once: s } = n, l = ht({}, n); let a; if (Pu) if (o === "sync") { const h = Dk(); a = h.__watcherHandles || (h.__watcherHandles = []) } else if (!e || i) l.once = !0; else { const h = () => { }; return h.stop = _n, h.resume = _n, h.pause = _n, h } const c = Ct; l.call = (h, d, p) => Bn(h, c, d, p); let u = !1; o === "post" ? l.scheduler = h => { jt(h, c && c.suspense) } : o !== "sync" && (u = !0, l.scheduler = (h, d) => { d ? h() : Dp(h) }), l.augmentJob = h => { e && (h.flags |= 4), u && (h.flags |= 2, c && (h.id = c.uid, h.i = c)) }; const f = U$(t, e, l); return a && a.push(f), f } function Bk(t, e, n) { const i = this.proxy, r = it(t) ? t.includes(".") ? s1(i, t) : () => i[t] : t.bind(i, i); let o; xe(e) ? o = e : (o = e.handler, n = e); const s = Hl(this), l = zp(r, o.bind(i), n); return s(), l } function s1(t, e) { const n = e.split("."); return () => { let i = t; for (let r = 0; r < n.length && i; r++)i = i[n[r]]; return i } } const Lk = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${xn(e)}Modifiers`] || t[`${Jr(e)}Modifiers`]; function Qk(t, e, ...n) { if (t.isUnmounted) return; const i = t.vnode.props || We; let r = n; const o = e.startsWith("update:"), s = o && Lk(i, e.slice(7)); s && (s.trim && (r = n.map(u => it(u) ? u.trim() : u)), s.number && (r = n.map(s$))); let l, a = i[l = df(e)] || i[l = df(xn(e))]; !a && o && (a = i[l = df(Jr(e))]), a && Bn(a, t, 6, r); const c = i[l + "Once"]; if (c) { if (!t.emitted) t.emitted = {}; else if (t.emitted[l]) return; t.emitted[l] = !0, Bn(c, t, 6, r) } } function l1(t, e, n = !1) { const i = e.emitsCache, r = i.get(t); if (r !== void 0) return r; const o = t.emits; let s = {}, l = !1; if (!xe(t)) { const a = c => { const u = l1(c, e, !0); u && (l = !0, ht(s, u)) }; !n && e.mixins.length && e.mixins.forEach(a), t.extends && a(t.extends), t.mixins && t.mixins.forEach(a) } return !o && !l ? (Ye(t) && i.set(t, null), null) : (be(o) ? o.forEach(a => s[a] = null) : ht(s, o), Ye(t) && i.set(t, s), s) } function ku(t, e) { return !t || !bu(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Ne(t, e[0].toLowerCase() + e.slice(1)) || Ne(t, Jr(e)) || Ne(t, e)) } function xf(t) { const { type: e, vnode: n, proxy: i, withProxy: r, propsOptions: [o], slots: s, attrs: l, emit: a, render: c, renderCache: u, props: f, data: h, setupState: d, ctx: p, inheritAttrs: g } = t, m = wc(t); let v, b; try { if (n.shapeFlag & 4) { const w = r || i, y = w; v = Gn(c.call(y, w, u, f, d, h, p)), b = l } else { const w = e; v = Gn(w.length > 1 ? w(f, { attrs: l, slots: s, emit: a }) : w(f, null)), b = e.props ? l : Nk(l) } } catch (w) { Us.length = 0, Cu(w, t, 1), v = $(Ut) } let x = v; if (b && g !== !1) { const w = Object.keys(b), { shapeFlag: y } = x; w.length && y & 7 && (o && w.some(Op) && (b = zk(b, o)), x = Pi(x, b, !1, !0)) } return n.dirs && (x = Pi(x, null, !1, !0), x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs), n.transition && cl(x, n.transition), v = x, wc(m), v } const Nk = t => { let e; for (const n in t) (n === "class" || n === "style" || bu(n)) && ((e || (e = {}))[n] = t[n]); return e }, zk = (t, e) => { const n = {}; for (const i in t) (!Op(i) || !(i.slice(9) in e)) && (n[i] = t[i]); return n }; function Wk(t, e, n) { const { props: i, children: r, component: o } = t, { props: s, children: l, patchFlag: a } = e, c = o.emitsOptions; if (e.dirs || e.transition) return !0; if (n && a >= 0) { if (a & 1024) return !0; if (a & 16) return i ? Pm(i, s, c) : !!s; if (a & 8) { const u = e.dynamicProps; for (let f = 0; f < u.length; f++) { const h = u[f]; if (s[h] !== i[h] && !ku(c, h)) return !0 } } } else return (r || l) && (!l || !l.$stable) ? !0 : i === s ? !1 : i ? s ? Pm(i, s, c) : !0 : !!s; return !1 } function Pm(t, e, n) { const i = Object.keys(e); if (i.length !== Object.keys(t).length) return !0; for (let r = 0; r < i.length; r++) { const o = i[r]; if (e[o] !== t[o] && !ku(n, o)) return !0 } return !1 } function Hk({ vnode: t, parent: e }, n) { for (; e;) { const i = e.subTree; if (i.suspense && i.suspense.activeBranch === t && (i.el = t.el), i === t) (t = e.vnode).el = n, e = e.parent; else break } } const a1 = t => t.__isSuspense; function Fk(t, e) { e && e.pendingBranch ? be(t) ? e.effects.push(...t) : e.effects.push(t) : Y$(t) } const et = Symbol.for("v-fgt"), rs = Symbol.for("v-txt"), Ut = Symbol.for("v-cmt"), wf = Symbol.for("v-stc"), Us = []; let un = null; function jk(t = !1) { Us.push(un = t ? null : []) } function qk() { Us.pop(), un = Us[Us.length - 1] || null } let ul = 1; function Am(t) { ul += t, t < 0 && un && (un.hasOnce = !0) } function Vk(t) { return t.dynamicChildren = ul > 0 ? un || Co : null, qk(), ul > 0 && un && un.push(t), t } function Xk(t, e, n, i, r) { return Vk($(t, e, n, i, r, !0)) } function wn(t) { return t ? t.__v_isVNode === !0 : !1 } function Ar(t, e) { return t.type === e.type && t.key === e.key } const c1 = ({ key: t }) => t ?? null, Ka = ({ ref: t, ref_key: e, ref_for: n }) => (typeof t == "number" && (t = "" + t), t != null ? it(t) || mt(t) || xe(t) ? { i: Gt, r: t, k: e, f: !!n } : t : null); function Ya(t, e = null, n = null, i = 0, r = null, o = t === et ? 0 : 1, s = !1, l = !1) { const a = { __v_isVNode: !0, __v_skip: !0, type: t, props: e, key: e && c1(e), ref: e && Ka(e), scopeId: IO, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: o, patchFlag: i, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: Gt }; return l ? (Wp(a, n), o & 128 && t.normalize(a)) : n && (a.shapeFlag |= it(n) ? 8 : 16), ul > 0 && !s && un && (a.patchFlag > 0 || o & 6) && a.patchFlag !== 32 && un.push(a), a } const $ = Uk; function Uk(t, e = null, n = null, i = 0, r = null, o = !1) { if ((!t || t === dk) && (t = Ut), wn(t)) { const l = Pi(t, e, !0); return n && Wp(l, n), ul > 0 && !o && un && (l.shapeFlag & 6 ? un[un.indexOf(t)] = l : un.push(l)), l.patchFlag = -2, l } if (oP(t) && (t = t.__vccOpts), e) { e = Gk(e); let { class: l, style: a } = e; l && !it(l) && (e.class = Cp(l)), Ye(a) && (Rp(a) && !be(a) && (a = ht({}, a)), e.style = wp(a)) } const s = it(t) ? 1 : a1(t) ? 128 : BO(t) ? 64 : Ye(t) ? 4 : xe(t) ? 2 : 0; return Ya(t, e, n, i, r, s, o, !0) } function Gk(t) { return t ? Rp(t) || ZO(t) ? ht({}, t) : t : null } function Pi(t, e, n = !1, i = !1) { const { props: r, ref: o, patchFlag: s, children: l, transition: a } = t, c = e ? Kk(r || {}, e) : r, u = { __v_isVNode: !0, __v_skip: !0, type: t.type, props: c, key: c && c1(c), ref: e && e.ref ? n && o ? be(o) ? o.concat(Ka(e)) : [o, Ka(e)] : Ka(e) : o, scopeId: t.scopeId, slotScopeIds: t.slotScopeIds, children: l, target: t.target, targetStart: t.targetStart, targetAnchor: t.targetAnchor, staticCount: t.staticCount, shapeFlag: t.shapeFlag, patchFlag: e && t.type !== et ? s === -1 ? 16 : s | 16 : s, dynamicProps: t.dynamicProps, dynamicChildren: t.dynamicChildren, appContext: t.appContext, dirs: t.dirs, transition: a, component: t.component, suspense: t.suspense, ssContent: t.ssContent && Pi(t.ssContent), ssFallback: t.ssFallback && Pi(t.ssFallback), el: t.el, anchor: t.anchor, ctx: t.ctx, ce: t.ce }; return a && i && cl(u, a.clone(u)), u } function Wh(t = " ", e = 0) { return $(rs, null, t, e) } function Gn(t) { return t == null || typeof t == "boolean" ? $(Ut) : be(t) ? $(et, null, t.slice()) : wn(t) ? qi(t) : $(rs, null, String(t)) } function qi(t) { return t.el === null && t.patchFlag !== -1 || t.memo ? t : Pi(t) } function Wp(t, e) { let n = 0; const { shapeFlag: i } = t; if (e == null) e = null; else if (be(e)) n = 16; else if (typeof e == "object") if (i & 65) { const r = e.default; r && (r._c && (r._d = !1), Wp(t, r()), r._c && (r._d = !0)); return } else { n = 32; const r = e._; !r && !ZO(e) ? e._ctx = Gt : r === 3 && Gt && (Gt.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024)) } else xe(e) ? (e = { default: e, _ctx: Gt }, n = 32) : (e = String(e), i & 64 ? (n = 16, e = [Wh(e)]) : n = 8); t.children = e, t.shapeFlag |= n } function Kk(...t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = t[n]; for (const r in i) if (r === "class") e.class !== i.class && (e.class = Cp([e.class, i.class])); else if (r === "style") e.style = wp([e.style, i.style]); else if (bu(r)) { const o = e[r], s = i[r]; s && o !== s && !(be(o) && o.includes(s)) && (e[r] = o ? [].concat(o, s) : s) } else r !== "" && (e[r] = i[r]) } return e } function Wn(t, e, n, i = null) { Bn(t, e, 7, [n, i]) } const Yk = GO(); let Zk = 0; function Jk(t, e, n) { const i = t.type, r = (e ? e.appContext : t.appContext) || Yk, o = { uid: Zk++, vnode: t, type: i, parent: e, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new p$(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: e ? e.provides : Object.create(r.provides), ids: e ? e.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: e1(i, r), emitsOptions: l1(i, r), emit: null, emitted: null, propsDefaults: We, inheritAttrs: i.inheritAttrs, ctx: We, data: We, props: We, attrs: We, slots: We, refs: We, setupState: We, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = Qk.bind(null, o), t.ce && t.ce(o), o } let Ct = null; const vr = () => Ct || Gt; let Tc, Hh; { const t = cO(), e = (n, i) => { let r; return (r = t[n]) || (r = t[n] = []), r.push(i), o => { r.length > 1 ? r.forEach(s => s(o)) : r[0](o) } }; Tc = e("__VUE_INSTANCE_SETTERS__", n => Ct = n), Hh = e("__VUE_SSR_SETTERS__", n => Pu = n) } const Hl = t => { const e = Ct; return Tc(t), t.scope.on(), () => { t.scope.off(), Tc(e) } }, Mm = () => { Ct && Ct.scope.off(), Tc(null) }; function u1(t) { return t.vnode.shapeFlag & 4 } let Pu = !1; function eP(t, e = !1, n = !1) { e && Hh(e); const { props: i, children: r } = t.vnode, o = u1(t); Ck(t, i, o, e), Pk(t, r, n); const s = o ? tP(t, e) : void 0; return e && Hh(!1), s } function tP(t, e) { const n = t.type; t.accessCache = Object.create(null), t.proxy = new Proxy(t.ctx, mk); const { setup: i } = n; if (i) { const r = t.setupContext = i.length > 1 ? iP(t) : null, o = Hl(t); gr(); const s = zl(i, t, 0, [t.props, r]); if (mr(), o(), oO(s)) { if (Vs(t) || jO(t), s.then(Mm, Mm), e) return s.then(l => { Em(t, l, e) }).catch(l => { Cu(l, t, 0) }); t.asyncDep = s } else Em(t, s, e) } else f1(t, e) } function Em(t, e, n) { xe(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : Ye(e) && (t.setupState = AO(e)), f1(t, n) } let _m; function f1(t, e, n) { const i = t.type; if (!t.render) { if (!e && _m && !i.render) { const r = i.template || Lp(t).template; if (r) { const { isCustomElement: o, compilerOptions: s } = t.appContext.config, { delimiters: l, compilerOptions: a } = i, c = ht(ht({ isCustomElement: o, delimiters: l }, s), a); i.render = _m(r, c) } } t.render = i.render || _n } { const r = Hl(t); gr(); try { vk(t) } finally { mr(), r() } } } const nP = { get(t, e) { return Rt(t, "get", ""), t[e] } }; function iP(t) { const e = n => { t.exposed = n || {} }; return { attrs: new Proxy(t.attrs, nP), slots: t.slots, emit: t.emit, expose: e } } function Au(t) { return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(AO(N$(t.exposed)), { get(e, n) { if (n in e) return e[n]; if (n in Xs) return Xs[n](t) }, has(e, n) { return n in e || n in Xs } })) : t.proxy } function rP(t, e = !0) { return xe(t) ? t.displayName || t.name : t.name || e && t.__name } function oP(t) { return xe(t) && "__vccOpts" in t } const E = (t, e) => V$(t, e, Pu); function Fr(t, e, n) { const i = arguments.length; return i === 2 ? Ye(e) && !be(e) ? wn(e) ? $(t, null, [e]) : $(t, e) : $(t, null, e) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && wn(n) && (n = [n]), $(t, e, n)) } const sP = "3.5.11";/**
* @vue/runtime-dom v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Fh; const Rm = typeof window < "u" && window.trustedTypes; if (Rm) try { Fh = Rm.createPolicy("vue", { createHTML: t => t }) } catch { } const h1 = Fh ? t => Fh.createHTML(t) : t => t, lP = "http://www.w3.org/2000/svg", aP = "http://www.w3.org/1998/Math/MathML", Si = typeof document < "u" ? document : null, Im = Si && Si.createElement("template"), cP = { insert: (t, e, n) => { e.insertBefore(t, n || null) }, remove: t => { const e = t.parentNode; e && e.removeChild(t) }, createElement: (t, e, n, i) => { const r = e === "svg" ? Si.createElementNS(lP, t) : e === "mathml" ? Si.createElementNS(aP, t) : n ? Si.createElement(t, { is: n }) : Si.createElement(t); return t === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r }, createText: t => Si.createTextNode(t), createComment: t => Si.createComment(t), setText: (t, e) => { t.nodeValue = e }, setElementText: (t, e) => { t.textContent = e }, parentNode: t => t.parentNode, nextSibling: t => t.nextSibling, querySelector: t => Si.querySelector(t), setScopeId(t, e) { t.setAttribute(e, "") }, insertStaticContent(t, e, n, i, r, o) { const s = n ? n.previousSibling : e.lastChild; if (r && (r === o || r.nextSibling)) for (; e.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling));); else { Im.innerHTML = h1(i === "svg" ? `<svg>${t}</svg>` : i === "mathml" ? `<math>${t}</math>` : t); const l = Im.content; if (i === "svg" || i === "mathml") { const a = l.firstChild; for (; a.firstChild;)l.appendChild(a.firstChild); l.removeChild(a) } e.insertBefore(l, n) } return [s ? s.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild] } }, Wi = "transition", vs = "animation", fl = Symbol("_vtc"), d1 = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, uP = ht({}, NO, d1), fP = t => (t.displayName = "Transition", t.props = uP, t), os = fP((t, { slots: e }) => Fr(ik, hP(t), e)), xr = (t, e = []) => { be(t) ? t.forEach(n => n(...e)) : t && t(...e) }, Dm = t => t ? be(t) ? t.some(e => e.length > 1) : t.length > 1 : !1; function hP(t) { const e = {}; for (const R in t) R in d1 || (e[R] = t[R]); if (t.css === !1) return e; const { name: n = "v", type: i, duration: r, enterFromClass: o = `${n}-enter-from`, enterActiveClass: s = `${n}-enter-active`, enterToClass: l = `${n}-enter-to`, appearFromClass: a = o, appearActiveClass: c = s, appearToClass: u = l, leaveFromClass: f = `${n}-leave-from`, leaveActiveClass: h = `${n}-leave-active`, leaveToClass: d = `${n}-leave-to` } = t, p = dP(r), g = p && p[0], m = p && p[1], { onBeforeEnter: v, onEnter: b, onEnterCancelled: x, onLeave: w, onLeaveCancelled: y, onBeforeAppear: C = v, onAppear: O = b, onAppearCancelled: P = x } = e, M = (R, X, K) => { wr(R, X ? u : l), wr(R, X ? c : s), K && K() }, A = (R, X) => { R._isLeaving = !1, wr(R, f), wr(R, d), wr(R, h), X && X() }, B = R => (X, K) => { const _ = R ? O : b, j = () => M(X, R, K); xr(_, [X, j]), Bm(() => { wr(X, R ? a : o), Hi(X, R ? u : l), Dm(_) || Lm(X, i, g, j) }) }; return ht(e, { onBeforeEnter(R) { xr(v, [R]), Hi(R, o), Hi(R, s) }, onBeforeAppear(R) { xr(C, [R]), Hi(R, a), Hi(R, c) }, onEnter: B(!1), onAppear: B(!0), onLeave(R, X) { R._isLeaving = !0; const K = () => A(R, X); Hi(R, f), Hi(R, h), mP(), Bm(() => { R._isLeaving && (wr(R, f), Hi(R, d), Dm(w) || Lm(R, i, m, K)) }), xr(w, [R, K]) }, onEnterCancelled(R) { M(R, !1), xr(x, [R]) }, onAppearCancelled(R) { M(R, !0), xr(P, [R]) }, onLeaveCancelled(R) { A(R), xr(y, [R]) } }) } function dP(t) { if (t == null) return null; if (Ye(t)) return [Cf(t.enter), Cf(t.leave)]; { const e = Cf(t); return [e, e] } } function Cf(t) { return l$(t) } function Hi(t, e) { e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t[fl] || (t[fl] = new Set)).add(e) } function wr(t, e) { e.split(/\s+/).forEach(i => i && t.classList.remove(i)); const n = t[fl]; n && (n.delete(e), n.size || (t[fl] = void 0)) } function Bm(t) { requestAnimationFrame(() => { requestAnimationFrame(t) }) } let pP = 0; function Lm(t, e, n, i) { const r = t._endId = ++pP, o = () => { r === t._endId && i() }; if (n != null) return setTimeout(o, n); const { type: s, timeout: l, propCount: a } = gP(t, e); if (!s) return i(); const c = s + "end"; let u = 0; const f = () => { t.removeEventListener(c, h), o() }, h = d => { d.target === t && ++u >= a && f() }; setTimeout(() => { u < a && f() }, l + 1), t.addEventListener(c, h) } function gP(t, e) { const n = window.getComputedStyle(t), i = p => (n[p] || "").split(", "), r = i(`${Wi}Delay`), o = i(`${Wi}Duration`), s = Qm(r, o), l = i(`${vs}Delay`), a = i(`${vs}Duration`), c = Qm(l, a); let u = null, f = 0, h = 0; e === Wi ? s > 0 && (u = Wi, f = s, h = o.length) : e === vs ? c > 0 && (u = vs, f = c, h = a.length) : (f = Math.max(s, c), u = f > 0 ? s > c ? Wi : vs : null, h = u ? u === Wi ? o.length : a.length : 0); const d = u === Wi && /\b(transform|all)(,|$)/.test(i(`${Wi}Property`).toString()); return { type: u, timeout: f, propCount: h, hasTransform: d } } function Qm(t, e) { for (; t.length < e.length;)t = t.concat(t); return Math.max(...e.map((n, i) => Nm(n) + Nm(t[i]))) } function Nm(t) { return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3 } function mP() { return document.body.offsetHeight } function vP(t, e, n) { const i = t[fl]; i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e } const $c = Symbol("_vod"), p1 = Symbol("_vsh"), g1 = { beforeMount(t, { value: e }, { transition: n }) { t[$c] = t.style.display === "none" ? "" : t.style.display, n && e ? n.beforeEnter(t) : ys(t, e) }, mounted(t, { value: e }, { transition: n }) { n && e && n.enter(t) }, updated(t, { value: e, oldValue: n }, { transition: i }) { !e != !n && (i ? e ? (i.beforeEnter(t), ys(t, !0), i.enter(t)) : i.leave(t, () => { ys(t, !1) }) : ys(t, e)) }, beforeUnmount(t, { value: e }) { ys(t, e) } }; function ys(t, e) { t.style.display = e ? t[$c] : "none", t[p1] = !e } const yP = Symbol(""), bP = /(^|;)\s*display\s*:/; function OP(t, e, n) { const i = t.style, r = it(n); let o = !1; if (n && !r) { if (e) if (it(e)) for (const s of e.split(";")) { const l = s.slice(0, s.indexOf(":")).trim(); n[l] == null && Za(i, l, "") } else for (const s in e) n[s] == null && Za(i, s, ""); for (const s in n) s === "display" && (o = !0), Za(i, s, n[s]) } else if (r) { if (e !== n) { const s = i[yP]; s && (n += ";" + s), i.cssText = n, o = bP.test(n) } } else e && t.removeAttribute("style"); $c in t && (t[$c] = o ? i.display : "", t[p1] && (i.display = "none")) } const zm = /\s*!important$/; function Za(t, e, n) { if (be(n)) n.forEach(i => Za(t, e, i)); else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n); else { const i = SP(t, e); zm.test(n) ? t.setProperty(Jr(i), n.replace(zm, ""), "important") : t[i] = n } } const Wm = ["Webkit", "Moz", "ms"], Tf = {}; function SP(t, e) { const n = Tf[e]; if (n) return n; let i = xn(e); if (i !== "filter" && i in t) return Tf[e] = i; i = xu(i); for (let r = 0; r < Wm.length; r++) { const o = Wm[r] + i; if (o in t) return Tf[e] = o } return e } const Hm = "http://www.w3.org/1999/xlink"; function Fm(t, e, n, i, r, o = d$(e)) { i && e.startsWith("xlink:") ? n == null ? t.removeAttributeNS(Hm, e.slice(6, e.length)) : t.setAttributeNS(Hm, e, n) : n == null || o && !uO(n) ? t.removeAttribute(e) : t.setAttribute(e, o ? "" : pr(n) ? String(n) : n) } function jm(t, e, n, i) { if (e === "innerHTML" || e === "textContent") { n != null && (t[e] = e === "innerHTML" ? h1(n) : n); return } const r = t.tagName; if (e === "value" && r !== "PROGRESS" && !r.includes("-")) { const s = r === "OPTION" ? t.getAttribute("value") || "" : t.value, l = n == null ? t.type === "checkbox" ? "on" : "" : String(n); (s !== l || !("_value" in t)) && (t.value = l), n == null && t.removeAttribute(e), t._value = n; return } let o = !1; if (n === "" || n == null) { const s = typeof t[e]; s === "boolean" ? n = uO(n) : n == null && s === "string" ? (n = "", o = !0) : s === "number" && (n = 0, o = !0) } try { t[e] = n } catch { } o && t.removeAttribute(e) } function xP(t, e, n, i) { t.addEventListener(e, n, i) } function wP(t, e, n, i) { t.removeEventListener(e, n, i) } const qm = Symbol("_vei"); function CP(t, e, n, i, r = null) { const o = t[qm] || (t[qm] = {}), s = o[e]; if (i && s) s.value = i; else { const [l, a] = TP(e); if (i) { const c = o[e] = PP(i, r); xP(t, l, c, a) } else s && (wP(t, l, s, a), o[e] = void 0) } } const Vm = /(?:Once|Passive|Capture)$/; function TP(t) { let e; if (Vm.test(t)) { e = {}; let i; for (; i = t.match(Vm);)t = t.slice(0, t.length - i[0].length), e[i[0].toLowerCase()] = !0 } return [t[2] === ":" ? t.slice(3) : Jr(t.slice(2)), e] } let $f = 0; const $P = Promise.resolve(), kP = () => $f || ($P.then(() => $f = 0), $f = Date.now()); function PP(t, e) { const n = i => { if (!i._vts) i._vts = Date.now(); else if (i._vts <= n.attached) return; Bn(AP(i, n.value), e, 5, [i]) }; return n.value = t, n.attached = kP(), n } function AP(t, e) { if (be(e)) { const n = t.stopImmediatePropagation; return t.stopImmediatePropagation = () => { n.call(t), t._stopped = !0 }, e.map(i => r => !r._stopped && i && i(r)) } else return e } const Xm = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, MP = (t, e, n, i, r, o) => { const s = r === "svg"; e === "class" ? vP(t, i, s) : e === "style" ? OP(t, n, i) : bu(e) ? Op(e) || CP(t, e, n, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : EP(t, e, i, s)) ? (jm(t, e, i), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Fm(t, e, i, s, o, e !== "value")) : t._isVueCE && (/[A-Z]/.test(e) || !it(i)) ? jm(t, xn(e), i) : (e === "true-value" ? t._trueValue = i : e === "false-value" && (t._falseValue = i), Fm(t, e, i, s)) }; function EP(t, e, n, i) { if (i) return !!(e === "innerHTML" || e === "textContent" || e in t && Xm(e) && xe(n)); if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA") return !1; if (e === "width" || e === "height") { const r = t.tagName; if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1 } return Xm(e) && it(n) ? !1 : e in t } const _P = ["ctrl", "shift", "alt", "meta"], RP = { stop: t => t.stopPropagation(), prevent: t => t.preventDefault(), self: t => t.target !== t.currentTarget, ctrl: t => !t.ctrlKey, shift: t => !t.shiftKey, alt: t => !t.altKey, meta: t => !t.metaKey, left: t => "button" in t && t.button !== 0, middle: t => "button" in t && t.button !== 1, right: t => "button" in t && t.button !== 2, exact: (t, e) => _P.some(n => t[`${n}Key`] && !e.includes(n)) }, Um = (t, e) => { const n = t._withMods || (t._withMods = {}), i = e.join("."); return n[i] || (n[i] = (r, ...o) => { for (let s = 0; s < e.length; s++) { const l = RP[e[s]]; if (l && l(r, e)) return } return t(r, ...o) }) }, IP = ht({ patchProp: MP }, cP); let Gm; function m1() { return Gm || (Gm = Mk(IP)) } const jh = (...t) => { m1().render(...t) }, DP = (...t) => { const e = m1().createApp(...t), { mount: n } = e; return e.mount = i => { const r = LP(i); if (!r) return; const o = e._component; !xe(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = ""); const s = n(r, !1, BP(r)); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), s }, e }; function BP(t) { if (t instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && t instanceof MathMLElement) return "mathml" } function LP(t) { return it(t) ? document.querySelector(t) : t } class Be { lineAt(e) { if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`); return this.lineInner(e, !1, 1, 0) } line(e) { if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`); return this.lineInner(e, !0, 1, 0) } replace(e, n, i) { [e, n] = Wo(this, e, n); let r = []; return this.decompose(0, e, r, 2), i.length && i.decompose(0, i.length, r, 3), this.decompose(n, this.length, r, 1), Kn.from(r, this.length - (n - e) + i.length) } append(e) { return this.replace(this.length, this.length, e) } slice(e, n = this.length) { [e, n] = Wo(this, e, n); let i = []; return this.decompose(e, n, i, 0), Kn.from(i, n - e) } eq(e) { if (e == this) return !0; if (e.length != this.length || e.lines != this.lines) return !1; let n = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), r = new Gs(this), o = new Gs(e); for (let s = n, l = n; ;) { if (r.next(s), o.next(s), s = 0, r.lineBreak != o.lineBreak || r.done != o.done || r.value != o.value) return !1; if (l += r.value.length, r.done || l >= i) return !0 } } iter(e = 1) { return new Gs(this, e) } iterRange(e, n = this.length) { return new v1(this, e, n) } iterLines(e, n) { let i; if (e == null) i = this.iter(); else { n == null && (n = this.lines + 1); let r = this.line(e).from; i = this.iterRange(r, Math.max(r, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to)) } return new y1(i) } toString() { return this.sliceString(0) } toJSON() { let e = []; return this.flatten(e), e } constructor() { } static of(e) { if (e.length == 0) throw new RangeError("A document must have at least one line"); return e.length == 1 && !e[0] ? Be.empty : e.length <= 32 ? new tt(e) : Kn.from(tt.split(e, [])) } } class tt extends Be {
        constructor(e, n = QP(e)) { super(), this.text = e, this.length = n } get lines() { return this.text.length } get children() { return null } lineInner(e, n, i, r) { for (let o = 0; ; o++) { let s = this.text[o], l = r + s.length; if ((n ? i : l) >= e) return new NP(r, l, i, s); r = l + 1, i++ } } decompose(e, n, i, r) { let o = e <= 0 && n >= this.length ? this : new tt(Km(this.text, e, n), Math.min(n, this.length) - Math.max(0, e)); if (r & 1) { let s = i.pop(), l = Ja(o.text, s.text.slice(), 0, o.length); if (l.length <= 32) i.push(new tt(l, s.length + o.length)); else { let a = l.length >> 1; i.push(new tt(l.slice(0, a)), new tt(l.slice(a))) } } else i.push(o) } replace(e, n, i) { if (!(i instanceof tt)) return super.replace(e, n, i);[e, n] = Wo(this, e, n); let r = Ja(this.text, Ja(i.text, Km(this.text, 0, e)), n), o = this.length + i.length - (n - e); return r.length <= 32 ? new tt(r, o) : Kn.from(tt.split(r, []), o) } sliceString(e, n = this.length, i = `
`) { [e, n] = Wo(this, e, n); let r = ""; for (let o = 0, s = 0; o <= n && s < this.text.length; s++) { let l = this.text[s], a = o + l.length; o > e && s && (r += i), e < a && n > o && (r += l.slice(Math.max(0, e - o), n - o)), o = a + 1 } return r } flatten(e) { for (let n of this.text) e.push(n) } scanIdentical() { return 0 } static split(e, n) { let i = [], r = -1; for (let o of e) i.push(o), r += o.length + 1, i.length == 32 && (n.push(new tt(i, r)), i = [], r = -1); return r > -1 && n.push(new tt(i, r)), n }
    } class Kn extends Be {
        constructor(e, n) { super(), this.children = e, this.length = n, this.lines = 0; for (let i of e) this.lines += i.lines } lineInner(e, n, i, r) { for (let o = 0; ; o++) { let s = this.children[o], l = r + s.length, a = i + s.lines - 1; if ((n ? a : l) >= e) return s.lineInner(e, n, i, r); r = l + 1, i = a + 1 } } decompose(e, n, i, r) { for (let o = 0, s = 0; s <= n && o < this.children.length; o++) { let l = this.children[o], a = s + l.length; if (e <= a && n >= s) { let c = r & ((s <= e ? 1 : 0) | (a >= n ? 2 : 0)); s >= e && a <= n && !c ? i.push(l) : l.decompose(e - s, n - s, i, c) } s = a + 1 } } replace(e, n, i) { if ([e, n] = Wo(this, e, n), i.lines < this.lines) for (let r = 0, o = 0; r < this.children.length; r++) { let s = this.children[r], l = o + s.length; if (e >= o && n <= l) { let a = s.replace(e - o, n - o, i), c = this.lines - s.lines + a.lines; if (a.lines < c >> 5 - 1 && a.lines > c >> 5 + 1) { let u = this.children.slice(); return u[r] = a, new Kn(u, this.length - (n - e) + i.length) } return super.replace(o, l, a) } o = l + 1 } return super.replace(e, n, i) } sliceString(e, n = this.length, i = `
`) { [e, n] = Wo(this, e, n); let r = ""; for (let o = 0, s = 0; o < this.children.length && s <= n; o++) { let l = this.children[o], a = s + l.length; s > e && o && (r += i), e < a && n > s && (r += l.sliceString(e - s, n - s, i)), s = a + 1 } return r } flatten(e) { for (let n of this.children) n.flatten(e) } scanIdentical(e, n) { if (!(e instanceof Kn)) return 0; let i = 0, [r, o, s, l] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1]; for (; ; r += n, o += n) { if (r == s || o == l) return i; let a = this.children[r], c = e.children[o]; if (a != c) return i + a.scanIdentical(c, n); i += a.length + 1 } } static from(e, n = e.reduce((i, r) => i + r.length + 1, -1)) { let i = 0; for (let d of e) i += d.lines; if (i < 32) { let d = []; for (let p of e) p.flatten(d); return new tt(d, n) } let r = Math.max(32, i >> 5), o = r << 1, s = r >> 1, l = [], a = 0, c = -1, u = []; function f(d) { let p; if (d.lines > o && d instanceof Kn) for (let g of d.children) f(g); else d.lines > s && (a > s || !a) ? (h(), l.push(d)) : d instanceof tt && a && (p = u[u.length - 1]) instanceof tt && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, u[u.length - 1] = new tt(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > r && h(), a += d.lines, c += d.length + 1, u.push(d)) } function h() { a != 0 && (l.push(u.length == 1 ? u[0] : Kn.from(u, c)), c = -1, a = u.length = 0) } for (let d of e) f(d); return h(), l.length == 1 ? l[0] : new Kn(l, n) }
    } Be.empty = new tt([""], 0); function QP(t) { let e = -1; for (let n of t) e += n.length + 1; return e } function Ja(t, e, n = 0, i = 1e9) { for (let r = 0, o = 0, s = !0; o < t.length && r <= i; o++) { let l = t[o], a = r + l.length; a >= n && (a > i && (l = l.slice(0, i - r)), r < n && (l = l.slice(n - r)), s ? (e[e.length - 1] += l, s = !1) : e.push(l)), r = a + 1 } return e } function Km(t, e, n) { return Ja(t, [""], e, n) } class Gs {
        constructor(e, n = 1) { this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof tt ? e.text.length : e.children.length) << 1] } nextInner(e, n) {
            for (this.done = this.lineBreak = !1; ;) {
                let i = this.nodes.length - 1, r = this.nodes[i], o = this.offsets[i], s = o >> 1, l = r instanceof tt ? r.text.length : r.children.length; if (s == (n > 0 ? l : 0)) { if (i == 0) return this.done = !0, this.value = "", this; n > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop() } else if ((o & 1) == (n > 0 ? 0 : 1)) {
                    if (this.offsets[i] += n, e == 0) return this.lineBreak = !0, this.value = `
`, this; e--
                } else if (r instanceof tt) { let a = r.text[s + (n < 0 ? -1 : 0)]; if (this.offsets[i] += n, a.length > Math.max(0, e)) return this.value = e == 0 ? a : n > 0 ? a.slice(e) : a.slice(0, a.length - e), this; e -= a.length } else { let a = r.children[s + (n < 0 ? -1 : 0)]; e > a.length ? (e -= a.length, this.offsets[i] += n) : (n < 0 && this.offsets[i]--, this.nodes.push(a), this.offsets.push(n > 0 ? 1 : (a instanceof tt ? a.text.length : a.children.length) << 1)) }
            }
        } next(e = 0) { return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir) }
    } class v1 { constructor(e, n, i) { this.value = "", this.done = !1, this.cursor = new Gs(e, n > i ? -1 : 1), this.pos = n > i ? e.length : 0, this.from = Math.min(n, i), this.to = Math.max(n, i) } nextInner(e, n) { if (n < 0 ? this.pos <= this.from : this.pos >= this.to) return this.value = "", this.done = !0, this; e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos); let i = n < 0 ? this.pos - this.from : this.to - this.pos; e > i && (e = i), i -= e; let { value: r } = this.cursor.next(e); return this.pos += (r.length + e) * n, this.value = r.length <= i ? r : n < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this } next(e = 0) { return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir) } get lineBreak() { return this.cursor.lineBreak && this.value != "" } } class y1 { constructor(e) { this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1 } next(e = 0) { let { done: n, lineBreak: i, value: r } = this.inner.next(e); return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this } get lineBreak() { return !1 } } typeof Symbol < "u" && (Be.prototype[Symbol.iterator] = function () { return this.iter() }, Gs.prototype[Symbol.iterator] = v1.prototype[Symbol.iterator] = y1.prototype[Symbol.iterator] = function () { return this }); class NP { constructor(e, n, i, r) { this.from = e, this.to = n, this.number = i, this.text = r } get length() { return this.to - this.from } } function Wo(t, e, n) { return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))] } let Po = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(t => t ? parseInt(t, 36) : 1); for (let t = 1; t < Po.length; t++)Po[t] += Po[t - 1]; function zP(t) { for (let e = 1; e < Po.length; e += 2)if (Po[e] > t) return Po[e - 1] <= t; return !1 } function Ym(t) { return t >= 127462 && t <= 127487 } const Zm = 8205; function kt(t, e, n = !0, i = !0) { return (n ? b1 : WP)(t, e, i) } function b1(t, e, n) { if (e == t.length) return e; e && O1(t.charCodeAt(e)) && S1(t.charCodeAt(e - 1)) && e--; let i = xt(t, e); for (e += bn(i); e < t.length;) { let r = xt(t, e); if (i == Zm || r == Zm || n && zP(r)) e += bn(r), i = r; else if (Ym(r)) { let o = 0, s = e - 2; for (; s >= 0 && Ym(xt(t, s));)o++, s -= 2; if (o % 2 == 0) break; e += 2 } else break } return e } function WP(t, e, n) { for (; e > 0;) { let i = b1(t, e - 2, n); if (i < e) return i; e-- } return 0 } function O1(t) { return t >= 56320 && t < 57344 } function S1(t) { return t >= 55296 && t < 56320 } function xt(t, e) { let n = t.charCodeAt(e); if (!S1(n) || e + 1 == t.length) return n; let i = t.charCodeAt(e + 1); return O1(i) ? (n - 55296 << 10) + (i - 56320) + 65536 : n } function Hp(t) { return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320)) } function bn(t) { return t < 65536 ? 1 : 2 } const qh = /\r\n?|\n/; var Tt = function (t) { return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t }(Tt || (Tt = {})); class ni { constructor(e) { this.sections = e } get length() { let e = 0; for (let n = 0; n < this.sections.length; n += 2)e += this.sections[n]; return e } get newLength() { let e = 0; for (let n = 0; n < this.sections.length; n += 2) { let i = this.sections[n + 1]; e += i < 0 ? this.sections[n] : i } return e } get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0 } iterGaps(e) { for (let n = 0, i = 0, r = 0; n < this.sections.length;) { let o = this.sections[n++], s = this.sections[n++]; s < 0 ? (e(i, r, o), r += o) : r += s, i += o } } iterChangedRanges(e, n = !1) { Vh(this, e, n) } get invertedDesc() { let e = []; for (let n = 0; n < this.sections.length;) { let i = this.sections[n++], r = this.sections[n++]; r < 0 ? e.push(i, r) : e.push(r, i) } return new ni(e) } composeDesc(e) { return this.empty ? e : e.empty ? this : x1(this, e) } mapDesc(e, n = !1) { return e.empty ? this : Xh(this, e, n) } mapPos(e, n = -1, i = Tt.Simple) { let r = 0, o = 0; for (let s = 0; s < this.sections.length;) { let l = this.sections[s++], a = this.sections[s++], c = r + l; if (a < 0) { if (c > e) return o + (e - r); o += l } else { if (i != Tt.Simple && c >= e && (i == Tt.TrackDel && r < e && c > e || i == Tt.TrackBefore && r < e || i == Tt.TrackAfter && c > e)) return null; if (c > e || c == e && n < 0 && !l) return e == r || n < 0 ? o : o + a; o += a } r = c } if (e > r) throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`); return o } touchesRange(e, n = e) { for (let i = 0, r = 0; i < this.sections.length && r <= n;) { let o = this.sections[i++], s = this.sections[i++], l = r + o; if (s >= 0 && r <= n && l >= e) return r < e && l > n ? "cover" : !0; r = l } return !1 } toString() { let e = ""; for (let n = 0; n < this.sections.length;) { let i = this.sections[n++], r = this.sections[n++]; e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "") } return e } toJSON() { return this.sections } static fromJSON(e) { if (!Array.isArray(e) || e.length % 2 || e.some(n => typeof n != "number")) throw new RangeError("Invalid JSON representation of ChangeDesc"); return new ni(e) } static create(e) { return new ni(e) } } class ut extends ni { constructor(e, n) { super(e), this.inserted = n } apply(e) { if (this.length != e.length) throw new RangeError("Applying change set to a document with the wrong length"); return Vh(this, (n, i, r, o, s) => e = e.replace(r, r + (i - n), s), !1), e } mapDesc(e, n = !1) { return Xh(this, e, n, !0) } invert(e) { let n = this.sections.slice(), i = []; for (let r = 0, o = 0; r < n.length; r += 2) { let s = n[r], l = n[r + 1]; if (l >= 0) { n[r] = l, n[r + 1] = s; let a = r >> 1; for (; i.length < a;)i.push(Be.empty); i.push(s ? e.slice(o, o + s) : Be.empty) } o += s } return new ut(n, i) } compose(e) { return this.empty ? e : e.empty ? this : x1(this, e, !0) } map(e, n = !1) { return e.empty ? this : Xh(this, e, n, !0) } iterChanges(e, n = !1) { Vh(this, e, n) } get desc() { return ni.create(this.sections) } filter(e) { let n = [], i = [], r = [], o = new hl(this); e: for (let s = 0, l = 0; ;) { let a = s == e.length ? 1e9 : e[s++]; for (; l < a || l == a && o.len == 0;) { if (o.done) break e; let u = Math.min(o.len, a - l); Mt(r, u, -1); let f = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0; Mt(n, u, f), f > 0 && Ki(i, n, o.text), o.forward(u), l += u } let c = e[s++]; for (; l < c;) { if (o.done) break e; let u = Math.min(o.len, c - l); Mt(n, u, -1), Mt(r, u, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(u), l += u } } return { changes: new ut(n, i), filtered: ni.create(r) } } toJSON() { let e = []; for (let n = 0; n < this.sections.length; n += 2) { let i = this.sections[n], r = this.sections[n + 1]; r < 0 ? e.push(i) : r == 0 ? e.push([i]) : e.push([i].concat(this.inserted[n >> 1].toJSON())) } return e } static of(e, n, i) { let r = [], o = [], s = 0, l = null; function a(u = !1) { if (!u && !r.length) return; s < n && Mt(r, n - s, -1); let f = new ut(r, o); l = l ? l.compose(f.map(l)) : f, r = [], o = [], s = 0 } function c(u) { if (Array.isArray(u)) for (let f of u) c(f); else if (u instanceof ut) { if (u.length != n) throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`); a(), l = l ? l.compose(u.map(l)) : u } else { let { from: f, to: h = f, insert: d } = u; if (f > h || f < 0 || h > n) throw new RangeError(`Invalid change range ${f} to ${h} (in doc of length ${n})`); let p = d ? typeof d == "string" ? Be.of(d.split(i || qh)) : d : Be.empty, g = p.length; if (f == h && g == 0) return; f < s && a(), f > s && Mt(r, f - s, -1), Mt(r, h - f, g), Ki(o, r, p), s = h } } return c(e), a(!l), l } static empty(e) { return new ut(e ? [e, -1] : [], []) } static fromJSON(e) { if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet"); let n = [], i = []; for (let r = 0; r < e.length; r++) { let o = e[r]; if (typeof o == "number") n.push(o, -1); else { if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, l) => l && typeof s != "string")) throw new RangeError("Invalid JSON representation of ChangeSet"); if (o.length == 1) n.push(o[0], 0); else { for (; i.length < r;)i.push(Be.empty); i[r] = Be.of(o.slice(1)), n.push(o[0], i[r].length) } } } return new ut(n, i) } static createSet(e, n) { return new ut(e, n) } } function Mt(t, e, n, i = !1) { if (e == 0 && n <= 0) return; let r = t.length - 2; r >= 0 && n <= 0 && n == t[r + 1] ? t[r] += e : e == 0 && t[r] == 0 ? t[r + 1] += n : i ? (t[r] += e, t[r + 1] += n) : t.push(e, n) } function Ki(t, e, n) { if (n.length == 0) return; let i = e.length - 2 >> 1; if (i < t.length) t[t.length - 1] = t[t.length - 1].append(n); else { for (; t.length < i;)t.push(Be.empty); t.push(n) } } function Vh(t, e, n) { let i = t.inserted; for (let r = 0, o = 0, s = 0; s < t.sections.length;) { let l = t.sections[s++], a = t.sections[s++]; if (a < 0) r += l, o += l; else { let c = r, u = o, f = Be.empty; for (; c += l, u += a, a && i && (f = f.append(i[s - 2 >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0);)l = t.sections[s++], a = t.sections[s++]; e(r, c, o, u, f), r = c, o = u } } } function Xh(t, e, n, i = !1) { let r = [], o = i ? [] : null, s = new hl(t), l = new hl(e); for (let a = -1; ;)if (s.ins == -1 && l.ins == -1) { let c = Math.min(s.len, l.len); Mt(r, c, -1), s.forward(c), l.forward(c) } else if (l.ins >= 0 && (s.ins < 0 || a == s.i || s.off == 0 && (l.len < s.len || l.len == s.len && !n))) { let c = l.len; for (Mt(r, l.ins, -1); c;) { let u = Math.min(s.len, c); s.ins >= 0 && a < s.i && s.len <= u && (Mt(r, 0, s.ins), o && Ki(o, r, s.text), a = s.i), s.forward(u), c -= u } l.next() } else if (s.ins >= 0) { let c = 0, u = s.len; for (; u;)if (l.ins == -1) { let f = Math.min(u, l.len); c += f, u -= f, l.forward(f) } else if (l.ins == 0 && l.len < u) u -= l.len, l.next(); else break; Mt(r, c, a < s.i ? s.ins : 0), o && a < s.i && Ki(o, r, s.text), a = s.i, s.forward(s.len - u) } else { if (s.done && l.done) return o ? ut.createSet(r, o) : ni.create(r); throw new Error("Mismatched change set lengths") } } function x1(t, e, n = !1) { let i = [], r = n ? [] : null, o = new hl(t), s = new hl(e); for (let l = !1; ;) { if (o.done && s.done) return r ? ut.createSet(i, r) : ni.create(i); if (o.ins == 0) Mt(i, o.len, 0, l), o.next(); else if (s.len == 0 && !s.done) Mt(i, 0, s.ins, l), r && Ki(r, i, s.text), s.next(); else { if (o.done || s.done) throw new Error("Mismatched change set lengths"); { let a = Math.min(o.len2, s.len), c = i.length; if (o.ins == -1) { let u = s.ins == -1 ? -1 : s.off ? 0 : s.ins; Mt(i, a, u, l), r && u && Ki(r, i, s.text) } else s.ins == -1 ? (Mt(i, o.off ? 0 : o.len, a, l), r && Ki(r, i, o.textBit(a))) : (Mt(i, o.off ? 0 : o.len, s.off ? 0 : s.ins, l), r && !s.off && Ki(r, i, s.text)); l = (o.ins > a || s.ins >= 0 && s.len > a) && (l || i.length > c), o.forward2(a), s.forward(a) } } } } class hl { constructor(e) { this.set = e, this.i = 0, this.next() } next() { let { sections: e } = this.set; this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0 } get done() { return this.ins == -2 } get len2() { return this.ins < 0 ? this.len : this.ins } get text() { let { inserted: e } = this.set, n = this.i - 2 >> 1; return n >= e.length ? Be.empty : e[n] } textBit(e) { let { inserted: n } = this.set, i = this.i - 2 >> 1; return i >= n.length && !e ? Be.empty : n[i].slice(this.off, e == null ? void 0 : this.off + e) } forward(e) { e == this.len ? this.next() : (this.len -= e, this.off += e) } forward2(e) { this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e) } } class Ir { constructor(e, n, i) { this.from = e, this.to = n, this.flags = i } get anchor() { return this.flags & 32 ? this.to : this.from } get head() { return this.flags & 32 ? this.from : this.to } get empty() { return this.from == this.to } get assoc() { return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0 } get bidiLevel() { let e = this.flags & 7; return e == 7 ? null : e } get goalColumn() { let e = this.flags >> 6; return e == 16777215 ? void 0 : e } map(e, n = -1) { let i, r; return this.empty ? i = r = e.mapPos(this.from, n) : (i = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new Ir(i, r, this.flags) } extend(e, n = e) { if (e <= this.anchor && n >= this.anchor) return z.range(e, n); let i = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n; return z.range(this.anchor, i) } eq(e, n = !1) { return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc) } toJSON() { return { anchor: this.anchor, head: this.head } } static fromJSON(e) { if (!e || typeof e.anchor != "number" || typeof e.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange"); return z.range(e.anchor, e.head) } static create(e, n, i) { return new Ir(e, n, i) } } class z { constructor(e, n) { this.ranges = e, this.mainIndex = n } map(e, n = -1) { return e.empty ? this : z.create(this.ranges.map(i => i.map(e, n)), this.mainIndex) } eq(e, n = !1) { if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1; for (let i = 0; i < this.ranges.length; i++)if (!this.ranges[i].eq(e.ranges[i], n)) return !1; return !0 } get main() { return this.ranges[this.mainIndex] } asSingle() { return this.ranges.length == 1 ? this : new z([this.main], 0) } addRange(e, n = !0) { return z.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1) } replaceRange(e, n = this.mainIndex) { let i = this.ranges.slice(); return i[n] = e, z.create(i, this.mainIndex) } toJSON() { return { ranges: this.ranges.map(e => e.toJSON()), main: this.mainIndex } } static fromJSON(e) { if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection"); return new z(e.ranges.map(n => Ir.fromJSON(n)), e.main) } static single(e, n = e) { return new z([z.range(e, n)], 0) } static create(e, n = 0) { if (e.length == 0) throw new RangeError("A selection needs at least one range"); for (let i = 0, r = 0; r < e.length; r++) { let o = e[r]; if (o.empty ? o.from <= i : o.from < i) return z.normalized(e.slice(), n); i = o.to } return new z(e, n) } static cursor(e, n = 0, i, r) { return Ir.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6) } static range(e, n, i, r) { let o = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r)); return n < e ? Ir.create(n, e, 48 | o) : Ir.create(e, n, (n > e ? 8 : 0) | o) } static normalized(e, n = 0) { let i = e[n]; e.sort((r, o) => r.from - o.from), n = e.indexOf(i); for (let r = 1; r < e.length; r++) { let o = e[r], s = e[r - 1]; if (o.empty ? o.from <= s.to : o.from < s.to) { let l = s.from, a = Math.max(o.to, s.to); r <= n && n--, e.splice(--r, 2, o.anchor > o.head ? z.range(a, l) : z.range(l, a)) } } return new z(e, n) } } function w1(t, e) { for (let n of t.ranges) if (n.to > e) throw new RangeError("Selection points outside of document") } let Fp = 0; class se { constructor(e, n, i, r, o) { this.combine = e, this.compareInput = n, this.compare = i, this.isStatic = r, this.id = Fp++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o } get reader() { return this } static define(e = {}) { return new se(e.combine || (n => n), e.compareInput || ((n, i) => n === i), e.compare || (e.combine ? (n, i) => n === i : jp), !!e.static, e.enables) } of(e) { return new ec([], this, 0, e) } compute(e, n) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new ec(e, this, 1, n) } computeN(e, n) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new ec(e, this, 2, n) } from(e, n) { return n || (n = i => i), this.compute([e], i => n(i.field(e))) } } function jp(t, e) { return t == e || t.length == e.length && t.every((n, i) => n === e[i]) } class ec { constructor(e, n, i, r) { this.dependencies = e, this.facet = n, this.type = i, this.value = r, this.id = Fp++ } dynamicSlot(e) { var n; let i = this.value, r = this.facet.compareInput, o = this.id, s = e[o] >> 1, l = this.type == 2, a = !1, c = !1, u = []; for (let f of this.dependencies) f == "doc" ? a = !0 : f == "selection" ? c = !0 : ((n = e[f.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[f.id]); return { create(f) { return f.values[s] = i(f), 1 }, update(f, h) { if (a && h.docChanged || c && (h.docChanged || h.selection) || Uh(f, u)) { let d = i(f); if (l ? !Jm(d, f.values[s], r) : !r(d, f.values[s])) return f.values[s] = d, 1 } return 0 }, reconfigure: (f, h) => { let d, p = h.config.address[o]; if (p != null) { let g = Pc(h, p); if (this.dependencies.every(m => m instanceof se ? h.facet(m) === f.facet(m) : m instanceof bt ? h.field(m, !1) == f.field(m, !1) : !0) || (l ? Jm(d = i(f), g, r) : r(d = i(f), g))) return f.values[s] = g, 0 } else d = i(f); return f.values[s] = d, 1 } } } } function Jm(t, e, n) { if (t.length != e.length) return !1; for (let i = 0; i < t.length; i++)if (!n(t[i], e[i])) return !1; return !0 } function Uh(t, e) { let n = !1; for (let i of e) Ks(t, i) & 1 && (n = !0); return n } function HP(t, e, n) { let i = n.map(a => t[a.id]), r = n.map(a => a.type), o = i.filter(a => !(a & 1)), s = t[e.id] >> 1; function l(a) { let c = []; for (let u = 0; u < i.length; u++) { let f = Pc(a, i[u]); if (r[u] == 2) for (let h of f) c.push(h); else c.push(f) } return e.combine(c) } return { create(a) { for (let c of i) Ks(a, c); return a.values[s] = l(a), 1 }, update(a, c) { if (!Uh(a, o)) return 0; let u = l(a); return e.compare(u, a.values[s]) ? 0 : (a.values[s] = u, 1) }, reconfigure(a, c) { let u = Uh(a, i), f = c.config.facets[e.id], h = c.facet(e); if (f && !u && jp(n, f)) return a.values[s] = h, 0; let d = l(a); return e.compare(d, h) ? (a.values[s] = h, 0) : (a.values[s] = d, 1) } } } const e0 = se.define({ static: !0 }); class bt { constructor(e, n, i, r, o) { this.id = e, this.createF = n, this.updateF = i, this.compareF = r, this.spec = o, this.provides = void 0 } static define(e) { let n = new bt(Fp++, e.create, e.update, e.compare || ((i, r) => i === r), e); return e.provide && (n.provides = e.provide(n)), n } create(e) { let n = e.facet(e0).find(i => i.field == this); return ((n == null ? void 0 : n.create) || this.createF)(e) } slot(e) { let n = e[this.id] >> 1; return { create: i => (i.values[n] = this.create(i), 1), update: (i, r) => { let o = i.values[n], s = this.updateF(o, r); return this.compareF(o, s) ? 0 : (i.values[n] = s, 1) }, reconfigure: (i, r) => r.config.address[this.id] != null ? (i.values[n] = r.field(this), 0) : (i.values[n] = this.create(i), 1) } } init(e) { return [this, e0.of({ field: this, create: e })] } get extension() { return this } } const Mr = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 }; function bs(t) { return e => new C1(e, t) } const yr = { highest: bs(Mr.highest), high: bs(Mr.high), default: bs(Mr.default), low: bs(Mr.low), lowest: bs(Mr.lowest) }; class C1 { constructor(e, n) { this.inner = e, this.prec = n } } class Mu { of(e) { return new Gh(this, e) } reconfigure(e) { return Mu.reconfigure.of({ compartment: this, extension: e }) } get(e) { return e.config.compartments.get(this) } } class Gh { constructor(e, n) { this.compartment = e, this.inner = n } } class kc { constructor(e, n, i, r, o, s) { for (this.base = e, this.compartments = n, this.dynamicSlots = i, this.address = r, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < i.length;)this.statusTemplate.push(0) } staticFacet(e) { let n = this.address[e.id]; return n == null ? e.default : this.staticValues[n >> 1] } static resolve(e, n, i) { let r = [], o = Object.create(null), s = new Map; for (let h of FP(e, n, s)) h instanceof bt ? r.push(h) : (o[h.facet.id] || (o[h.facet.id] = [])).push(h); let l = Object.create(null), a = [], c = []; for (let h of r) l[h.id] = c.length << 1, c.push(d => h.slot(d)); let u = i == null ? void 0 : i.config.facets; for (let h in o) { let d = o[h], p = d[0].facet, g = u && u[h] || []; if (d.every(m => m.type == 0)) if (l[p.id] = a.length << 1 | 1, jp(g, d)) a.push(i.facet(p)); else { let m = p.combine(d.map(v => v.value)); a.push(i && p.compare(m, i.facet(p)) ? i.facet(p) : m) } else { for (let m of d) m.type == 0 ? (l[m.id] = a.length << 1 | 1, a.push(m.value)) : (l[m.id] = c.length << 1, c.push(v => m.dynamicSlot(v))); l[p.id] = c.length << 1, c.push(m => HP(m, p, d)) } } let f = c.map(h => h(l)); return new kc(e, s, f, l, a, o) } } function FP(t, e, n) { let i = [[], [], [], [], []], r = new Map; function o(s, l) { let a = r.get(s); if (a != null) { if (a <= l) return; let c = i[a].indexOf(s); c > -1 && i[a].splice(c, 1), s instanceof Gh && n.delete(s.compartment) } if (r.set(s, l), Array.isArray(s)) for (let c of s) o(c, l); else if (s instanceof Gh) { if (n.has(s.compartment)) throw new RangeError("Duplicate use of compartment in extensions"); let c = e.get(s.compartment) || s.inner; n.set(s.compartment, c), o(c, l) } else if (s instanceof C1) o(s.inner, s.prec); else if (s instanceof bt) i[l].push(s), s.provides && o(s.provides, l); else if (s instanceof ec) i[l].push(s), s.facet.extensions && o(s.facet.extensions, Mr.default); else { let c = s.extension; if (!c) throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`); o(c, l) } } return o(t, Mr.default), i.reduce((s, l) => s.concat(l)) } function Ks(t, e) { if (e & 1) return 2; let n = e >> 1, i = t.status[n]; if (i == 4) throw new Error("Cyclic dependency between fields and/or facets"); if (i & 2) return i; t.status[n] = 4; let r = t.computeSlot(t, t.config.dynamicSlots[n]); return t.status[n] = 2 | r } function Pc(t, e) { return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1] } const T1 = se.define(), Kh = se.define({ combine: t => t.some(e => e), static: !0 }), $1 = se.define({ combine: t => t.length ? t[0] : void 0, static: !0 }), k1 = se.define(), P1 = se.define(), A1 = se.define(), M1 = se.define({ combine: t => t.length ? t[0] : !1 }); class Ri { constructor(e, n) { this.type = e, this.value = n } static define() { return new jP } } class jP { of(e) { return new Ri(this, e) } } class qP { constructor(e) { this.map = e } of(e) { return new Ce(this, e) } } class Ce { constructor(e, n) { this.type = e, this.value = n } map(e) { let n = this.type.map(this.value, e); return n === void 0 ? void 0 : n == this.value ? this : new Ce(this.type, n) } is(e) { return this.type == e } static define(e = {}) { return new qP(e.map || (n => n)) } static mapEffects(e, n) { if (!e.length) return e; let i = []; for (let r of e) { let o = r.map(n); o && i.push(o) } return i } } Ce.reconfigure = Ce.define(); Ce.appendConfig = Ce.define(); class lt { constructor(e, n, i, r, o, s) { this.startState = e, this.changes = n, this.selection = i, this.effects = r, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, i && w1(i, n.newLength), o.some(l => l.type == lt.time) || (this.annotations = o.concat(lt.time.of(Date.now()))) } static create(e, n, i, r, o, s) { return new lt(e, n, i, r, o, s) } get newDoc() { return this._doc || (this._doc = this.changes.apply(this.startState.doc)) } get newSelection() { return this.selection || this.startState.selection.map(this.changes) } get state() { return this._state || this.startState.applyTransaction(this), this._state } annotation(e) { for (let n of this.annotations) if (n.type == e) return n.value } get docChanged() { return !this.changes.empty } get reconfigured() { return this.startState.config != this.state.config } isUserEvent(e) { let n = this.annotation(lt.userEvent); return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == ".")) } } lt.time = Ri.define(); lt.userEvent = Ri.define(); lt.addToHistory = Ri.define(); lt.remote = Ri.define(); function VP(t, e) { let n = []; for (let i = 0, r = 0; ;) { let o, s; if (i < t.length && (r == e.length || e[r] >= t[i])) o = t[i++], s = t[i++]; else if (r < e.length) o = e[r++], s = e[r++]; else return n; !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s) } } function E1(t, e, n) { var i; let r, o, s; return n ? (r = e.changes, o = ut.empty(e.changes.length), s = t.changes.compose(e.changes)) : (r = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, !0), s = t.changes.compose(r)), { changes: s, selection: e.selection ? e.selection.map(o) : (i = t.selection) === null || i === void 0 ? void 0 : i.map(r), effects: Ce.mapEffects(t.effects, r).concat(Ce.mapEffects(e.effects, o)), annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations, scrollIntoView: t.scrollIntoView || e.scrollIntoView } } function Yh(t, e, n) { let i = e.selection, r = Ao(e.annotations); return e.userEvent && (r = r.concat(lt.userEvent.of(e.userEvent))), { changes: e.changes instanceof ut ? e.changes : ut.of(e.changes || [], n, t.facet($1)), selection: i && (i instanceof z ? i : z.single(i.anchor, i.head)), effects: Ao(e.effects), annotations: r, scrollIntoView: !!e.scrollIntoView } } function _1(t, e, n) { let i = Yh(t, e.length ? e[0] : {}, t.doc.length); e.length && e[0].filter === !1 && (n = !1); for (let o = 1; o < e.length; o++) { e[o].filter === !1 && (n = !1); let s = !!e[o].sequential; i = E1(i, Yh(t, e[o], s ? i.changes.newLength : t.doc.length), s) } let r = lt.create(t, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView); return UP(n ? XP(r) : r) } function XP(t) { let e = t.startState, n = !0; for (let r of e.facet(k1)) { let o = r(t); if (o === !1) { n = !1; break } Array.isArray(o) && (n = n === !0 ? o : VP(n, o)) } if (n !== !0) { let r, o; if (n === !1) o = t.changes.invertedDesc, r = ut.empty(e.doc.length); else { let s = t.changes.filter(n); r = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc } t = lt.create(e, r, t.selection && t.selection.map(o), Ce.mapEffects(t.effects, o), t.annotations, t.scrollIntoView) } let i = e.facet(P1); for (let r = i.length - 1; r >= 0; r--) { let o = i[r](t); o instanceof lt ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof lt ? t = o[0] : t = _1(e, Ao(o), !1) } return t } function UP(t) { let e = t.startState, n = e.facet(A1), i = t; for (let r = n.length - 1; r >= 0; r--) { let o = n[r](t); o && Object.keys(o).length && (i = E1(i, Yh(e, o, t.changes.newLength), !0)) } return i == t ? t : lt.create(e, t.changes, t.selection, i.effects, i.annotations, i.scrollIntoView) } const GP = []; function Ao(t) { return t == null ? GP : Array.isArray(t) ? t : [t] } var Ze = function (t) { return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t }(Ze || (Ze = {})); const KP = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; let Zh; try { Zh = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u") } catch { } function YP(t) { if (Zh) return Zh.test(t); for (let e = 0; e < t.length; e++) { let n = t[e]; if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || KP.test(n))) return !0 } return !1 } function ZP(t) { return e => { if (!/\S/.test(e)) return Ze.Space; if (YP(e)) return Ze.Word; for (let n = 0; n < t.length; n++)if (e.indexOf(t[n]) > -1) return Ze.Word; return Ze.Other } } class _e {
        constructor(e, n, i, r, o, s) { this.config = e, this.doc = n, this.selection = i, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this); for (let l = 0; l < this.config.dynamicSlots.length; l++)Ks(this, l << 1); this.computeSlot = null } field(e, n = !0) { let i = this.config.address[e.id]; if (i == null) { if (n) throw new RangeError("Field is not present in this state"); return } return Ks(this, i), Pc(this, i) } update(...e) { return _1(this, e, !0) } applyTransaction(e) { let n = this.config, { base: i, compartments: r } = n; for (let l of e.effects) l.is(Mu.reconfigure) ? (n && (r = new Map, n.compartments.forEach((a, c) => r.set(c, a)), n = null), r.set(l.value.compartment, l.value.extension)) : l.is(Ce.reconfigure) ? (n = null, i = l.value) : l.is(Ce.appendConfig) && (n = null, i = Ao(i).concat(l.value)); let o; n ? o = e.startState.values.slice() : (n = kc.resolve(i, r, this), o = new _e(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (a, c) => c.reconfigure(a, this), null).values); let s = e.startState.facet(Kh) ? e.newSelection : e.newSelection.asSingle(); new _e(n, e.newDoc, s, o, (l, a) => a.update(l, e), e) } replaceSelection(e) { return typeof e == "string" && (e = this.toText(e)), this.changeByRange(n => ({ changes: { from: n.from, to: n.to, insert: e }, range: z.cursor(n.from + e.length) })) } changeByRange(e) { let n = this.selection, i = e(n.ranges[0]), r = this.changes(i.changes), o = [i.range], s = Ao(i.effects); for (let l = 1; l < n.ranges.length; l++) { let a = e(n.ranges[l]), c = this.changes(a.changes), u = c.map(r); for (let h = 0; h < l; h++)o[h] = o[h].map(u); let f = r.mapDesc(c, !0); o.push(a.range.map(f)), r = r.compose(u), s = Ce.mapEffects(s, u).concat(Ce.mapEffects(Ao(a.effects), f)) } return { changes: r, selection: z.create(o, n.mainIndex), effects: s } } changes(e = []) { return e instanceof ut ? e : ut.of(e, this.doc.length, this.facet(_e.lineSeparator)) } toText(e) { return Be.of(e.split(this.facet(_e.lineSeparator) || qh)) } sliceDoc(e = 0, n = this.doc.length) { return this.doc.sliceString(e, n, this.lineBreak) } facet(e) { let n = this.config.address[e.id]; return n == null ? e.default : (Ks(this, n), Pc(this, n)) } toJSON(e) { let n = { doc: this.sliceDoc(), selection: this.selection.toJSON() }; if (e) for (let i in e) { let r = e[i]; r instanceof bt && this.config.address[r.id] != null && (n[i] = r.spec.toJSON(this.field(e[i]), this)) } return n } static fromJSON(e, n = {}, i) { if (!e || typeof e.doc != "string") throw new RangeError("Invalid JSON representation for EditorState"); let r = []; if (i) { for (let o in i) if (Object.prototype.hasOwnProperty.call(e, o)) { let s = i[o], l = e[o]; r.push(s.init(a => s.spec.fromJSON(l, a))) } } return _e.create({ doc: e.doc, selection: z.fromJSON(e.selection), extensions: n.extensions ? r.concat([n.extensions]) : r }) } static create(e = {}) { let n = kc.resolve(e.extensions || [], new Map), i = e.doc instanceof Be ? e.doc : Be.of((e.doc || "").split(n.staticFacet(_e.lineSeparator) || qh)), r = e.selection ? e.selection instanceof z ? e.selection : z.single(e.selection.anchor, e.selection.head) : z.single(0); return w1(r, i.length), n.staticFacet(Kh) || (r = r.asSingle()), new _e(n, i, r, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null) } get tabSize() { return this.facet(_e.tabSize) } get lineBreak() {
            return this.facet(_e.lineSeparator) || `
`} get readOnly() { return this.facet(M1) } phrase(e, ...n) { for (let i of this.facet(_e.phrases)) if (Object.prototype.hasOwnProperty.call(i, e)) { e = i[e]; break } return n.length && (e = e.replace(/\$(\$|\d*)/g, (i, r) => { if (r == "$") return "$"; let o = +(r || 1); return !o || o > n.length ? i : n[o - 1] })), e } languageDataAt(e, n, i = -1) { let r = []; for (let o of this.facet(T1)) for (let s of o(this, n, i)) Object.prototype.hasOwnProperty.call(s, e) && r.push(s[e]); return r } charCategorizer(e) { return ZP(this.languageDataAt("wordChars", e).join("")) } wordAt(e) { let { text: n, from: i, length: r } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - i, l = e - i; for (; s > 0;) { let a = kt(n, s, !1); if (o(n.slice(a, s)) != Ze.Word) break; s = a } for (; l < r;) { let a = kt(n, l); if (o(n.slice(l, a)) != Ze.Word) break; l = a } return s == l ? null : z.range(s + i, l + i) }
    } _e.allowMultipleSelections = Kh; _e.tabSize = se.define({ combine: t => t.length ? t[0] : 4 }); _e.lineSeparator = $1; _e.readOnly = M1; _e.phrases = se.define({ compare(t, e) { let n = Object.keys(t), i = Object.keys(e); return n.length == i.length && n.every(r => t[r] == e[r]) } }); _e.languageData = T1; _e.changeFilter = k1; _e.transactionFilter = P1; _e.transactionExtender = A1; Mu.reconfigure = Ce.define(); function fi(t, e, n = {}) { let i = {}; for (let r of t) for (let o of Object.keys(r)) { let s = r[o], l = i[o]; if (l === void 0) i[o] = s; else if (!(l === s || s === void 0)) if (Object.hasOwnProperty.call(n, o)) i[o] = n[o](l, s); else throw new Error("Config merge conflict for field " + o) } for (let r in e) i[r] === void 0 && (i[r] = e[r]); return i } class jr { eq(e) { return this == e } range(e, n = e) { return Jh.create(e, n, this) } } jr.prototype.startSide = jr.prototype.endSide = 0; jr.prototype.point = !1; jr.prototype.mapMode = Tt.TrackDel; let Jh = class R1 { constructor(e, n, i) { this.from = e, this.to = n, this.value = i } static create(e, n, i) { return new R1(e, n, i) } }; function ed(t, e) { return t.from - e.from || t.value.startSide - e.value.startSide } class qp { constructor(e, n, i, r) { this.from = e, this.to = n, this.value = i, this.maxPoint = r } get length() { return this.to[this.to.length - 1] } findIndex(e, n, i, r = 0) { let o = i ? this.to : this.from; for (let s = r, l = o.length; ;) { if (s == l) return s; let a = s + l >> 1, c = o[a] - e || (i ? this.value[a].endSide : this.value[a].startSide) - n; if (a == s) return c >= 0 ? s : l; c >= 0 ? l = a : s = a + 1 } } between(e, n, i, r) { for (let o = this.findIndex(n, -1e9, !0), s = this.findIndex(i, 1e9, !1, o); o < s; o++)if (r(this.from[o] + e, this.to[o] + e, this.value[o]) === !1) return !1 } map(e, n) { let i = [], r = [], o = [], s = -1, l = -1; for (let a = 0; a < this.value.length; a++) { let c = this.value[a], u = this.from[a] + e, f = this.to[a] + e, h, d; if (u == f) { let p = n.mapPos(u, c.startSide, c.mapMode); if (p == null || (h = d = p, c.startSide != c.endSide && (d = n.mapPos(u, c.endSide), d < h))) continue } else if (h = n.mapPos(u, c.startSide), d = n.mapPos(f, c.endSide), h > d || h == d && c.startSide > 0 && c.endSide <= 0) continue; (d - h || c.endSide - c.startSide) < 0 || (s < 0 && (s = h), c.point && (l = Math.max(l, d - h)), i.push(c), r.push(h - s), o.push(d - s)) } return { mapped: i.length ? new qp(r, o, i, l) : null, pos: s } } } class De { constructor(e, n, i, r) { this.chunkPos = e, this.chunk = n, this.nextLayer = i, this.maxPoint = r } static create(e, n, i, r) { return new De(e, n, i, r) } get length() { let e = this.chunk.length - 1; return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length) } get size() { if (this.isEmpty) return 0; let e = this.nextLayer.size; for (let n of this.chunk) e += n.value.length; return e } chunkEnd(e) { return this.chunkPos[e] + this.chunk[e].length } update(e) { let { add: n = [], sort: i = !1, filterFrom: r = 0, filterTo: o = this.length } = e, s = e.filter; if (n.length == 0 && !s) return this; if (i && (n = n.slice().sort(ed)), this.isEmpty) return n.length ? De.of(n) : this; let l = new I1(this, null, -1).goto(0), a = 0, c = [], u = new ar; for (; l.value || a < n.length;)if (a < n.length && (l.from - n[a].from || l.startSide - n[a].value.startSide) >= 0) { let f = n[a++]; u.addInner(f.from, f.to, f.value) || c.push(f) } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == n.length || this.chunkEnd(l.chunkIndex) < n[a].from) && (!s || r > this.chunkEnd(l.chunkIndex) || o < this.chunkPos[l.chunkIndex]) && u.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!s || r > l.to || o < l.from || s(l.from, l.to, l.value)) && (u.addInner(l.from, l.to, l.value) || c.push(Jh.create(l.from, l.to, l.value))), l.next()); return u.finishInner(this.nextLayer.isEmpty && !c.length ? De.empty : this.nextLayer.update({ add: c, filter: s, filterFrom: r, filterTo: o })) } map(e) { if (e.empty || this.isEmpty) return this; let n = [], i = [], r = -1; for (let s = 0; s < this.chunk.length; s++) { let l = this.chunkPos[s], a = this.chunk[s], c = e.touchesRange(l, l + a.length); if (c === !1) r = Math.max(r, a.maxPoint), n.push(a), i.push(e.mapPos(l)); else if (c === !0) { let { mapped: u, pos: f } = a.map(l, e); u && (r = Math.max(r, u.maxPoint), n.push(u), i.push(f)) } } let o = this.nextLayer.map(e); return n.length == 0 ? o : new De(i, n, o || De.empty, r) } between(e, n, i) { if (!this.isEmpty) { for (let r = 0; r < this.chunk.length; r++) { let o = this.chunkPos[r], s = this.chunk[r]; if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, i) === !1) return } this.nextLayer.between(e, n, i) } } iter(e = 0) { return dl.from([this]).goto(e) } get isEmpty() { return this.nextLayer == this } static iter(e, n = 0) { return dl.from(e).goto(n) } static compare(e, n, i, r, o = -1) { let s = e.filter(f => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= o), l = n.filter(f => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= o), a = t0(s, l, i), c = new Os(s, a, o), u = new Os(l, a, o); i.iterGaps((f, h, d) => n0(c, f, u, h, d, r)), i.empty && i.length == 0 && n0(c, 0, u, 0, 0, r) } static eq(e, n, i = 0, r) { r == null && (r = 1e9 - 1); let o = e.filter(u => !u.isEmpty && n.indexOf(u) < 0), s = n.filter(u => !u.isEmpty && e.indexOf(u) < 0); if (o.length != s.length) return !1; if (!o.length) return !0; let l = t0(o, s), a = new Os(o, l, 0).goto(i), c = new Os(s, l, 0).goto(i); for (; ;) { if (a.to != c.to || !td(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point))) return !1; if (a.to > r) return !0; a.next(), c.next() } } static spans(e, n, i, r, o = -1) { let s = new Os(e, null, o).goto(n), l = n, a = s.openStart; for (; ;) { let c = Math.min(s.to, i); if (s.point) { let u = s.activeForPoint(s.to), f = s.pointFrom < n ? u.length + 1 : s.point.startSide < 0 ? u.length : Math.min(u.length, a); r.point(l, c, s.point, u, f, s.pointRank), a = Math.min(s.openEnd(c), u.length) } else c > l && (r.span(l, c, s.active, a), a = s.openEnd(c)); if (s.to > i) return a + (s.point && s.to > i ? 1 : 0); l = s.to, s.next() } } static of(e, n = !1) { let i = new ar; for (let r of e instanceof Jh ? [e] : n ? JP(e) : e) i.add(r.from, r.to, r.value); return i.finish() } static join(e) { if (!e.length) return De.empty; let n = e[e.length - 1]; for (let i = e.length - 2; i >= 0; i--)for (let r = e[i]; r != De.empty; r = r.nextLayer)n = new De(r.chunkPos, r.chunk, n, Math.max(r.maxPoint, n.maxPoint)); return n } } De.empty = new De([], [], null, -1); function JP(t) { if (t.length > 1) for (let e = t[0], n = 1; n < t.length; n++) { let i = t[n]; if (ed(e, i) > 0) return t.slice().sort(ed); e = i } return t } De.empty.nextLayer = De.empty; class ar { finishChunk(e) { this.chunks.push(new qp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []) } constructor() { this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null } add(e, n, i) { this.addInner(e, n, i) || (this.nextLayer || (this.nextLayer = new ar)).add(e, n, i) } addInner(e, n, i) { let r = e - this.lastTo || i.startSide - this.last.endSide; if (r <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`"); return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = n, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0) } addChunk(e, n) { if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0) return !1; this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e); let i = n.value.length - 1; return this.last = n.value[i], this.lastFrom = n.from[i] + e, this.lastTo = n.to[i] + e, !0 } finish() { return this.finishInner(De.empty) } finishInner(e) { if (this.from.length && this.finishChunk(!1), this.chunks.length == 0) return e; let n = De.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint); return this.from = null, n } } function t0(t, e, n) { let i = new Map; for (let o of t) for (let s = 0; s < o.chunk.length; s++)o.chunk[s].maxPoint <= 0 && i.set(o.chunk[s], o.chunkPos[s]); let r = new Set; for (let o of e) for (let s = 0; s < o.chunk.length; s++) { let l = i.get(o.chunk[s]); l != null && (n ? n.mapPos(l) : l) == o.chunkPos[s] && !(n != null && n.touchesRange(l, l + o.chunk[s].length)) && r.add(o.chunk[s]) } return r } class I1 { constructor(e, n, i, r = 0) { this.layer = e, this.skip = n, this.minPoint = i, this.rank = r } get startSide() { return this.value ? this.value.startSide : 0 } get endSide() { return this.value ? this.value.endSide : 0 } goto(e, n = -1e9) { return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this } gotoInner(e, n, i) { for (; this.chunkIndex < this.layer.chunk.length;) { let r = this.layer.chunk[this.chunkIndex]; if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint)) break; this.chunkIndex++, i = !1 } if (this.chunkIndex < this.layer.chunk.length) { let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0); (!i || this.rangeIndex < r) && this.setRangeIndex(r) } this.next() } forward(e, n) { (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0) } next() { for (; ;)if (this.chunkIndex == this.layer.chunk.length) { this.from = this.to = 1e9, this.value = null; break } else { let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], i = e + n.from[this.rangeIndex]; if (this.from = i, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break } } setRangeIndex(e) { if (e == this.layer.chunk[this.chunkIndex].value.length) { if (this.chunkIndex++, this.skip) for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++; this.rangeIndex = 0 } else this.rangeIndex = e } nextChunk() { this.chunkIndex++, this.rangeIndex = 0, this.next() } compare(e) { return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide } } class dl { constructor(e) { this.heap = e } static from(e, n = null, i = -1) { let r = []; for (let o = 0; o < e.length; o++)for (let s = e[o]; !s.isEmpty; s = s.nextLayer)s.maxPoint >= i && r.push(new I1(s, n, i, o)); return r.length == 1 ? r[0] : new dl(r) } get startSide() { return this.value ? this.value.startSide : 0 } goto(e, n = -1e9) { for (let i of this.heap) i.goto(e, n); for (let i = this.heap.length >> 1; i >= 0; i--)kf(this.heap, i); return this.next(), this } forward(e, n) { for (let i of this.heap) i.forward(e, n); for (let i = this.heap.length >> 1; i >= 0; i--)kf(this.heap, i); (this.to - e || this.value.endSide - n) < 0 && this.next() } next() { if (this.heap.length == 0) this.from = this.to = 1e9, this.value = null, this.rank = -1; else { let e = this.heap[0]; this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), kf(this.heap, 0) } } } function kf(t, e) { for (let n = t[e]; ;) { let i = (e << 1) + 1; if (i >= t.length) break; let r = t[i]; if (i + 1 < t.length && r.compare(t[i + 1]) >= 0 && (r = t[i + 1], i++), n.compare(r) < 0) break; t[i] = n, t[e] = r, e = i } } class Os { constructor(e, n, i) { this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = dl.from(e, n, i) } goto(e, n = -1e9) { return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this } forward(e, n) { for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0;)this.removeActive(this.minActive); this.cursor.forward(e, n) } removeActive(e) { ca(this.active, e), ca(this.activeTo, e), ca(this.activeRank, e), this.minActive = i0(this.active, this.activeTo) } addActive(e) { let n = 0, { value: i, to: r, rank: o } = this.cursor; for (; n < this.activeRank.length && (o - this.activeRank[n] || r - this.activeTo[n]) > 0;)n++; ua(this.active, n, i), ua(this.activeTo, n, r), ua(this.activeRank, n, o), e && ua(e, n, this.cursor.from), this.minActive = i0(this.active, this.activeTo) } next() { let e = this.to, n = this.point; this.point = null; let i = this.openStart < 0 ? [] : null; for (; ;) { let r = this.minActive; if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) { if (this.activeTo[r] > e) { this.to = this.activeTo[r], this.endSide = this.active[r].endSide; break } this.removeActive(r), i && ca(i, r) } else if (this.cursor.value) if (this.cursor.from > e) { this.to = this.cursor.from, this.endSide = this.cursor.startSide; break } else { let o = this.cursor.value; if (!o.point) this.addActive(i), this.cursor.next(); else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to) this.cursor.next(); else { this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide); break } } else { this.to = this.endSide = 1e9; break } } if (i) { this.openStart = 0; for (let r = i.length - 1; r >= 0 && i[r] < e; r--)this.openStart++ } } activeForPoint(e) { if (!this.active.length) return this.active; let n = []; for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)(this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && n.push(this.active[i]); return n.reverse() } openEnd(e) { let n = 0; for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)n++; return n } } function n0(t, e, n, i, r, o) { t.goto(e), n.goto(i); let s = i + r, l = i, a = i - e; for (; ;) { let c = t.to + a - n.to || t.endSide - n.endSide, u = c < 0 ? t.to + a : n.to, f = Math.min(u, s); if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && td(t.activeForPoint(t.to), n.activeForPoint(n.to)) || o.comparePoint(l, f, t.point, n.point) : f > l && !td(t.active, n.active) && o.compareRange(l, f, t.active, n.active), u > s) break; l = u, c <= 0 && t.next(), c >= 0 && n.next() } } function td(t, e) { if (t.length != e.length) return !1; for (let n = 0; n < t.length; n++)if (t[n] != e[n] && !t[n].eq(e[n])) return !1; return !0 } function ca(t, e) { for (let n = e, i = t.length - 1; n < i; n++)t[n] = t[n + 1]; t.pop() } function ua(t, e, n) { for (let i = t.length - 1; i >= e; i--)t[i + 1] = t[i]; t[e] = n } function i0(t, e) { let n = -1, i = 1e9; for (let r = 0; r < e.length; r++)(e[r] - i || t[r].endSide - t[n].endSide) < 0 && (n = r, i = e[r]); return n } function ss(t, e, n = t.length) { let i = 0; for (let r = 0; r < n;)t.charCodeAt(r) == 9 ? (i += e - i % e, r++) : (i++, r = kt(t, r)); return i } function nd(t, e, n, i) { for (let r = 0, o = 0; ;) { if (o >= e) return r; if (r == t.length) break; o += t.charCodeAt(r) == 9 ? n - o % n : 1, r = kt(t, r) } return i === !0 ? -1 : t.length } const id = "ͼ", r0 = typeof Symbol > "u" ? "__" + id : Symbol.for(id), rd = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), o0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {}; class cr {
        constructor(e, n) { this.rules = []; let { finish: i } = n || {}; function r(s) { return /^@/.test(s) ? [s] : s.split(/,\s*/) } function o(s, l, a, c) { let u = [], f = /^@(\w+)\b/.exec(s[0]), h = f && f[1] == "keyframes"; if (f && l == null) return a.push(s[0] + ";"); for (let d in l) { let p = l[d]; if (/&/.test(d)) o(d.split(/,\s*/).map(g => s.map(m => g.replace(/&/, m))).reduce((g, m) => g.concat(m)), p, a); else if (p && typeof p == "object") { if (!f) throw new RangeError("The value of a property (" + d + ") should be a primitive value."); o(r(d), p, u, h) } else p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, g => "-" + g.toLowerCase()) + ": " + p + ";") } (u.length || h) && a.push((i && !f && !c ? s.map(i) : s).join(", ") + " {" + u.join(" ") + "}") } for (let s in e) o(r(s), e[s], this.rules) } getRules() {
            return this.rules.join(`
`)
        } static newName() { let e = o0[r0] || 1; return o0[r0] = e + 1, id + e.toString(36) } static mount(e, n, i) { let r = e[rd], o = i && i.nonce; r ? o && r.setNonce(o) : r = new eA(e, o), r.mount(Array.isArray(n) ? n : [n], e) }
    } let s0 = new Map; class eA {
        constructor(e, n) { let i = e.ownerDocument || e, r = i.defaultView; if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) { let o = s0.get(i); if (o) return e[rd] = o; this.sheet = new r.CSSStyleSheet, s0.set(i, this) } else this.styleTag = i.createElement("style"), n && this.styleTag.setAttribute("nonce", n); this.modules = [], e[rd] = this } mount(e, n) {
            let i = this.sheet, r = 0, o = 0; for (let s = 0; s < e.length; s++) { let l = e[s], a = this.modules.indexOf(l); if (a < o && a > -1 && (this.modules.splice(a, 1), o--, a = -1), a == -1) { if (this.modules.splice(o++, 0, l), i) for (let c = 0; c < l.rules.length; c++)i.insertRule(l.rules[c], r++) } else { for (; o < a;)r += this.modules[o++].rules.length; r += l.rules.length, o++ } } if (i) n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]); else {
                let s = ""; for (let a = 0; a < this.modules.length; a++)s += this.modules[a].getRules() + `
`; this.styleTag.textContent = s; let l = n.head || n; this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild)
            }
        } setNonce(e) { this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e) }
    } var ur = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, pl = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, tA = typeof navigator < "u" && /Mac/.test(navigator.platform), nA = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (var wt = 0; wt < 10; wt++)ur[48 + wt] = ur[96 + wt] = String(wt); for (var wt = 1; wt <= 24; wt++)ur[wt + 111] = "F" + wt; for (var wt = 65; wt <= 90; wt++)ur[wt] = String.fromCharCode(wt + 32), pl[wt] = String.fromCharCode(wt); for (var Pf in ur) pl.hasOwnProperty(Pf) || (pl[Pf] = ur[Pf]); function iA(t) { var e = tA && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || nA && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? pl : ur)[t.keyCode] || t.key || "Unidentified"; return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n } function gl(t) { let e; return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection() } function od(t, e) { return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1 } function tc(t, e) { if (!e.anchorNode) return !1; try { return od(t, e.anchorNode) } catch { return !1 } } function ml(t) { return t.nodeType == 3 ? Vr(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [] } function Ys(t, e, n, i) { return n ? l0(t, e, n, i, -1) || l0(t, e, n, i, 1) : !1 } function qr(t) { for (var e = 0; ; e++)if (t = t.previousSibling, !t) return e } function Ac(t) { return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName) } function l0(t, e, n, i, r) { for (; ;) { if (t == n && e == i) return !0; if (e == (r < 0 ? 0 : oi(t))) { if (t.nodeName == "DIV") return !1; let o = t.parentNode; if (!o || o.nodeType != 1) return !1; e = qr(t) + (r < 0 ? 0 : 1), t = o } else if (t.nodeType == 1) { if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false") return !1; e = r < 0 ? oi(t) : 0 } else return !1 } } function oi(t) { return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length } function Eu(t, e) { let n = e ? t.left : t.right; return { left: n, right: n, top: t.top, bottom: t.bottom } } function rA(t) { let e = t.visualViewport; return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: t.innerWidth, top: 0, bottom: t.innerHeight } } function D1(t, e) { let n = e.width / t.offsetWidth, i = e.height / t.offsetHeight; return (n > .995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (i > .995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - t.offsetHeight) < 1) && (i = 1), { scaleX: n, scaleY: i } } function oA(t, e, n, i, r, o, s, l) { let a = t.ownerDocument, c = a.defaultView || window; for (let u = t, f = !1; u && !f;)if (u.nodeType == 1) { let h, d = u == a.body, p = 1, g = 1; if (d) h = rA(c); else { if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (f = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) { u = u.assignedSlot || u.parentNode; continue } let b = u.getBoundingClientRect(); ({ scaleX: p, scaleY: g } = D1(u, b)), h = { left: b.left, right: b.left + u.clientWidth * p, top: b.top, bottom: b.top + u.clientHeight * g } } let m = 0, v = 0; if (r == "nearest") e.top < h.top ? (v = -(h.top - e.top + s), n > 0 && e.bottom > h.bottom + v && (v = e.bottom - h.bottom + v + s)) : e.bottom > h.bottom && (v = e.bottom - h.bottom + s, n < 0 && e.top - v < h.top && (v = -(h.top + v - e.top + s))); else { let b = e.bottom - e.top, x = h.bottom - h.top; v = (r == "center" && b <= x ? e.top + b / 2 - x / 2 : r == "start" || r == "center" && n < 0 ? e.top - s : e.bottom - x + s) - h.top } if (i == "nearest" ? e.left < h.left ? (m = -(h.left - e.left + o), n > 0 && e.right > h.right + m && (m = e.right - h.right + m + o)) : e.right > h.right && (m = e.right - h.right + o, n < 0 && e.left < h.left + m && (m = -(h.left + m - e.left + o))) : m = (i == "center" ? e.left + (e.right - e.left) / 2 - (h.right - h.left) / 2 : i == "start" == l ? e.left - o : e.right - (h.right - h.left) + o) - h.left, m || v) if (d) c.scrollBy(m, v); else { let b = 0, x = 0; if (v) { let w = u.scrollTop; u.scrollTop += v / g, x = (u.scrollTop - w) * g } if (m) { let w = u.scrollLeft; u.scrollLeft += m / p, b = (u.scrollLeft - w) * p } e = { left: e.left - b, top: e.top - x, right: e.right - b, bottom: e.bottom - x }, b && Math.abs(b - m) < 1 && (i = "nearest"), x && Math.abs(x - v) < 1 && (r = "nearest") } if (d) break; u = u.assignedSlot || u.parentNode } else if (u.nodeType == 11) u = u.host; else break } function sA(t) { let e = t.ownerDocument, n, i; for (let r = t.parentNode; r && !(r == e.body || n && i);)if (r.nodeType == 1) !i && r.scrollHeight > r.clientHeight && (i = r), !n && r.scrollWidth > r.clientWidth && (n = r), r = r.assignedSlot || r.parentNode; else if (r.nodeType == 11) r = r.host; else break; return { x: n, y: i } } class lA { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } eq(e) { return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset } setRange(e) { let { anchorNode: n, focusNode: i } = e; this.set(n, Math.min(e.anchorOffset, n ? oi(n) : 0), i, Math.min(e.focusOffset, i ? oi(i) : 0)) } set(e, n, i, r) { this.anchorNode = e, this.anchorOffset = n, this.focusNode = i, this.focusOffset = r } } let ao = null; function B1(t) { if (t.setActive) return t.setActive(); if (ao) return t.focus(ao); let e = []; for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode); if (t.focus(ao == null ? { get preventScroll() { return ao = { preventScroll: !0 }, !0 } } : void 0), !ao) { ao = !1; for (let n = 0; n < e.length;) { let i = e[n++], r = e[n++], o = e[n++]; i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != o && (i.scrollLeft = o) } } } let a0; function Vr(t, e, n = e) { let i = a0 || (a0 = document.createRange()); return i.setEnd(t, n), i.setStart(t, e), i } function Mo(t, e, n, i) { let r = { key: e, code: e, keyCode: n, which: n, cancelable: !0 }; i && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = i); let o = new KeyboardEvent("keydown", r); o.synthetic = !0, t.dispatchEvent(o); let s = new KeyboardEvent("keyup", r); return s.synthetic = !0, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented } function aA(t) { for (; t;) { if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host)) return t; t = t.assignedSlot || t.parentNode } return null } function L1(t) { for (; t.attributes.length;)t.removeAttributeNode(t.attributes[0]) } function cA(t, e) { let n = e.focusNode, i = e.focusOffset; if (!n || e.anchorNode != n || e.anchorOffset != i) return !1; for (i = Math.min(i, oi(n)); ;)if (i) { if (n.nodeType != 1) return !1; let r = n.childNodes[i - 1]; r.contentEditable == "false" ? i-- : (n = r, i = oi(n)) } else { if (n == t) return !0; i = qr(n), n = n.parentNode } } function Q1(t) { return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4) } function N1(t, e) { for (let n = t, i = e; ;) { if (n.nodeType == 3 && i > 0) return { node: n, offset: i }; if (n.nodeType == 1 && i > 0) { if (n.contentEditable == "false") return null; n = n.childNodes[i - 1], i = oi(n) } else if (n.parentNode && !Ac(n)) i = qr(n), n = n.parentNode; else return null } } function z1(t, e) { for (let n = t, i = e; ;) { if (n.nodeType == 3 && i < n.nodeValue.length) return { node: n, offset: i }; if (n.nodeType == 1 && i < n.childNodes.length) { if (n.contentEditable == "false") return null; n = n.childNodes[i], i = 0 } else if (n.parentNode && !Ac(n)) i = qr(n) + 1, n = n.parentNode; else return null } } class Et { constructor(e, n, i = !0) { this.node = e, this.offset = n, this.precise = i } static before(e, n) { return new Et(e.parentNode, qr(e), n) } static after(e, n) { return new Et(e.parentNode, qr(e) + 1, n) } } const Vp = []; class He { constructor() { this.parent = null, this.dom = null, this.flags = 2 } get overrideDOMText() { return null } get posAtStart() { return this.parent ? this.parent.posBefore(this) : 0 } get posAtEnd() { return this.posAtStart + this.length } posBefore(e) { let n = this.posAtStart; for (let i of this.children) { if (i == e) return n; n += i.length + i.breakAfter } throw new RangeError("Invalid child in posBefore") } posAfter(e) { return this.posBefore(e) + e.length } sync(e, n) { if (this.flags & 2) { let i = this.dom, r = null, o; for (let s of this.children) { if (s.flags & 7) { if (!s.dom && (o = r ? r.nextSibling : i.firstChild)) { let l = He.get(o); (!l || !l.parent && l.canReuseDOM(s)) && s.reuseDOM(o) } s.sync(e, n), s.flags &= -8 } if (o = r ? r.nextSibling : i.firstChild, n && !n.written && n.node == i && o != s.dom && (n.written = !0), s.dom.parentNode == i) for (; o && o != s.dom;)o = c0(o); else i.insertBefore(s.dom, o); r = s.dom } for (o = r ? r.nextSibling : i.firstChild, o && n && n.node == i && (n.written = !0); o;)o = c0(o) } else if (this.flags & 1) for (let i of this.children) i.flags & 7 && (i.sync(e, n), i.flags &= -8) } reuseDOM(e) { } localPosFromDOM(e, n) { let i; if (e == this.dom) i = this.dom.childNodes[n]; else { let r = oi(e) == 0 ? 0 : n == 0 ? -1 : 1; for (; ;) { let o = e.parentNode; if (o == this.dom) break; r == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? r = -1 : r = 1), e = o } r < 0 ? i = e : i = e.nextSibling } if (i == this.dom.firstChild) return 0; for (; i && !He.get(i);)i = i.nextSibling; if (!i) return this.length; for (let r = 0, o = 0; ; r++) { let s = this.children[r]; if (s.dom == i) return o; o += s.length + s.breakAfter } } domBoundsAround(e, n, i = 0) { let r = -1, o = -1, s = -1, l = -1; for (let a = 0, c = i, u = i; a < this.children.length; a++) { let f = this.children[a], h = c + f.length; if (c < e && h > n) return f.domBoundsAround(e, n, c); if (h >= e && r == -1 && (r = a, o = c), c > n && f.dom.parentNode == this.dom) { s = a, l = u; break } u = h, c = h + f.breakAfter } return { from: o, to: l < 0 ? i + this.length : l, startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null } } markDirty(e = !1) { this.flags |= 2, this.markParentsDirty(e) } markParentsDirty(e) { for (let n = this.parent; n; n = n.parent) { if (e && (n.flags |= 2), n.flags & 1) return; n.flags |= 1, e = !1 } } setParent(e) { this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0)) } setDOM(e) { this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this) } get rootView() { for (let e = this; ;) { let n = e.parent; if (!n) return e; e = n } } replaceChildren(e, n, i = Vp) { this.markDirty(); for (let r = e; r < n; r++) { let o = this.children[r]; o.parent == this && i.indexOf(o) < 0 && o.destroy() } i.length < 250 ? this.children.splice(e, n - e, ...i) : this.children = [].concat(this.children.slice(0, e), i, this.children.slice(n)); for (let r = 0; r < i.length; r++)i[r].setParent(this) } ignoreMutation(e) { return !1 } ignoreEvent(e) { return !1 } childCursor(e = this.length) { return new W1(this.children, e, this.children.length) } childPos(e, n = 1) { return this.childCursor().findPos(e, n) } toString() { let e = this.constructor.name.replace("View", ""); return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "") } static get(e) { return e.cmView } get isEditable() { return !0 } get isWidget() { return !1 } get isHidden() { return !1 } merge(e, n, i, r, o, s) { return !1 } become(e) { return !1 } canReuseDOM(e) { return e.constructor == this.constructor && !((this.flags | e.flags) & 8) } getSide() { return 0 } destroy() { for (let e of this.children) e.parent == this && e.destroy(); this.parent = null } } He.prototype.breakAfter = 0; function c0(t) { let e = t.nextSibling; return t.parentNode.removeChild(t), e } class W1 { constructor(e, n, i) { this.children = e, this.pos = n, this.i = i, this.off = 0 } findPos(e, n = 1) { for (; ;) { if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) return this.off = e - this.pos, this; let i = this.children[--this.i]; this.pos -= i.length + i.breakAfter } } } function H1(t, e, n, i, r, o, s, l, a) { let { children: c } = t, u = c.length ? c[e] : null, f = o.length ? o[o.length - 1] : null, h = f ? f.breakAfter : s; if (!(e == i && u && !s && !h && o.length < 2 && u.merge(n, r, o.length ? f : null, n == 0, l, a))) { if (i < c.length) { let d = c[i]; d && (r < d.length || d.breakAfter && (f != null && f.breakAfter)) ? (e == i && (d = d.split(r), r = 0), !h && f && d.merge(0, r, f, !0, 0, a) ? o[o.length - 1] = d : ((r || d.children.length && !d.children[0].length) && d.merge(0, r, null, !1, 0, a), o.push(d))) : d != null && d.breakAfter && (f ? f.breakAfter = 1 : s = 1), i++ } for (u && (u.breakAfter = s, n > 0 && (!s && o.length && u.merge(n, u.length, o[0], !1, l, 0) ? u.breakAfter = o.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, !1, l, 0), e++)); e < i && o.length;)if (c[i - 1].become(o[o.length - 1])) i--, o.pop(), a = o.length ? 0 : l; else if (c[e].become(o[0])) e++, o.shift(), l = o.length ? 0 : a; else break; !o.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < i || o.length) && t.replaceChildren(e, i, o) } } function F1(t, e, n, i, r, o) { let s = t.childCursor(), { i: l, off: a } = s.findPos(n, 1), { i: c, off: u } = s.findPos(e, -1), f = e - n; for (let h of i) f += h.length; t.length += f, H1(t, c, u, l, a, i, 0, r, o) } let Vt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, sd = typeof document < "u" ? document : { documentElement: { style: {} } }; const ld = /Edge\/(\d+)/.exec(Vt.userAgent), j1 = /MSIE \d/.test(Vt.userAgent), ad = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Vt.userAgent), _u = !!(j1 || ad || ld), u0 = !_u && /gecko\/(\d+)/i.test(Vt.userAgent), Af = !_u && /Chrome\/(\d+)/.exec(Vt.userAgent), f0 = "webkitFontSmoothing" in sd.documentElement.style, q1 = !_u && /Apple Computer/.test(Vt.vendor), h0 = q1 && (/Mobile\/\w+/.test(Vt.userAgent) || Vt.maxTouchPoints > 2); var le = { mac: h0 || /Mac/.test(Vt.platform), windows: /Win/.test(Vt.platform), linux: /Linux|X11/.test(Vt.platform), ie: _u, ie_version: j1 ? sd.documentMode || 6 : ad ? +ad[1] : ld ? +ld[1] : 0, gecko: u0, gecko_version: u0 ? +(/Firefox\/(\d+)/.exec(Vt.userAgent) || [0, 0])[1] : 0, chrome: !!Af, chrome_version: Af ? +Af[1] : 0, ios: h0, android: /Android\b/.test(Vt.userAgent), webkit: f0, safari: q1, webkit_version: f0 ? +(/\bAppleWebKit\/(\d+)/.exec(Vt.userAgent) || [0, 0])[1] : 0, tabSize: sd.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size" }; const uA = 256; class Ln extends He { constructor(e) { super(), this.text = e } get length() { return this.text.length } createDOM(e) { this.setDOM(e || document.createTextNode(this.text)) } sync(e, n) { this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text) } reuseDOM(e) { e.nodeType == 3 && this.createDOM(e) } merge(e, n, i) { return this.flags & 8 || i && (!(i instanceof Ln) || this.length - (n - e) + i.length > uA || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(n), this.markDirty(), !0) } split(e) { let n = new Ln(this.text.slice(e)); return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n } localPosFromDOM(e, n) { return e == this.dom ? n : n ? this.text.length : 0 } domAtPos(e) { return new Et(this.dom, e) } domBoundsAround(e, n, i) { return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling } } coordsAt(e, n) { return fA(this.dom, e, n) } } class Ai extends He { constructor(e, n = [], i = 0) { super(), this.mark = e, this.children = n, this.length = i; for (let r of n) r.setParent(this) } setAttrs(e) { if (L1(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs) for (let n in this.mark.attrs) e.setAttribute(n, this.mark.attrs[n]); return e } canReuseDOM(e) { return super.canReuseDOM(e) && !((this.flags | e.flags) & 8) } reuseDOM(e) { e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6) } sync(e, n) { this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n) } merge(e, n, i, r, o, s) { return i && (!(i instanceof Ai && i.mark.eq(this.mark)) || e && o <= 0 || n < this.length && s <= 0) ? !1 : (F1(this, e, n, i ? i.children.slice() : [], o - 1, s - 1), this.markDirty(), !0) } split(e) { let n = [], i = 0, r = -1, o = 0; for (let l of this.children) { let a = i + l.length; a > e && n.push(i < e ? l.split(e - i) : l), r < 0 && i >= e && (r = o), i = a, o++ } let s = this.length - e; return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new Ai(this.mark, n, s) } domAtPos(e) { return V1(this, e) } coordsAt(e, n) { return U1(this, e, n) } } function fA(t, e, n) { let i = t.nodeValue.length; e > i && (e = i); let r = e, o = e, s = 0; e == 0 && n < 0 || e == i && n >= 0 ? le.chrome || le.gecko || (e ? (r--, s = 1) : o < i && (o++, s = -1)) : n < 0 ? r-- : o < i && o++; let l = Vr(t, r, o).getClientRects(); if (!l.length) return null; let a = l[(s ? s < 0 : n >= 0) ? 0 : l.length - 1]; return le.safari && !s && a.width == 0 && (a = Array.prototype.find.call(l, c => c.width) || a), s ? Eu(a, s < 0) : a || null } class Yi extends He { static create(e, n, i) { return new Yi(e, n, i) } constructor(e, n, i) { super(), this.widget = e, this.length = n, this.side = i, this.prevWidget = null } split(e) { let n = Yi.create(this.widget, this.length - e, this.side); return this.length -= e, n } sync(e) { (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false")) } getSide() { return this.side } merge(e, n, i, r, o, s) { return i && (!(i instanceof Yi) || !this.widget.compare(i.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - n), !0) } become(e) { return e instanceof Yi && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1 } ignoreMutation() { return !0 } ignoreEvent(e) { return this.widget.ignoreEvent(e) } get overrideDOMText() { if (this.length == 0) return Be.empty; let e = this; for (; e.parent;)e = e.parent; let { view: n } = e, i = n && n.state.doc, r = this.posAtStart; return i ? i.slice(r, r + this.length) : Be.empty } domAtPos(e) { return (this.length ? e == 0 : this.side > 0) ? Et.before(this.dom) : Et.after(this.dom, e == this.length) } domBoundsAround() { return null } coordsAt(e, n) { let i = this.widget.coordsAt(this.dom, e, n); if (i) return i; let r = this.dom.getClientRects(), o = null; if (!r.length) return null; let s = this.side ? this.side < 0 : e > 0; for (let l = s ? r.length - 1 : 0; o = r[l], !(e > 0 ? l == 0 : l == r.length - 1 || o.top < o.bottom); l += s ? -1 : 1); return Eu(o, !s) } get isEditable() { return !1 } get isWidget() { return !0 } get isHidden() { return this.widget.isHidden } destroy() { super.destroy(), this.dom && this.widget.destroy(this.dom) } } class Ho extends He { constructor(e) { super(), this.side = e } get length() { return 0 } merge() { return !1 } become(e) { return e instanceof Ho && e.side == this.side } split() { return new Ho(this.side) } sync() { if (!this.dom) { let e = document.createElement("img"); e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e) } } getSide() { return this.side } domAtPos(e) { return this.side > 0 ? Et.before(this.dom) : Et.after(this.dom) } localPosFromDOM() { return 0 } domBoundsAround() { return null } coordsAt(e) { return this.dom.getBoundingClientRect() } get overrideDOMText() { return Be.empty } get isHidden() { return !0 } } Ln.prototype.children = Yi.prototype.children = Ho.prototype.children = Vp; function V1(t, e) { let n = t.dom, { children: i } = t, r = 0; for (let o = 0; r < i.length; r++) { let s = i[r], l = o + s.length; if (!(l == o && s.getSide() <= 0)) { if (e > o && e < l && s.dom.parentNode == n) return s.domAtPos(e - o); if (e <= o) break; o = l } } for (let o = r; o > 0; o--) { let s = i[o - 1]; if (s.dom.parentNode == n) return s.domAtPos(s.length) } for (let o = r; o < i.length; o++) { let s = i[o]; if (s.dom.parentNode == n) return s.domAtPos(0) } return new Et(n, 0) } function X1(t, e, n) { let i, { children: r } = t; n > 0 && e instanceof Ai && r.length && (i = r[r.length - 1]) instanceof Ai && i.mark.eq(e.mark) ? X1(i, e.children[0], n - 1) : (r.push(e), e.setParent(t)), t.length += e.length } function U1(t, e, n) { let i = null, r = -1, o = null, s = -1; function l(c, u) { for (let f = 0, h = 0; f < c.children.length && h <= u; f++) { let d = c.children[f], p = h + d.length; p >= u && (d.children.length ? l(d, u - h) : (!o || o.isHidden && n > 0) && (p > u || h == p && d.getSide() > 0) ? (o = d, s = u - h) : (h < u || h == p && d.getSide() < 0 && !d.isHidden) && (i = d, r = u - h)), h = p } } l(t, e); let a = (n < 0 ? i : o) || i || o; return a ? a.coordsAt(Math.max(0, a == i ? r : s), n) : hA(t) } function hA(t) { let e = t.dom.lastChild; if (!e) return t.dom.getBoundingClientRect(); let n = ml(e); return n[n.length - 1] || null } function cd(t, e) { for (let n in t) n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n]; return e } const d0 = Object.create(null); function Mc(t, e, n) { if (t == e) return !0; t || (t = d0), e || (e = d0); let i = Object.keys(t), r = Object.keys(e); if (i.length - (n && i.indexOf(n) > -1 ? 1 : 0) != r.length - (n && r.indexOf(n) > -1 ? 1 : 0)) return !1; for (let o of i) if (o != n && (r.indexOf(o) == -1 || t[o] !== e[o])) return !1; return !0 } function ud(t, e, n) { let i = !1; if (e) for (let r in e) n && r in n || (i = !0, r == "style" ? t.style.cssText = "" : t.removeAttribute(r)); if (n) for (let r in n) e && e[r] == n[r] || (i = !0, r == "style" ? t.style.cssText = n[r] : t.setAttribute(r, n[r])); return i } function dA(t) { let e = Object.create(null); for (let n = 0; n < t.attributes.length; n++) { let i = t.attributes[n]; e[i.name] = i.value } return e } class Ii { eq(e) { return !1 } updateDOM(e, n) { return !1 } compare(e) { return this == e || this.constructor == e.constructor && this.eq(e) } get estimatedHeight() { return -1 } get lineBreaks() { return 0 } ignoreEvent(e) { return !0 } coordsAt(e, n, i) { return null } get isHidden() { return !1 } get editable() { return !1 } destroy(e) { } } var Wt = function (t) { return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t }(Wt || (Wt = {})); class de extends jr { constructor(e, n, i, r) { super(), this.startSide = e, this.endSide = n, this.widget = i, this.spec = r } get heightRelevant() { return !1 } static mark(e) { return new Fl(e) } static widget(e) { let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block; return n += i && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new fr(e, n, n, i, e.widget || null, !1) } static replace(e) { let n = !!e.block, i, r; if (e.isBlockGap) i = -5e8, r = 4e8; else { let { start: o, end: s } = G1(e, n); i = (o ? n ? -3e8 : -1 : 5e8) - 1, r = (s ? n ? 2e8 : 1 : -6e8) + 1 } return new fr(e, i, r, n, e.widget || null, !0) } static line(e) { return new jl(e) } static set(e, n = !1) { return De.of(e, n) } hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : !1 } } de.none = De.empty; class Fl extends de { constructor(e) { let { start: n, end: i } = G1(e); super(n ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null } eq(e) { var n, i; return this == e || e instanceof Fl && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Mc(this.attrs, e.attrs, "class") } range(e, n = e) { if (e >= n) throw new RangeError("Mark decorations may not be empty"); return super.range(e, n) } } Fl.prototype.point = !1; class jl extends de { constructor(e) { super(-2e8, -2e8, null, e) } eq(e) { return e instanceof jl && this.spec.class == e.spec.class && Mc(this.spec.attributes, e.spec.attributes) } range(e, n = e) { if (n != e) throw new RangeError("Line decoration ranges must be zero-length"); return super.range(e, n) } } jl.prototype.mapMode = Tt.TrackBefore; jl.prototype.point = !0; class fr extends de { constructor(e, n, i, r, o, s) { super(n, i, o, e), this.block = r, this.isReplace = s, this.mapMode = r ? n <= 0 ? Tt.TrackBefore : Tt.TrackAfter : Tt.TrackDel } get type() { return this.startSide != this.endSide ? Wt.WidgetRange : this.startSide <= 0 ? Wt.WidgetBefore : Wt.WidgetAfter } get heightRelevant() { return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0) } eq(e) { return e instanceof fr && pA(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide } range(e, n = e) { if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration"); if (!this.isReplace && n != e) throw new RangeError("Widget decorations can only have zero-length ranges"); return super.range(e, n) } } fr.prototype.point = !0; function G1(t, e = !1) { let { inclusiveStart: n, inclusiveEnd: i } = t; return n == null && (n = t.inclusive), i == null && (i = t.inclusive), { start: n ?? e, end: i ?? e } } function pA(t, e) { return t == e || !!(t && e && t.compare(e)) } function fd(t, e, n, i = 0) { let r = n.length - 1; r >= 0 && n[r] + i >= t ? n[r] = Math.max(n[r], e) : n.push(t, e) } class ot extends He { constructor() { super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0 } merge(e, n, i, r, o, s) { if (i) { if (!(i instanceof ot)) return !1; this.dom || i.transferDOM(this) } return r && this.setDeco(i ? i.attrs : null), F1(this, e, n, i ? i.children.slice() : [], o, s), !0 } split(e) { let n = new ot; if (n.breakAfter = this.breakAfter, this.length == 0) return n; let { i, off: r } = this.childPos(e); r && (n.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++); for (let o = i; o < this.children.length; o++)n.append(this.children[o], 0); for (; i > 0 && this.children[i - 1].length == 0;)this.children[--i].destroy(); return this.children.length = i, this.markDirty(), this.length = e, n } transferDOM(e) { this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null) } setDeco(e) { Mc(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e) } append(e, n) { X1(this, e, n) } addLineDeco(e) { let n = e.spec.attributes, i = e.spec.class; n && (this.attrs = cd(n, this.attrs || {})), i && (this.attrs = cd({ class: i }, this.attrs || {})) } domAtPos(e) { return V1(this, e) } reuseDOM(e) { e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6) } sync(e, n) { var i; this.dom ? this.flags & 4 && (L1(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (ud(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n); let r = this.dom.lastChild; for (; r && He.get(r) instanceof Ai;)r = r.lastChild; if (!r || !this.length || r.nodeName != "BR" && ((i = He.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!le.ios || !this.children.some(o => o instanceof Ln))) { let o = document.createElement("BR"); o.cmIgnore = !0, this.dom.appendChild(o) } } measureTextSize() { if (this.children.length == 0 || this.length > 20) return null; let e = 0, n; for (let i of this.children) { if (!(i instanceof Ln) || /[^ -~]/.test(i.text)) return null; let r = ml(i.dom); if (r.length != 1) return null; e += r[0].width, n = r[0].height } return e ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: e / this.length, textHeight: n } : null } coordsAt(e, n) { let i = U1(this, e, n); if (!this.children.length && i && this.parent) { let { heightOracle: r } = this.parent.view.viewState, o = i.bottom - i.top; if (Math.abs(o - r.lineHeight) < 2 && r.textHeight < o) { let s = (o - r.textHeight) / 2; return { top: i.top + s, bottom: i.bottom - s, left: i.left, right: i.left } } } return i } become(e) { return e instanceof ot && this.children.length == 0 && e.children.length == 0 && Mc(this.attrs, e.attrs) && this.breakAfter == e.breakAfter } covers() { return !0 } static find(e, n) { for (let i = 0, r = 0; i < e.children.length; i++) { let o = e.children[i], s = r + o.length; if (s >= n) { if (o instanceof ot) return o; if (s > n) break } r = s + o.breakAfter } return null } } class ki extends He { constructor(e, n, i) { super(), this.widget = e, this.length = n, this.deco = i, this.breakAfter = 0, this.prevWidget = null } merge(e, n, i, r, o, s) { return i && (!(i instanceof ki) || !this.widget.compare(i.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - n), !0) } domAtPos(e) { return e == 0 ? Et.before(this.dom) : Et.after(this.dom, e == this.length) } split(e) { let n = this.length - e; this.length = e; let i = new ki(this.widget, n, this.deco); return i.breakAfter = this.breakAfter, i } get children() { return Vp } sync(e) { (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false")) } get overrideDOMText() { return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Be.empty } domBoundsAround() { return null } become(e) { return e instanceof ki && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1 } ignoreMutation() { return !0 } ignoreEvent(e) { return this.widget.ignoreEvent(e) } get isEditable() { return !1 } get isWidget() { return !0 } coordsAt(e, n) { let i = this.widget.coordsAt(this.dom, e, n); return i || (this.widget instanceof hd ? null : Eu(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0)) } destroy() { super.destroy(), this.dom && this.widget.destroy(this.dom) } covers(e) { let { startSide: n, endSide: i } = this.deco; return n == i ? !1 : e < 0 ? n < 0 : i > 0 } } class hd extends Ii { constructor(e) { super(), this.height = e } toDOM() { let e = document.createElement("div"); return e.className = "cm-gap", this.updateDOM(e), e } eq(e) { return e.height == this.height } updateDOM(e) { return e.style.height = this.height + "px", !0 } get editable() { return !0 } get estimatedHeight() { return this.height } ignoreEvent() { return !1 } } class Zs { constructor(e, n, i, r) { this.doc = e, this.pos = n, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n } posCovered() { if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos; let e = this.content[this.content.length - 1]; return !(e.breakAfter || e instanceof ki && e.deco.endSide < 0) } getLine() { return this.curLine || (this.content.push(this.curLine = new ot), this.atCursorPos = !0), this.curLine } flushBuffer(e = this.bufferMarks) { this.pendingBuffer && (this.curLine.append(fa(new Ho(-1), e), e.length), this.pendingBuffer = 0) } addBlockWidget(e) { this.flushBuffer(), this.curLine = null, this.content.push(e) } finish(e) { this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof ki) && this.getLine() } buildText(e, n, i) { for (; e > 0;) { if (this.textOff == this.text.length) { let { value: o, lineBreak: s, done: l } = this.cursor.next(this.skip); if (this.skip = 0, l) throw new Error("Ran out of text content when drawing inline views"); if (s) { this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--; continue } else this.text = o, this.textOff = 0 } let r = Math.min(this.text.length - this.textOff, e, 512); this.flushBuffer(n.slice(n.length - i)), this.getLine().append(fa(new Ln(this.text.slice(this.textOff, this.textOff + r)), n), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0 } } span(e, n, i, r) { this.buildText(n - e, i, r), this.pos = n, this.openStart < 0 && (this.openStart = r) } point(e, n, i, r, o, s) { if (this.disallowBlockEffectsFor[s] && i instanceof fr) { if (i.block) throw new RangeError("Block decorations may not be specified via plugins"); if (n > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins") } let l = n - e; if (i instanceof fr) if (i.block) i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new ki(i.widget || Fo.block, l, i)); else { let a = Yi.create(i.widget || Fo.inline, l, l ? 0 : i.startSide), c = this.atCursorPos && !a.isEditable && o <= r.length && (e < n || i.startSide > 0), u = !a.isEditable && (e < n || o > r.length || i.startSide <= 0), f = this.getLine(); this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (f.append(fa(new Ho(1), r), o), o = r.length + Math.max(0, o - r.length)), f.append(fa(a, r), o), this.atCursorPos = u, this.pendingBuffer = u ? e < n || o > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice()) } else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i); l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o) } static build(e, n, i, r, o) { let s = new Zs(e, n, i, o); return s.openEnd = De.spans(r, n, i, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s } } function fa(t, e) { for (let n of e) t = new Ai(n, [t], t.length); return t } class Fo extends Ii { constructor(e) { super(), this.tag = e } eq(e) { return e.tag == this.tag } toDOM() { return document.createElement(this.tag) } updateDOM(e) { return e.nodeName.toLowerCase() == this.tag } get isHidden() { return !0 } } Fo.inline = new Fo("span"); Fo.block = new Fo("div"); var Ge = function (t) { return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t }(Ge || (Ge = {})); const Xr = Ge.LTR, Xp = Ge.RTL; function K1(t) { let e = []; for (let n = 0; n < t.length; n++)e.push(1 << +t[n]); return e } const gA = K1("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), mA = K1("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), dd = Object.create(null), Hn = []; for (let t of ["()", "[]", "{}"]) { let e = t.charCodeAt(0), n = t.charCodeAt(1); dd[e] = n, dd[n] = -e } function Y1(t) { return t <= 247 ? gA[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? mA[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1 } const vA = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/; class Zi { get dir() { return this.level % 2 ? Xp : Xr } constructor(e, n, i) { this.from = e, this.to = n, this.level = i } side(e, n) { return this.dir == n == e ? this.to : this.from } forward(e, n) { return e == (this.dir == n) } static find(e, n, i, r) { let o = -1; for (let s = 0; s < e.length; s++) { let l = e[s]; if (l.from <= n && l.to >= n) { if (l.level == i) return s; (o < 0 || (r != 0 ? r < 0 ? l.from < n : l.to > n : e[o].level > l.level)) && (o = s) } } if (o < 0) throw new RangeError("Index out of range"); return o } } function Z1(t, e) { if (t.length != e.length) return !1; for (let n = 0; n < t.length; n++) { let i = t[n], r = e[n]; if (i.from != r.from || i.to != r.to || i.direction != r.direction || !Z1(i.inner, r.inner)) return !1 } return !0 } const ze = []; function yA(t, e, n, i, r) { for (let o = 0; o <= i.length; o++) { let s = o ? i[o - 1].to : e, l = o < i.length ? i[o].from : n, a = o ? 256 : r; for (let c = s, u = a, f = a; c < l; c++) { let h = Y1(t.charCodeAt(c)); h == 512 ? h = u : h == 8 && f == 4 && (h = 16), ze[c] = h == 4 ? 2 : h, h & 7 && (f = h), u = h } for (let c = s, u = a, f = a; c < l; c++) { let h = ze[c]; if (h == 128) c < l - 1 && u == ze[c + 1] && u & 24 ? h = ze[c] = u : ze[c] = 256; else if (h == 64) { let d = c + 1; for (; d < l && ze[d] == 64;)d++; let p = c && u == 8 || d < n && ze[d] == 8 ? f == 1 ? 1 : 8 : 256; for (let g = c; g < d; g++)ze[g] = p; c = d - 1 } else h == 8 && f == 1 && (ze[c] = 1); u = h, h & 7 && (f = h) } } } function bA(t, e, n, i, r) { let o = r == 1 ? 2 : 1; for (let s = 0, l = 0, a = 0; s <= i.length; s++) { let c = s ? i[s - 1].to : e, u = s < i.length ? i[s].from : n; for (let f = c, h, d, p; f < u; f++)if (d = dd[h = t.charCodeAt(f)]) if (d < 0) { for (let g = l - 3; g >= 0; g -= 3)if (Hn[g + 1] == -d) { let m = Hn[g + 2], v = m & 2 ? r : m & 4 ? m & 1 ? o : r : 0; v && (ze[f] = ze[Hn[g]] = v), l = g; break } } else { if (Hn.length == 189) break; Hn[l++] = f, Hn[l++] = h, Hn[l++] = a } else if ((p = ze[f]) == 2 || p == 1) { let g = p == r; a = g ? 0 : 1; for (let m = l - 3; m >= 0; m -= 3) { let v = Hn[m + 2]; if (v & 2) break; if (g) Hn[m + 2] |= 2; else { if (v & 4) break; Hn[m + 2] |= 4 } } } } } function OA(t, e, n, i) { for (let r = 0, o = i; r <= n.length; r++) { let s = r ? n[r - 1].to : t, l = r < n.length ? n[r].from : e; for (let a = s; a < l;) { let c = ze[a]; if (c == 256) { let u = a + 1; for (; ;)if (u == l) { if (r == n.length) break; u = n[r++].to, l = r < n.length ? n[r].from : e } else if (ze[u] == 256) u++; else break; let f = o == 1, h = (u < e ? ze[u] : i) == 1, d = f == h ? f ? 1 : 2 : i; for (let p = u, g = r, m = g ? n[g - 1].to : t; p > a;)p == m && (p = n[--g].from, m = g ? n[g - 1].to : t), ze[--p] = d; a = u } else o = c, a++ } } } function pd(t, e, n, i, r, o, s) { let l = i % 2 ? 2 : 1; if (i % 2 == r % 2) for (let a = e, c = 0; a < n;) { let u = !0, f = !1; if (c == o.length || a < o[c].from) { let g = ze[a]; g != l && (u = !1, f = g == 16) } let h = !u && l == 1 ? [] : null, d = u ? i : i + 1, p = a; e: for (; ;)if (c < o.length && p == o[c].from) { if (f) break e; let g = o[c]; if (!u) for (let m = g.to, v = c + 1; ;) { if (m == n) break e; if (v < o.length && o[v].from == m) m = o[v++].to; else { if (ze[m] == l) break e; break } } if (c++, h) h.push(g); else { g.from > a && s.push(new Zi(a, g.from, d)); let m = g.direction == Xr != !(d % 2); gd(t, m ? i + 1 : i, r, g.inner, g.from, g.to, s), a = g.to } p = g.to } else { if (p == n || (u ? ze[p] != l : ze[p] == l)) break; p++ } h ? pd(t, a, p, i + 1, r, h, s) : a < p && s.push(new Zi(a, p, d)), a = p } else for (let a = n, c = o.length; a > e;) { let u = !0, f = !1; if (!c || a > o[c - 1].to) { let g = ze[a - 1]; g != l && (u = !1, f = g == 16) } let h = !u && l == 1 ? [] : null, d = u ? i : i + 1, p = a; e: for (; ;)if (c && p == o[c - 1].to) { if (f) break e; let g = o[--c]; if (!u) for (let m = g.from, v = c; ;) { if (m == e) break e; if (v && o[v - 1].to == m) m = o[--v].from; else { if (ze[m - 1] == l) break e; break } } if (h) h.push(g); else { g.to < a && s.push(new Zi(g.to, a, d)); let m = g.direction == Xr != !(d % 2); gd(t, m ? i + 1 : i, r, g.inner, g.from, g.to, s), a = g.from } p = g.from } else { if (p == e || (u ? ze[p - 1] != l : ze[p - 1] == l)) break; p-- } h ? pd(t, p, a, i + 1, r, h, s) : p < a && s.push(new Zi(p, a, d)), a = p } } function gd(t, e, n, i, r, o, s) { let l = e % 2 ? 2 : 1; yA(t, r, o, i, l), bA(t, r, o, i, l), OA(r, o, i, l), pd(t, r, o, e, n, i, s) } function SA(t, e, n) { if (!t) return [new Zi(0, 0, e == Xp ? 1 : 0)]; if (e == Xr && !n.length && !vA.test(t)) return J1(t.length); if (n.length) for (; t.length > ze.length;)ze[ze.length] = 256; let i = [], r = e == Xr ? 0 : 1; return gd(t, r, r, n, 0, t.length, i), i } function J1(t) { return [new Zi(0, t, 0)] } let eS = ""; function xA(t, e, n, i, r) { var o; let s = i.head - t.from, l = Zi.find(e, s, (o = i.bidiLevel) !== null && o !== void 0 ? o : -1, i.assoc), a = e[l], c = a.side(r, n); if (s == c) { let h = l += r ? 1 : -1; if (h < 0 || h >= e.length) return null; a = e[l = h], s = a.side(!r, n), c = a.side(r, n) } let u = kt(t.text, s, a.forward(r, n)); (u < a.from || u > a.to) && (u = c), eS = t.text.slice(Math.min(s, u), Math.max(s, u)); let f = l == (r ? e.length - 1 : 0) ? null : e[l + (r ? 1 : -1)]; return f && u == c && f.level + (r ? 0 : 1) < a.level ? z.cursor(f.side(!r, n) + t.from, f.forward(r, n) ? 1 : -1, f.level) : z.cursor(u + t.from, a.forward(r, n) ? -1 : 1, a.level) } function wA(t, e, n) { for (let i = e; i < n; i++) { let r = Y1(t.charCodeAt(i)); if (r == 1) return Xr; if (r == 2 || r == 4) return Xp } return Xr } const tS = se.define(), nS = se.define(), iS = se.define(), rS = se.define(), md = se.define(), oS = se.define(), sS = se.define(), Up = se.define(), Gp = se.define(), lS = se.define({ combine: t => t.some(e => e) }), aS = se.define({ combine: t => t.some(e => e) }), cS = se.define(); class Eo { constructor(e, n = "nearest", i = "nearest", r = 5, o = 5, s = !1) { this.range = e, this.y = n, this.x = i, this.yMargin = r, this.xMargin = o, this.isSnapshot = s } map(e) { return e.empty ? this : new Eo(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot) } clip(e) { return this.range.to <= e.doc.length ? this : new Eo(z.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot) } } const ha = Ce.define({ map: (t, e) => t.map(e) }), uS = Ce.define(); function Kt(t, e, n) { let i = t.facet(rS); i.length ? i[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e) } const Ui = se.define({ combine: t => t.length ? t[0] : !0 }); let CA = 0; const Rs = se.define(); class ct { constructor(e, n, i, r, o) { this.id = e, this.create = n, this.domEventHandlers = i, this.domEventObservers = r, this.extension = o(this) } static define(e, n) { const { eventHandlers: i, eventObservers: r, provide: o, decorations: s } = n || {}; return new ct(CA++, e, i, r, l => { let a = [Rs.of(l)]; return s && a.push(vl.of(c => { let u = c.plugin(l); return u ? s(u) : de.none })), o && a.push(o(l)), a }) } static fromClass(e, n) { return ct.define(i => new e(i), n) } } class Mf { constructor(e) { this.spec = e, this.mustUpdate = null, this.value = null } update(e) { if (this.value) { if (this.mustUpdate) { let n = this.mustUpdate; if (this.mustUpdate = null, this.value.update) try { this.value.update(n) } catch (i) { if (Kt(n.state, i, "CodeMirror plugin crashed"), this.value.destroy) try { this.value.destroy() } catch { } this.deactivate() } } } else if (this.spec) try { this.value = this.spec.create(e) } catch (n) { Kt(e.state, n, "CodeMirror plugin crashed"), this.deactivate() } return this } destroy(e) { var n; if (!((n = this.value) === null || n === void 0) && n.destroy) try { this.value.destroy() } catch (i) { Kt(e.state, i, "CodeMirror plugin crashed") } } deactivate() { this.spec = this.value = null } } const fS = se.define(), Kp = se.define(), vl = se.define(), hS = se.define(), Yp = se.define(), dS = se.define(); function p0(t, e) { let n = t.state.facet(dS); if (!n.length) return n; let i = n.map(o => o instanceof Function ? o(t) : o), r = []; return De.spans(i, e.from, e.to, { point() { }, span(o, s, l, a) { let c = o - e.from, u = s - e.from, f = r; for (let h = l.length - 1; h >= 0; h--, a--) { let d = l[h].spec.bidiIsolate, p; if (d == null && (d = wA(e.text, c, u)), a > 0 && f.length && (p = f[f.length - 1]).to == c && p.direction == d) p.to = u, f = p.inner; else { let g = { from: c, to: u, direction: d, inner: [] }; f.push(g), f = g.inner } } } }), r } const pS = se.define(); function gS(t) { let e = 0, n = 0, i = 0, r = 0; for (let o of t.state.facet(pS)) { let s = o(t); s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (i = Math.max(i, s.top)), s.bottom != null && (r = Math.max(r, s.bottom))) } return { left: e, right: n, top: i, bottom: r } } const Is = se.define(); class Sn { constructor(e, n, i, r) { this.fromA = e, this.toA = n, this.fromB = i, this.toB = r } join(e) { return new Sn(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB)) } addToSet(e) { let n = e.length, i = this; for (; n > 0; n--) { let r = e[n - 1]; if (!(r.fromA > i.toA)) { if (r.toA < i.fromA) break; i = i.join(r), e.splice(n - 1, 1) } } return e.splice(n, 0, i), e } static extendWithRanges(e, n) { if (n.length == 0) return e; let i = []; for (let r = 0, o = 0, s = 0, l = 0; ; r++) { let a = r == e.length ? null : e[r], c = s - l, u = a ? a.fromB : 1e9; for (; o < n.length && n[o] < u;) { let f = n[o], h = n[o + 1], d = Math.max(l, f), p = Math.min(u, h); if (d <= p && new Sn(d + c, p + c, d, p).addToSet(i), h > u) break; o += 2 } if (!a) return i; new Sn(a.fromA, a.toA, a.fromB, a.toB).addToSet(i), s = a.toA, l = a.toB } } } class Ec { constructor(e, n, i) { this.view = e, this.state = n, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = ut.empty(this.startState.doc.length); for (let o of i) this.changes = this.changes.compose(o.changes); let r = []; this.changes.iterChangedRanges((o, s, l, a) => r.push(new Sn(o, s, l, a))), this.changedRanges = r } static create(e, n, i) { return new Ec(e, n, i) } get viewportChanged() { return (this.flags & 4) > 0 } get heightChanged() { return (this.flags & 2) > 0 } get geometryChanged() { return this.docChanged || (this.flags & 10) > 0 } get focusChanged() { return (this.flags & 1) > 0 } get docChanged() { return !this.changes.empty } get selectionSet() { return this.transactions.some(e => e.selection) } get empty() { return this.flags == 0 && this.transactions.length == 0 } } class g0 extends He { get length() { return this.view.state.doc.length } constructor(e) { super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = new Set, this.editContextFormatting = de.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new ot], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Sn(0, 0, 0, e.state.doc.length)], 0, null) } update(e) { var n; let i = e.changedRanges; this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e); let r = -1; this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? r = this.domChanged.newSel.head : !EA(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head)); let o = r > -1 ? $A(this.view, e.changes, r) : null; if (this.domChanged = null, this.hasComposition) { this.markedForComposition.clear(); let { from: c, to: u } = this.hasComposition; i = new Sn(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(i.slice()) } this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (le.ie || le.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0); let s = this.decorations, l = this.updateDeco(), a = AA(s, l, e.changes); return i = Sn.extendWithRanges(i, a), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0) } updateInner(e, n, i) { this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, i); let { observer: r } = this.view; r.ignore(() => { this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : ""; let s = le.chrome || le.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0; this.sync(this.view, s), this.flags &= -8, s && (s.written || r.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "" }), this.markedForComposition.forEach(s => s.flags &= -9); let o = []; if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let s of this.children) s instanceof ki && s.widget instanceof hd && o.push(s.dom); r.updateGaps(o) } updateChildren(e, n, i) { let r = i ? i.range.addToSet(e.slice()) : e, o = this.childCursor(n); for (let s = r.length - 1; ; s--) { let l = s >= 0 ? r[s] : null; if (!l) break; let { fromA: a, toA: c, fromB: u, toB: f } = l, h, d, p, g; if (i && i.range.fromB < f && i.range.toB > u) { let w = Zs.build(this.view.state.doc, u, i.range.fromB, this.decorations, this.dynamicDecorationMap), y = Zs.build(this.view.state.doc, i.range.toB, f, this.decorations, this.dynamicDecorationMap); d = w.breakAtStart, p = w.openStart, g = y.openEnd; let C = this.compositionView(i); y.breakAtStart ? C.breakAfter = 1 : y.content.length && C.merge(C.length, C.length, y.content[0], !1, y.openStart, 0) && (C.breakAfter = y.content[0].breakAfter, y.content.shift()), w.content.length && C.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), h = w.content.concat(C).concat(y.content) } else ({ content: h, breakAtStart: d, openStart: p, openEnd: g } = Zs.build(this.view.state.doc, u, f, this.decorations, this.dynamicDecorationMap)); let { i: m, off: v } = o.findPos(c, 1), { i: b, off: x } = o.findPos(a, -1); H1(this, b, x, m, v, h, d, p, g) } i && this.fixCompositionDOM(i) } updateEditContextFormatting(e) { this.editContextFormatting = this.editContextFormatting.map(e.changes); for (let n of e.transactions) for (let i of n.effects) i.is(uS) && (this.editContextFormatting = i.value) } compositionView(e) { let n = new Ln(e.text.nodeValue); n.flags |= 8; for (let { deco: r } of e.marks) n = new Ai(r, [n], n.length); let i = new ot; return i.append(n, 0), i } fixCompositionDOM(e) { let n = (o, s) => { s.flags |= 8 | (s.children.some(a => a.flags & 7) ? 1 : 0), this.markedForComposition.add(s); let l = He.get(o); l && l != s && (l.dom = null), s.setDOM(o) }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i]; n(e.line, r); for (let o = e.marks.length - 1; o >= -1; o--)i = r.childPos(i.off, 1), r = r.children[i.i], n(o >= 0 ? e.marks[o].node : e.text, r) } updateSelection(e = !1, n = !1) { (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange(); let i = this.view.root.activeElement, r = i == this.dom, o = !r && tc(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i)); if (!(r || n || o)) return; let s = this.forceSelection; this.forceSelection = !1; let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head)); if (le.gecko && l.empty && !this.hasComposition && TA(a)) { let f = document.createTextNode(""); this.view.observer.ignore(() => a.node.insertBefore(f, a.node.childNodes[a.offset] || null)), a = c = new Et(f, 0), s = !0 } let u = this.view.observer.selectionRange; (s || !u.focusNode || (!Ys(a.node, a.offset, u.anchorNode, u.anchorOffset) || !Ys(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, l)) && (this.view.observer.ignore(() => { le.android && le.chrome && this.dom.contains(u.focusNode) && MA(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 })); let f = gl(this.view.root); if (f) if (l.empty) { if (le.gecko) { let h = kA(a.node, a.offset); if (h && h != 3) { let d = (h == 1 ? N1 : z1)(a.node, a.offset); d && (a = new Et(d.node, d.offset)) } } f.collapse(a.node, a.offset), l.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = l.bidiLevel) } else if (f.extend) { f.collapse(a.node, a.offset); try { f.extend(c.node, c.offset) } catch { } } else { let h = document.createRange(); l.anchor > l.head && ([a, c] = [c, a]), h.setEnd(c.node, c.offset), h.setStart(a.node, a.offset), f.removeAllRanges(), f.addRange(h) } o && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus()) }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new Et(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Et(u.focusNode, u.focusOffset) } suppressWidgetCursorChange(e, n) { return this.hasComposition && n.empty && Ys(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head } enforceCursorAssoc() { if (this.hasComposition) return; let { view: e } = this, n = e.state.selection.main, i = gl(e.root), { anchorNode: r, anchorOffset: o } = e.observer.selectionRange; if (!i || !n.empty || !n.assoc || !i.modify) return; let s = ot.find(this, n.head); if (!s) return; let l = s.posAtStart; if (n.head == l || n.head == l + s.length) return; let a = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1); if (!a || !c || a.bottom > c.top) return; let u = this.domAtPos(n.head + n.assoc); i.collapse(u.node, u.offset), i.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange(); let f = e.observer.selectionRange; e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != n.from && i.collapse(r, o) } moveToLine(e) { let n = this.dom, i; if (e.node != n) return e; for (let r = e.offset; !i && r < n.childNodes.length; r++) { let o = He.get(n.childNodes[r]); o instanceof ot && (i = o.domAtPos(0)) } for (let r = e.offset - 1; !i && r >= 0; r--) { let o = He.get(n.childNodes[r]); o instanceof ot && (i = o.domAtPos(o.length)) } return i ? new Et(i.node, i.offset, !0) : e } nearest(e) { for (let n = e; n;) { let i = He.get(n); if (i && i.rootView == this) return i; n = n.parentNode } return null } posFromDOM(e, n) { let i = this.nearest(e); if (!i) throw new RangeError("Trying to find position for a DOM position outside of the document"); return i.localPosFromDOM(e, n) + i.posAtStart } domAtPos(e) { let { i: n, off: i } = this.childCursor().findPos(e, -1); for (; n < this.children.length - 1;) { let r = this.children[n]; if (i < r.length || r instanceof ot) break; n++, i = 0 } return this.children[n].domAtPos(i) } coordsAt(e, n) { let i = null, r = 0; for (let o = this.length, s = this.children.length - 1; s >= 0; s--) { let l = this.children[s], a = o - l.breakAfter, c = a - l.length; if (a < e) break; if (c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!i || l instanceof ot && !(i instanceof ot && n >= 0))) i = l, r = c; else if (i && c == e && a == e && l instanceof ki && Math.abs(n) < 2) { if (l.deco.startSide < 0) break; s && (i = null) } o = c } return i ? i.coordsAt(e - r, n) : null } coordsForChar(e) { let { i: n, off: i } = this.childPos(e, 1), r = this.children[n]; if (!(r instanceof ot)) return null; for (; r.children.length;) { let { i: l, off: a } = r.childPos(i, 1); for (; ; l++) { if (l == r.children.length) return null; if ((r = r.children[l]).length) break } i = a } if (!(r instanceof Ln)) return null; let o = kt(r.text, i); if (o == i) return null; let s = Vr(r.dom, i, o).getClientRects(); for (let l = 0; l < s.length; l++) { let a = s[l]; if (l == s.length - 1 || a.top < a.bottom && a.left < a.right) return a } return null } measureVisibleLineHeights(e) { let n = [], { from: i, to: r } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == Ge.LTR; for (let c = 0, u = 0; u < this.children.length; u++) { let f = this.children[u], h = c + f.length; if (h > r) break; if (c >= i) { let d = f.dom.getBoundingClientRect(); if (n.push(d.height), s) { let p = f.dom.lastChild, g = p ? ml(p) : []; if (g.length) { let m = g[g.length - 1], v = a ? m.right - d.left : d.right - m.left; v > l && (l = v, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = h) } } } c = h + f.breakAfter } return n } textDirectionAt(e) { let { i: n } = this.childPos(e, 1); return getComputedStyle(this.children[n].dom).direction == "rtl" ? Ge.RTL : Ge.LTR } measureTextSize() { for (let o of this.children) if (o instanceof ot) { let s = o.measureTextSize(); if (s) return s } let e = document.createElement("div"), n, i, r; return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => { this.dom.appendChild(e); let o = ml(e.firstChild)[0]; n = e.getBoundingClientRect().height, i = o ? o.width / 27 : 7, r = o ? o.height : n, e.remove() }), { lineHeight: n, charWidth: i, textHeight: r } } childCursor(e = this.length) { let n = this.children.length; return n && (e -= this.children[--n].length), new W1(this.children, e, n) } computeBlockGapDeco() { let e = [], n = this.view.viewState; for (let i = 0, r = 0; ; r++) { let o = r == n.viewports.length ? null : n.viewports[r], s = o ? o.from - 1 : this.length; if (s > i) { let l = (n.lineBlockAt(s).bottom - n.lineBlockAt(i).top) / this.view.scaleY; e.push(de.replace({ widget: new hd(l), block: !0, inclusive: !0, isBlockGap: !0 }).range(i, s)) } if (!o) break; i = o.to + 1 } return de.set(e) } updateDeco() { let e = 1, n = this.view.state.facet(vl).map(o => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), i = !1, r = this.view.state.facet(hS).map((o, s) => { let l = typeof o == "function"; return l && (i = !0), l ? o(this.view) : o }); for (r.length && (this.dynamicDecorationMap[e++] = i, n.push(De.join(r))), this.decorations = [this.editContextFormatting, ...n, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; e < this.decorations.length;)this.dynamicDecorationMap[e++] = !1; return this.decorations } scrollIntoView(e) { if (e.isSnapshot) { let c = this.view.viewState.lineBlockAt(e.range.head); this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin; return } for (let c of this.view.state.facet(cS)) try { if (c(this.view, e.range, e)) return !0 } catch (u) { Kt(this.view.state, u, "scroll handler") } let { range: n } = e, i = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), r; if (!i) return; !n.empty && (r = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (i = { left: Math.min(i.left, r.left), top: Math.min(i.top, r.top), right: Math.max(i.right, r.right), bottom: Math.max(i.bottom, r.bottom) }); let o = gS(this.view), s = { left: i.left - o.left, top: i.top - o.top, right: i.right + o.right, bottom: i.bottom + o.bottom }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM; oA(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == Ge.LTR) } } function TA(t) { return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false") } function mS(t, e) { let n = t.observer.selectionRange; if (!n.focusNode) return null; let i = N1(n.focusNode, n.focusOffset), r = z1(n.focusNode, n.focusOffset), o = i || r; if (r && i && r.node != i.node) { let l = He.get(r.node); if (!l || l instanceof Ln && l.text != r.node.nodeValue) o = r; else if (t.docView.lastCompositionAfterCursor) { let a = He.get(i.node); !a || a instanceof Ln && a.text != i.node.nodeValue || (o = r) } } if (t.docView.lastCompositionAfterCursor = o != i, !o) return null; let s = e - o.offset; return { from: s, to: s + o.node.nodeValue.length, node: o.node } } function $A(t, e, n) { let i = mS(t, n); if (!i) return null; let { node: r, from: o, to: s } = i, l = r.nodeValue; if (/[\n\r]/.test(l) || t.state.doc.sliceString(i.from, i.to) != l) return null; let a = e.invertedDesc, c = new Sn(a.mapPos(o), a.mapPos(s), o, s), u = []; for (let f = r.parentNode; ; f = f.parentNode) { let h = He.get(f); if (h instanceof Ai) u.push({ node: f, deco: h.mark }); else { if (h instanceof ot || f.nodeName == "DIV" && f.parentNode == t.contentDOM) return { range: c, text: r, marks: u, line: f }; if (f != t.contentDOM) u.push({ node: f, deco: new Fl({ inclusive: !0, attributes: dA(f), tagName: f.tagName.toLowerCase() }) }); else return null } } } function kA(t, e) { return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0) } let PA = class { constructor() { this.changes = [] } compareRange(e, n) { fd(e, n, this.changes) } comparePoint(e, n) { fd(e, n, this.changes) } }; function AA(t, e, n) { let i = new PA; return De.compare(t, e, n, i), i.changes } function MA(t, e) { for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)if (n.nodeType == 1 && n.contentEditable == "false") return !0; return !1 } function EA(t, e) { let n = !1; return e && t.iterChangedRanges((i, r) => { i < e.to && r > e.from && (n = !0) }), n } function _A(t, e, n = 1) { let i = t.charCategorizer(e), r = t.doc.lineAt(e), o = e - r.from; if (r.length == 0) return z.cursor(e); o == 0 ? n = 1 : o == r.length && (n = -1); let s = o, l = o; n < 0 ? s = kt(r.text, o, !1) : l = kt(r.text, o); let a = i(r.text.slice(s, l)); for (; s > 0;) { let c = kt(r.text, s, !1); if (i(r.text.slice(c, s)) != a) break; s = c } for (; l < r.length;) { let c = kt(r.text, l); if (i(r.text.slice(l, c)) != a) break; l = c } return z.range(s + r.from, l + r.from) } function RA(t, e) { return e.left > t ? e.left - t : Math.max(0, t - e.right) } function IA(t, e) { return e.top > t ? e.top - t : Math.max(0, t - e.bottom) } function Ef(t, e) { return t.top < e.bottom - 1 && t.bottom > e.top + 1 } function m0(t, e) { return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t } function v0(t, e) { return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t } function vd(t, e, n) { let i, r, o, s, l = !1, a, c, u, f; for (let p = t.firstChild; p; p = p.nextSibling) { let g = ml(p); for (let m = 0; m < g.length; m++) { let v = g[m]; r && Ef(r, v) && (v = m0(v0(v, r.bottom), r.top)); let b = RA(e, v), x = IA(n, v); if (b == 0 && x == 0) return p.nodeType == 3 ? y0(p, e, n) : vd(p, e, n); if (!i || s > x || s == x && o > b) { i = p, r = v, o = b, s = x; let w = x ? n < v.top ? -1 : 1 : b ? e < v.left ? -1 : 1 : 0; l = !w || (w > 0 ? m < g.length - 1 : m > 0) } b == 0 ? n > v.bottom && (!u || u.bottom < v.bottom) ? (a = p, u = v) : n < v.top && (!f || f.top > v.top) && (c = p, f = v) : u && Ef(u, v) ? u = v0(u, v.bottom) : f && Ef(f, v) && (f = m0(f, v.top)) } } if (u && u.bottom >= n ? (i = a, r = u) : f && f.top <= n && (i = c, r = f), !i) return { node: t, offset: 0 }; let h = Math.max(r.left, Math.min(r.right, e)); if (i.nodeType == 3) return y0(i, h, n); if (l && i.contentEditable != "false") return vd(i, h, n); let d = Array.prototype.indexOf.call(t.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0); return { node: t, offset: d } } function y0(t, e, n) { let i = t.nodeValue.length, r = -1, o = 1e9, s = 0; for (let l = 0; l < i; l++) { let a = Vr(t, l, l + 1).getClientRects(); for (let c = 0; c < a.length; c++) { let u = a[c]; if (u.top == u.bottom) continue; s || (s = e - u.left); let f = (u.top > n ? u.top - n : n - u.bottom) - 1; if (u.left - 1 <= e && u.right + 1 >= e && f < o) { let h = e >= (u.left + u.right) / 2, d = h; if ((le.chrome || le.gecko) && Vr(t, l).getBoundingClientRect().left == u.right && (d = !h), f <= 0) return { node: t, offset: l + (d ? 1 : 0) }; r = l + (d ? 1 : 0), o = f } } } return { node: t, offset: r > -1 ? r : s > 0 ? t.nodeValue.length : 0 } } function vS(t, e, n, i = -1) { var r, o; let s = t.contentDOM.getBoundingClientRect(), l = s.top + t.viewState.paddingTop, a, { docHeight: c } = t.viewState, { x: u, y: f } = e, h = f - l; if (h < 0) return 0; if (h > c) return t.state.doc.length; for (let w = t.viewState.heightOracle.textHeight / 2, y = !1; a = t.elementAtHeight(h), a.type != Wt.Text;)for (; h = i > 0 ? a.bottom + w : a.top - w, !(h >= 0 && h <= c);) { if (y) return n ? null : 0; y = !0, i = -i } f = l + h; let d = a.from; if (d < t.viewport.from) return t.viewport.from == 0 ? 0 : n ? null : b0(t, s, a, u, f); if (d > t.viewport.to) return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : b0(t, s, a, u, f); let p = t.dom.ownerDocument, g = t.root.elementFromPoint ? t.root : p, m = g.elementFromPoint(u, f); m && !t.contentDOM.contains(m) && (m = null), m || (u = Math.max(s.left + 1, Math.min(s.right - 1, u)), m = g.elementFromPoint(u, f), m && !t.contentDOM.contains(m) && (m = null)); let v, b = -1; if (m && ((r = t.docView.nearest(m)) === null || r === void 0 ? void 0 : r.isEditable) != !1) { if (p.caretPositionFromPoint) { let w = p.caretPositionFromPoint(u, f); w && ({ offsetNode: v, offset: b } = w) } else if (p.caretRangeFromPoint) { let w = p.caretRangeFromPoint(u, f); w && ({ startContainer: v, startOffset: b } = w, (!t.contentDOM.contains(v) || le.safari && DA(v, b, u) || le.chrome && BA(v, b, u)) && (v = void 0)) } v && (b = Math.min(oi(v), b)) } if (!v || !t.docView.dom.contains(v)) { let w = ot.find(t.docView, d); if (!w) return h > a.top + a.height / 2 ? a.to : a.from; ({ node: v, offset: b } = vd(w.dom, u, f)) } let x = t.docView.nearest(v); if (!x) return null; if (x.isWidget && ((o = x.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) { let w = x.dom.getBoundingClientRect(); return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? x.posAtStart : x.posAtEnd } else return x.localPosFromDOM(v, b) + x.posAtStart } function b0(t, e, n, i, r) { let o = Math.round((i - e.left) * t.defaultCharacterWidth); if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) { let l = t.viewState.heightOracle.textHeight, a = Math.floor((r - n.top - (t.defaultLineHeight - l) * .5) / l); o += a * t.viewState.heightOracle.lineLength } let s = t.state.sliceDoc(n.from, n.to); return n.from + nd(s, o, t.state.tabSize) } function DA(t, e, n) { let i; if (t.nodeType != 3 || e != (i = t.nodeValue.length)) return !1; for (let r = t.nextSibling; r; r = r.nextSibling)if (r.nodeType != 1 || r.nodeName != "BR") return !1; return Vr(t, i - 1, i).getBoundingClientRect().left > n } function BA(t, e, n) { if (e != 0) return !1; for (let r = t; ;) { let o = r.parentNode; if (!o || o.nodeType != 1 || o.firstChild != r) return !1; if (o.classList.contains("cm-line")) break; r = o } let i = t.nodeType == 1 ? t.getBoundingClientRect() : Vr(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect(); return n - i.left > 5 } function yd(t, e) { let n = t.lineBlockAt(e); if (Array.isArray(n.type)) { for (let i of n.type) if (i.to > e || i.to == e && (i.to == n.to || i.type == Wt.Text)) return i } return n } function LA(t, e, n, i) { let r = yd(t, e.head), o = !i || r.type != Wt.Text || !(t.lineWrapping || r.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head); if (o) { let s = t.dom.getBoundingClientRect(), l = t.textDirectionAt(r.from), a = t.posAtCoords({ x: n == (l == Ge.LTR) ? s.right - 1 : s.left + 1, y: (o.top + o.bottom) / 2 }); if (a != null) return z.cursor(a, n ? -1 : 1) } return z.cursor(n ? r.to : r.from, n ? -1 : 1) } function O0(t, e, n, i) {
        let r = t.state.doc.lineAt(e.head), o = t.bidiSpans(r), s = t.textDirectionAt(r.from); for (let l = e, a = null; ;) {
            let c = xA(r, o, s, l, n), u = eS; if (!c) {
                if (r.number == (n ? t.state.doc.lines : 1)) return l; u = `
`, r = t.state.doc.line(r.number + (n ? 1 : -1)), o = t.bidiSpans(r), c = t.visualLineSide(r, !n)
            } if (a) { if (!a(u)) return l } else { if (!i) return c; a = i(u) } l = c
        }
    } function QA(t, e, n) { let i = t.state.charCategorizer(e), r = i(n); return o => { let s = i(o); return r == Ze.Space && (r = s), r == s } } function NA(t, e, n, i) { let r = e.head, o = n ? 1 : -1; if (r == (n ? t.state.doc.length : 0)) return z.cursor(r, e.assoc); let s = e.goalColumn, l, a = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(r, e.assoc || -1), u = t.documentTop; if (c) s == null && (s = c.left - a.left), l = o < 0 ? c.top : c.bottom; else { let d = t.viewState.lineBlockAt(r); s == null && (s = Math.min(a.right - a.left, t.defaultCharacterWidth * (r - d.from))), l = (o < 0 ? d.top : d.bottom) + u } let f = a.left + s, h = i ?? t.viewState.heightOracle.textHeight >> 1; for (let d = 0; ; d += 10) { let p = l + (h + d) * o, g = vS(t, { x: f, y: p }, !1, o); if (p < a.top || p > a.bottom || (o < 0 ? g < r : g > r)) { let m = t.docView.coordsForChar(g), v = !m || p < m.top ? -1 : 1; return z.cursor(g, v, void 0, s) } } } function nc(t, e, n) { for (; ;) { let i = 0; for (let r of t) r.between(e - 1, e + 1, (o, s, l) => { if (e > o && e < s) { let a = i || n || (e - o < s - e ? -1 : 1); e = a < 0 ? o : s, i = a } }); if (!i) return e } } function _f(t, e, n) { let i = nc(t.state.facet(Yp).map(r => r(t)), n.from, e.head > n.from ? -1 : 1); return i == n.from ? n : z.cursor(i, i < n.from ? 1 : -1) } const Ds = "￿"; class zA { constructor(e, n) { this.points = e, this.text = "", this.lineSeparator = n.facet(_e.lineSeparator) } append(e) { this.text += e } lineBreak() { this.text += Ds } readRange(e, n) { if (!e) return this; let i = e.parentNode; for (let r = e; ;) { this.findPointBefore(i, r); let o = this.text.length; this.readNode(r); let s = r.nextSibling; if (s == n) break; let l = He.get(r), a = He.get(s); (l && a ? l.breakAfter : (l ? l.breakAfter : Ac(r)) || Ac(s) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > o) && this.lineBreak(), r = s } return this.findPointBefore(i, n), this } readTextNode(e) { let n = e.nodeValue; for (let i of this.points) i.node == e && (i.pos = this.text.length + Math.min(i.offset, n.length)); for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ;) { let o = -1, s = 1, l; if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, i), s = this.lineSeparator.length) : (l = r.exec(n)) && (o = l.index, s = l[0].length), this.append(n.slice(i, o < 0 ? n.length : o)), o < 0) break; if (this.lineBreak(), s > 1) for (let a of this.points) a.node == e && a.pos > this.text.length && (a.pos -= s - 1); i = o + s } } readNode(e) { if (e.cmIgnore) return; let n = He.get(e), i = n && n.overrideDOMText; if (i != null) { this.findPointInside(e, i.length); for (let r = i.iter(); !r.next().done;)r.lineBreak ? this.lineBreak() : this.append(r.value) } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null) } findPointBefore(e, n) { for (let i of this.points) i.node == e && e.childNodes[i.offset] == n && (i.pos = this.text.length) } findPointInside(e, n) { for (let i of this.points) (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (WA(e, i.node, i.offset) ? n : 0)) } } function WA(t, e, n) { for (; ;) { if (!e || n < oi(e)) return !1; if (e == t) return !0; n = qr(e) + 1, e = e.parentNode } } class S0 { constructor(e, n) { this.node = e, this.offset = n, this.pos = -1 } } class HA { constructor(e, n, i, r) { this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = n > -1; let { impreciseHead: o, impreciseAnchor: s } = e.docView; if (e.state.readOnly && n > -1) this.newSel = null; else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, i, 0))) { let l = o || s ? [] : qA(e), a = new zA(l, e.state); a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = VA(l, this.bounds.from) } else { let l = e.observer.selectionRange, a = o && o.node == l.focusNode && o.offset == l.focusOffset || !od(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = s && s.node == l.anchorNode && s.offset == l.anchorOffset || !od(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), u = e.viewport; if ((le.ios || le.chrome) && e.state.selection.main.empty && a != c && (u.from > 0 || u.to < e.state.doc.length)) { let f = Math.min(a, c), h = Math.max(a, c), d = u.from - f, p = u.to - h; (d == 0 || d == 1 || f == 0) && (p == 0 || p == -1 || h == e.state.doc.length) && (a = 0, c = e.state.doc.length) } this.newSel = z.single(c, a) } } } function yS(t, e) {
        let n, { newSel: i } = e, r = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1; if (e.bounds) { let { from: s, to: l } = e.bounds, a = r.from, c = null; (o === 8 || le.android && e.text.length < l - s) && (a = r.to, c = "end"); let u = jA(t.state.doc.sliceString(s, l, Ds), e.text, a - s, c); u && (le.chrome && o == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Ds + Ds && u.toB--, n = { from: s + u.from, to: s + u.toA, insert: Be.of(e.text.slice(u.from, u.toB).split(Ds)) }) } else i && (!t.hasFocus && t.state.facet(Ui) || i.main.eq(r)) && (i = null); if (!n && !i) return !1; if (!n && e.typeOver && !r.empty && i && i.main.empty ? n = { from: r.from, to: r.to, insert: t.state.doc.slice(r.from, r.to) } : n && n.from >= r.from && n.to <= r.to && (n.from != r.from || n.to != r.to) && r.to - r.from - (n.to - n.from) <= 4 ? n = { from: r.from, to: r.to, insert: t.state.doc.slice(r.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, r.to)) } : (le.mac || le.android) && n && n.from == n.to && n.from == r.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (i && n.insert.length == 2 && (i = z.single(i.main.anchor - 1, i.main.head - 1)), n = { from: r.from, to: r.to, insert: Be.of([" "]) }) : le.chrome && n && n.from == n.to && n.from == r.head && n.insert.toString() == `
 `&& t.lineWrapping && (i && (i = z.single(i.main.anchor - 1, i.main.head - 1)), n = { from: r.from, to: r.to, insert: Be.of([" "]) }), n) return Zp(t, n, i, o); if (i && !i.main.eq(r)) { let s = !1, l = "select"; return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = !0), l = t.inputState.lastSelectionOrigin), t.dispatch({ selection: i, scrollIntoView: s, userEvent: l }), !0 } else return !1
    } function Zp(t, e, n, i = -1) { if (le.ios && t.inputState.flushIOSKey(e)) return !0; let r = t.state.selection.main; if (le.android && (e.to == r.to && (e.from == r.from || e.from == r.from - 1 && t.state.sliceDoc(e.from, r.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Mo(t.contentDOM, "Enter", 13) || (e.from == r.from - 1 && e.to == r.to && e.insert.length == 0 || i == 8 && e.insert.length < e.to - e.from && e.to > r.head) && Mo(t.contentDOM, "Backspace", 8) || e.from == r.from && e.to == r.to + 1 && e.insert.length == 0 && Mo(t.contentDOM, "Delete", 46))) return !0; let o = e.insert.toString(); t.inputState.composing >= 0 && t.inputState.composing++; let s, l = () => s || (s = FA(t, e, n)); return t.state.facet(oS).some(a => a(t, e.from, e.to, o, l)) || t.dispatch(l()), !0 } function FA(t, e, n) { let i, r = t.state, o = r.selection.main; if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) { let l = o.from < e.from ? r.sliceDoc(o.from, e.from) : "", a = o.to > e.to ? r.sliceDoc(e.to, o.to) : ""; i = r.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + a)) } else { let l = r.changes(e), a = n && n.main.to <= l.newLength ? n.main : void 0; if (r.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) { let c = t.state.sliceDoc(e.from, e.to), u, f = n && mS(t, n.main.head); if (f) { let p = e.insert.length - (e.to - e.from); u = { from: f.from, to: f.to - p } } else u = t.state.doc.lineAt(o.head); let h = o.to - e.to, d = o.to - o.from; i = r.changeByRange(p => { if (p.from == o.from && p.to == o.to) return { changes: l, range: a || p.map(l) }; let g = p.to - h, m = g - c.length; if (p.to - p.from != d || t.state.sliceDoc(m, g) != c || p.to >= u.from && p.from <= u.to) return { range: p }; let v = r.changes({ from: m, to: g, insert: e.insert }), b = p.to - o.to; return { changes: v, range: a ? z.range(Math.max(0, a.anchor + b), Math.max(0, a.head + b)) : p.map(v) } }) } else i = { changes: l, selection: a && r.selection.replaceRange(a) } } let s = "input.type"; return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, s += ".compose", t.inputState.compositionFirstChange && (s += ".start", t.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: s, scrollIntoView: !0 }) } function jA(t, e, n, i) { let r = Math.min(t.length, e.length), o = 0; for (; o < r && t.charCodeAt(o) == e.charCodeAt(o);)o++; if (o == r && t.length == e.length) return null; let s = t.length, l = e.length; for (; s > 0 && l > 0 && t.charCodeAt(s - 1) == e.charCodeAt(l - 1);)s--, l--; if (i == "end") { let a = Math.max(0, o - Math.min(s, l)); n -= s + a - o } if (s < o && t.length < e.length) { let a = n <= o && n >= s ? o - n : 0; o -= a, l = o + (l - s), s = o } else if (l < o) { let a = n <= o && n >= l ? o - n : 0; o -= a, s = o + (s - l), l = o } return { from: o, toA: s, toB: l } } function qA(t) { let e = []; if (t.root.activeElement != t.contentDOM) return e; let { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: o } = t.observer.selectionRange; return n && (e.push(new S0(n, i)), (r != n || o != i) && e.push(new S0(r, o))), e } function VA(t, e) { if (t.length == 0) return null; let n = t[0].pos, i = t.length == 2 ? t[1].pos : n; return n > -1 && i > -1 ? z.single(n + e, i + e) : null } class XA { setSelectionOrigin(e) { this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now() } constructor(e) { this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, le.safari && e.contentDOM.addEventListener("input", () => null), le.gecko && cM(e.contentDOM.ownerDocument) } handleEvent(e) { !tM(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e) } runHandlers(e, n) { let i = this.handlers[e]; if (i) { for (let r of i.observers) r(this.view, n); for (let r of i.handlers) { if (n.defaultPrevented) break; if (r(this.view, n)) { n.preventDefault(); break } } } } ensureHandlers(e) { let n = UA(e), i = this.handlers, r = this.view.contentDOM; for (let o in n) if (o != "scroll") { let s = !n[o].handlers.length, l = i[o]; l && s != !l.handlers.length && (r.removeEventListener(o, this.handleEvent), l = null), l || r.addEventListener(o, this.handleEvent, { passive: s }) } for (let o in i) o != "scroll" && !n[o] && r.removeEventListener(o, this.handleEvent); this.handlers = n } keydown(e) { if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return !0; if (this.tabFocusMode > 0 && e.keyCode != 27 && OS.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), le.android && le.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8)) return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0; let n; return le.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = bS.find(i => i.keyCode == e.keyCode)) && !e.ctrlKey || GA.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1) } flushIOSKey(e) { let n = this.pendingIOSKey; return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Mo(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0)) } ignoreDuringComposition(e) { return /^key/.test(e.type) ? this.composing > 0 ? !0 : le.safari && !le.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1 } startMouseSelection(e) { this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e } update(e) { this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0) } destroy() { this.mouseSelection && this.mouseSelection.destroy() } } function x0(t, e) { return (n, i) => { try { return e.call(t, i, n) } catch (r) { Kt(n.state, r) } } } function UA(t) { let e = Object.create(null); function n(i) { return e[i] || (e[i] = { observers: [], handlers: [] }) } for (let i of t) { let r = i.spec; if (r && r.domEventHandlers) for (let o in r.domEventHandlers) { let s = r.domEventHandlers[o]; s && n(o).handlers.push(x0(i.value, s)) } if (r && r.domEventObservers) for (let o in r.domEventObservers) { let s = r.domEventObservers[o]; s && n(o).observers.push(x0(i.value, s)) } } for (let i in Qn) n(i).handlers.push(Qn[i]); for (let i in Cn) n(i).observers.push(Cn[i]); return e } const bS = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], GA = "dthko", OS = [16, 17, 18, 20, 91, 92, 224, 225], da = 6; function pa(t) { return Math.max(0, t) * .7 + 8 } function KA(t, e) { return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY)) } class YA { constructor(e, n, i, r) { this.view = e, this.startEvent = n, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = sA(e.contentDOM), this.atoms = e.state.facet(Yp).map(s => s(e)); let o = e.contentDOM.ownerDocument; o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(_e.allowMultipleSelections) && ZA(e, n), this.dragging = eM(e, n) && wS(n) == 1 ? null : !1 } start(e) { this.dragging === !1 && this.select(e) } move(e) { if (e.buttons == 0) return this.destroy(); if (this.dragging || this.dragging == null && KA(this.startEvent, e) < 10) return; this.select(this.lastEvent = e); let n = 0, i = 0, r = 0, o = 0, s = this.view.win.innerWidth, l = this.view.win.innerHeight; this.scrollParents.x && ({ left: r, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: l } = this.scrollParents.y.getBoundingClientRect()); let a = gS(this.view); e.clientX - a.left <= r + da ? n = -pa(r - e.clientX) : e.clientX + a.right >= s - da && (n = pa(e.clientX - s)), e.clientY - a.top <= o + da ? i = -pa(o - e.clientY) : e.clientY + a.bottom >= l - da && (i = pa(e.clientY - l)), this.setScrollSpeed(n, i) } up(e) { this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy() } destroy() { this.setScrollSpeed(0, 0); let e = this.view.contentDOM.ownerDocument; e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null } setScrollSpeed(e, n) { this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1) } scroll() { let { x: e, y: n } = this.scrollSpeed; e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent) } skipAtoms(e) { let n = null; for (let i = 0; i < e.ranges.length; i++) { let r = e.ranges[i], o = null; if (r.empty) { let s = nc(this.atoms, r.from, 0); s != r.from && (o = z.cursor(s, -1)) } else { let s = nc(this.atoms, r.from, -1), l = nc(this.atoms, r.to, 1); (s != r.from || l != r.to) && (o = z.range(r.from == r.anchor ? s : l, r.from == r.head ? s : l)) } o && (n || (n = e.ranges.slice()), n[i] = o) } return n ? z.create(n, e.mainIndex) : e } select(e) { let { view: n } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple)); (this.mustSelect || !i.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({ selection: i, userEvent: "select.pointer" }), this.mustSelect = !1 } update(e) { e.transactions.some(n => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20) } } function ZA(t, e) { let n = t.state.facet(tS); return n.length ? n[0](e) : le.mac ? e.metaKey : e.ctrlKey } function JA(t, e) { let n = t.state.facet(nS); return n.length ? n[0](e) : le.mac ? !e.altKey : !e.ctrlKey } function eM(t, e) { let { main: n } = t.state.selection; if (n.empty) return !1; let i = gl(t.root); if (!i || i.rangeCount == 0) return !0; let r = i.getRangeAt(0).getClientRects(); for (let o = 0; o < r.length; o++) { let s = r[o]; if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY) return !0 } return !1 } function tM(t, e) { if (!e.bubbles) return !0; if (e.defaultPrevented) return !1; for (let n = e.target, i; n != t.contentDOM; n = n.parentNode)if (!n || n.nodeType == 11 || (i = He.get(n)) && i.ignoreEvent(e)) return !1; return !0 } const Qn = Object.create(null), Cn = Object.create(null), SS = le.ie && le.ie_version < 15 || le.ios && le.webkit_version < 604; function nM(t) { let e = t.dom.parentNode; if (!e) return; let n = e.appendChild(document.createElement("textarea")); n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => { t.focus(), n.remove(), xS(t, n.value) }, 50) } function Ru(t, e, n) { for (let i of t.facet(e)) n = i(n, t); return n } function xS(t, e) { e = Ru(t.state, Up, e); let { state: n } = t, i, r = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length; if (bd != null && n.selection.ranges.every(a => a.empty) && bd == o.toString()) { let a = -1; i = n.changeByRange(c => { let u = n.doc.lineAt(c.from); if (u.from == a) return { range: c }; a = u.from; let f = n.toText((s ? o.line(r++).text : e) + n.lineBreak); return { changes: { from: u.from, insert: f }, range: z.cursor(c.from + f.length) } }) } else s ? i = n.changeByRange(a => { let c = o.line(r++); return { changes: { from: a.from, to: a.to, insert: c.text }, range: z.cursor(a.from + c.length) } }) : i = n.replaceSelection(o); t.dispatch(i, { userEvent: "input.paste", scrollIntoView: !0 }) } Cn.scroll = t => { t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft }; Qn.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1); Cn.touchstart = (t, e) => { t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer") }; Cn.touchmove = t => { t.inputState.setSelectionOrigin("select.pointer") }; Qn.mousedown = (t, e) => { if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3) return !1; let n = null; for (let i of t.state.facet(iS)) if (n = i(t, e), n) break; if (!n && e.button == 0 && (n = oM(t, e)), n) { let i = !t.hasFocus; t.inputState.startMouseSelection(new YA(t, e, n, i)), i && t.observer.ignore(() => { B1(t.contentDOM); let o = t.root.activeElement; o && !o.contains(t.contentDOM) && o.blur() }); let r = t.inputState.mouseSelection; if (r) return r.start(e), r.dragging === !1 } return !1 }; function w0(t, e, n, i) { if (i == 1) return z.cursor(e, n); if (i == 2) return _A(t.state, e, n); { let r = ot.find(t.docView, e), o = t.state.doc.lineAt(r ? r.posAtEnd : e), s = r ? r.posAtStart : o.from, l = r ? r.posAtEnd : o.to; return l < t.state.doc.length && l == o.to && l++, z.range(s, l) } } let C0 = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right; function iM(t, e, n, i) { let r = ot.find(t.docView, e); if (!r) return 1; let o = e - r.posAtStart; if (o == 0) return 1; if (o == r.length) return -1; let s = r.coordsAt(o, -1); if (s && C0(n, i, s)) return -1; let l = r.coordsAt(o, 1); return l && C0(n, i, l) ? 1 : s && s.bottom >= i ? -1 : 1 } function T0(t, e) { let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1); return { pos: n, bias: iM(t, n, e.clientX, e.clientY) } } const rM = le.ie && le.ie_version <= 11; let $0 = null, k0 = 0, P0 = 0; function wS(t) { if (!rM) return t.detail; let e = $0, n = P0; return $0 = t, P0 = Date.now(), k0 = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (k0 + 1) % 3 : 1 } function oM(t, e) { let n = T0(t, e), i = wS(e), r = t.state.selection; return { update(o) { o.docChanged && (n.pos = o.changes.mapPos(n.pos), r = r.map(o.changes)) }, get(o, s, l) { let a = T0(t, o), c, u = w0(t, a.pos, a.bias, i); if (n.pos != a.pos && !s) { let f = w0(t, n.pos, n.bias, i), h = Math.min(f.from, u.from), d = Math.max(f.to, u.to); u = h < u.from ? z.range(h, d) : z.range(d, h) } return s ? r.replaceRange(r.main.extend(u.from, u.to)) : l && i == 1 && r.ranges.length > 1 && (c = sM(r, a.pos)) ? c : l ? r.addRange(u) : z.create([u]) } } } function sM(t, e) { for (let n = 0; n < t.ranges.length; n++) { let { from: i, to: r } = t.ranges[n]; if (i <= e && r >= e) return z.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0)) } return null } Qn.dragstart = (t, e) => { let { selection: { main: n } } = t.state; if (e.target.draggable) { let r = t.docView.nearest(e.target); if (r && r.isWidget) { let o = r.posAtStart, s = o + r.length; (o >= n.to || s <= n.from) && (n = z.range(o, s)) } } let { inputState: i } = t; return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Ru(t.state, Gp, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), !1 }; Qn.dragend = t => (t.inputState.draggedContent = null, !1); function A0(t, e, n, i) { if (n = Ru(t.state, Up, n), !n) return; let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = t.inputState, s = i && o && JA(t, e) ? { from: o.from, to: o.to } : null, l = { from: r, insert: n }, a = t.state.changes(s ? [s, l] : l); t.focus(), t.dispatch({ changes: a, selection: { anchor: a.mapPos(r, -1), head: a.mapPos(r, 1) }, userEvent: s ? "move.drop" : "input.drop" }), t.inputState.draggedContent = null } Qn.drop = (t, e) => { if (!e.dataTransfer) return !1; if (t.state.readOnly) return !0; let n = e.dataTransfer.files; if (n && n.length) { let i = Array(n.length), r = 0, o = () => { ++r == n.length && A0(t, e, i.filter(s => s != null).join(t.state.lineBreak), !1) }; for (let s = 0; s < n.length; s++) { let l = new FileReader; l.onerror = o, l.onload = () => { /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[s] = l.result), o() }, l.readAsText(n[s]) } return !0 } else { let i = e.dataTransfer.getData("Text"); if (i) return A0(t, e, i, !0), !0 } return !1 }; Qn.paste = (t, e) => { if (t.state.readOnly) return !0; t.observer.flush(); let n = SS ? null : e.clipboardData; return n ? (xS(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (nM(t), !1) }; function lM(t, e) { let n = t.dom.parentNode; if (!n) return; let i = n.appendChild(document.createElement("textarea")); i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => { i.remove(), t.focus() }, 50) } function aM(t) { let e = [], n = [], i = !1; for (let r of t.selection.ranges) r.empty || (e.push(t.sliceDoc(r.from, r.to)), n.push(r)); if (!e.length) { let r = -1; for (let { from: o } of t.selection.ranges) { let s = t.doc.lineAt(o); s.number > r && (e.push(s.text), n.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), r = s.number } i = !0 } return { text: Ru(t, Gp, e.join(t.lineBreak)), ranges: n, linewise: i } } let bd = null; Qn.copy = Qn.cut = (t, e) => { let { text: n, ranges: i, linewise: r } = aM(t.state); if (!n && !r) return !1; bd = r ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({ changes: i, scrollIntoView: !0, userEvent: "delete.cut" }); let o = SS ? null : e.clipboardData; return o ? (o.clearData(), o.setData("text/plain", n), !0) : (lM(t, n), !1) }; const CS = Ri.define(); function TS(t, e) { let n = []; for (let i of t.facet(sS)) { let r = i(t, e); r && n.push(r) } return n ? t.update({ effects: n, annotations: CS.of(!0) }) : null } function $S(t) { setTimeout(() => { let e = t.hasFocus; if (e != t.inputState.notifiedFocused) { let n = TS(t.state, e); n ? t.dispatch(n) : t.update([]) } }, 10) } Cn.focus = t => { t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), $S(t) }; Cn.blur = t => { t.observer.clearSelectionRange(), $S(t) }; Cn.compositionstart = Cn.compositionupdate = t => { t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0)) }; Cn.compositionend = t => { t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, le.chrome && le.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => { t.inputState.composing < 0 && t.docView.hasComposition && t.update([]) }, 50)) }; Cn.contextmenu = t => { t.inputState.lastContextMenu = Date.now() }; Qn.beforeinput = (t, e) => { var n, i; if (e.inputType == "insertReplacementText" && t.observer.editContext) { let o = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), s = e.getTargetRanges(); if (o && s.length) { let l = s[0], a = t.posAtDOM(l.startContainer, l.startOffset), c = t.posAtDOM(l.endContainer, l.endOffset); return Zp(t, { from: a, to: c, insert: t.state.toText(o) }, null), !0 } } let r; if (le.chrome && le.android && (r = bS.find(o => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) { let o = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0; setTimeout(() => { var s; (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus()) }, 100) } return le.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), le.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => Cn.compositionend(t, e), 20), !1 }; const M0 = new Set; function cM(t) { M0.has(t) || (M0.add(t), t.addEventListener("copy", () => { }), t.addEventListener("cut", () => { })) } const E0 = ["pre-wrap", "normal", "pre-line", "break-spaces"]; let jo = !1; function _0() { jo = !1 } class uM { constructor(e) { this.lineWrapping = e, this.doc = Be.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30 } heightForGap(e, n) { let i = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1; return this.lineWrapping && (i += Math.max(0, Math.ceil((n - e - i * this.lineLength * .5) / this.lineLength))), this.lineHeight * i } heightForLine(e) { return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight } setDoc(e) { return this.doc = e, this } mustRefreshForWrapping(e) { return E0.indexOf(e) > -1 != this.lineWrapping } mustRefreshForHeights(e) { let n = !1; for (let i = 0; i < e.length; i++) { let r = e[i]; r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (n = !0, this.heightSamples[Math.floor(r * 10)] = !0) } return n } refresh(e, n, i, r, o, s) { let l = E0.indexOf(e) > -1, a = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != l; if (this.lineWrapping = l, this.lineHeight = n, this.charWidth = i, this.textHeight = r, this.lineLength = o, a) { this.heightSamples = {}; for (let c = 0; c < s.length; c++) { let u = s[c]; u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0 } } return a } } class fM { constructor(e, n) { this.from = e, this.heights = n, this.index = 0 } get more() { return this.index < this.heights.length } } class Yn { constructor(e, n, i, r, o) { this.from = e, this.length = n, this.top = i, this.height = r, this._content = o } get type() { return typeof this._content == "number" ? Wt.Text : Array.isArray(this._content) ? this._content : this._content.type } get to() { return this.from + this.length } get bottom() { return this.top + this.height } get widget() { return this._content instanceof fr ? this._content.widget : null } get widgetLineBreaks() { return typeof this._content == "number" ? this._content : 0 } join(e) { let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]); return new Yn(this.from, this.length + e.length, this.top, this.height + e.height, n) } } var Ue = function (t) { return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t }(Ue || (Ue = {})); const ic = .001; class Ht { constructor(e, n, i = 2) { this.length = e, this.height = n, this.flags = i } get outdated() { return (this.flags & 2) > 0 } set outdated(e) { this.flags = (e ? 2 : 0) | this.flags & -3 } setHeight(e) { this.height != e && (Math.abs(this.height - e) > ic && (jo = !0), this.height = e) } replace(e, n, i) { return Ht.of(i) } decomposeLeft(e, n) { n.push(this) } decomposeRight(e, n) { n.push(this) } applyChanges(e, n, i, r) { let o = this, s = i.doc; for (let l = r.length - 1; l >= 0; l--) { let { fromA: a, toA: c, fromB: u, toB: f } = r[l], h = o.lineAt(a, Ue.ByPosNoHeight, i.setDoc(n), 0, 0), d = h.to >= c ? h : o.lineAt(c, Ue.ByPosNoHeight, i, 0, 0); for (f += d.to - c, c = d.to; l > 0 && h.from <= r[l - 1].toA;)a = r[l - 1].fromA, u = r[l - 1].fromB, l--, a < h.from && (h = o.lineAt(a, Ue.ByPosNoHeight, i, 0, 0)); u += h.from - a, a = h.from; let p = Jp.build(i.setDoc(s), e, u, f); o = _c(o, o.replace(a, c, p)) } return o.updateHeight(i, 0) } static empty() { return new an(0, 0) } static of(e) { if (e.length == 1) return e[0]; let n = 0, i = e.length, r = 0, o = 0; for (; ;)if (n == i) if (r > o * 2) { let l = e[n - 1]; l.break ? e.splice(--n, 1, l.left, null, l.right) : e.splice(--n, 1, l.left, l.right), i += 1 + l.break, r -= l.size } else if (o > r * 2) { let l = e[i]; l.break ? e.splice(i, 1, l.left, null, l.right) : e.splice(i, 1, l.left, l.right), i += 2 + l.break, o -= l.size } else break; else if (r < o) { let l = e[n++]; l && (r += l.size) } else { let l = e[--i]; l && (o += l.size) } let s = 0; return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, i++), new hM(Ht.of(e.slice(0, n)), s, Ht.of(e.slice(i))) } } function _c(t, e) { return t == e ? t : (t.constructor != e.constructor && (jo = !0), e) } Ht.prototype.size = 1; class kS extends Ht { constructor(e, n, i) { super(e, n), this.deco = i } blockAt(e, n, i, r) { return new Yn(r, this.length, i, this.height, this.deco || 0) } lineAt(e, n, i, r, o) { return this.blockAt(0, i, r, o) } forEachLine(e, n, i, r, o, s) { e <= o + this.length && n >= o && s(this.blockAt(0, i, r, o)) } updateHeight(e, n = 0, i = !1, r) { return r && r.from <= n && r.more && this.setHeight(r.heights[r.index++]), this.outdated = !1, this } toString() { return `block(${this.length})` } } class an extends kS { constructor(e, n) { super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0 } blockAt(e, n, i, r) { return new Yn(r, this.length, i, this.height, this.breaks) } replace(e, n, i) { let r = i[0]; return i.length == 1 && (r instanceof an || r instanceof St && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof St ? r = new an(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Ht.of(i) } updateHeight(e, n = 0, i = !1, r) { return r && r.from <= n && r.more ? this.setHeight(r.heights[r.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this } toString() { return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})` } } class St extends Ht { constructor(e) { super(e, 0) } heightMetrics(e, n) { let i = e.doc.lineAt(n).number, r = e.doc.lineAt(n + this.length).number, o = r - i + 1, s, l = 0; if (e.lineWrapping) { let a = Math.min(this.height, e.lineHeight * o); s = a / o, this.length > o + 1 && (l = (this.height - a) / (this.length - o - 1)) } else s = this.height / o; return { firstLine: i, lastLine: r, perLine: s, perChar: l } } blockAt(e, n, i, r) { let { firstLine: o, lastLine: s, perLine: l, perChar: a } = this.heightMetrics(n, r); if (n.lineWrapping) { let c = r + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length)), u = n.doc.lineAt(c), f = l + u.length * a, h = Math.max(i, e - f / 2); return new Yn(u.from, u.length, h, f, 0) } else { let c = Math.max(0, Math.min(s - o, Math.floor((e - i) / l))), { from: u, length: f } = n.doc.line(o + c); return new Yn(u, f, i + l * c, l, 0) } } lineAt(e, n, i, r, o) { if (n == Ue.ByHeight) return this.blockAt(e, i, r, o); if (n == Ue.ByPosNoHeight) { let { from: d, to: p } = i.doc.lineAt(e); return new Yn(d, p - d, 0, 0, 0) } let { firstLine: s, perLine: l, perChar: a } = this.heightMetrics(i, o), c = i.doc.lineAt(e), u = l + c.length * a, f = c.number - s, h = r + l * f + a * (c.from - o - f); return new Yn(c.from, c.length, Math.max(r, Math.min(h, r + this.height - u)), u, 0) } forEachLine(e, n, i, r, o, s) { e = Math.max(e, o), n = Math.min(n, o + this.length); let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(i, o); for (let u = e, f = r; u <= n;) { let h = i.doc.lineAt(u); if (u == e) { let p = h.number - l; f += a * p + c * (e - o - p) } let d = a + c * h.length; s(new Yn(h.from, h.length, f, d, 0)), f += d, u = h.to + 1 } } replace(e, n, i) { let r = this.length - n; if (r > 0) { let o = i[i.length - 1]; o instanceof St ? i[i.length - 1] = new St(o.length + r) : i.push(null, new St(r - 1)) } if (e > 0) { let o = i[0]; o instanceof St ? i[0] = new St(e + o.length) : i.unshift(new St(e - 1), null) } return Ht.of(i) } decomposeLeft(e, n) { n.push(new St(e - 1), null) } decomposeRight(e, n) { n.push(null, new St(this.length - e - 1)) } updateHeight(e, n = 0, i = !1, r) { let o = n + this.length; if (r && r.from <= n + this.length && r.more) { let s = [], l = Math.max(n, r.from), a = -1; for (r.from > n && s.push(new St(r.from - n - 1).updateHeight(e, n)); l <= o && r.more;) { let u = e.doc.lineAt(l).length; s.length && s.push(null); let f = r.heights[r.index++]; a == -1 ? a = f : Math.abs(f - a) >= ic && (a = -2); let h = new an(u, f); h.outdated = !1, s.push(h), l += u + 1 } l <= o && s.push(null, new St(o - l).updateHeight(e, l)); let c = Ht.of(s); return (a < 0 || Math.abs(c.height - this.height) >= ic || Math.abs(a - this.heightMetrics(e, n).perLine) >= ic) && (jo = !0), _c(this, c) } else (i || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1); return this } toString() { return `gap(${this.length})` } } class hM extends Ht { constructor(e, n, i) { super(e.length + n + i.length, e.height + i.height, n | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size } get break() { return this.flags & 1 } blockAt(e, n, i, r) { let o = i + this.left.height; return e < o ? this.left.blockAt(e, n, i, r) : this.right.blockAt(e, n, o, r + this.left.length + this.break) } lineAt(e, n, i, r, o) { let s = r + this.left.height, l = o + this.left.length + this.break, a = n == Ue.ByHeight ? e < s : e < l, c = a ? this.left.lineAt(e, n, i, r, o) : this.right.lineAt(e, n, i, s, l); if (this.break || (a ? c.to < l : c.from > l)) return c; let u = n == Ue.ByPosNoHeight ? Ue.ByPosNoHeight : Ue.ByPos; return a ? c.join(this.right.lineAt(l, u, i, s, l)) : this.left.lineAt(l, u, i, r, o).join(c) } forEachLine(e, n, i, r, o, s) { let l = r + this.left.height, a = o + this.left.length + this.break; if (this.break) e < a && this.left.forEachLine(e, n, i, r, o, s), n >= a && this.right.forEachLine(e, n, i, l, a, s); else { let c = this.lineAt(a, Ue.ByPos, i, r, o); e < c.from && this.left.forEachLine(e, c.from - 1, i, r, o, s), c.to >= e && c.from <= n && s(c), n > c.to && this.right.forEachLine(c.to + 1, n, i, l, a, s) } } replace(e, n, i) { let r = this.left.length + this.break; if (n < r) return this.balanced(this.left.replace(e, n, i), this.right); if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - r, n - r, i)); let o = []; e > 0 && this.decomposeLeft(e, o); let s = o.length; for (let l of i) o.push(l); if (e > 0 && R0(o, s - 1), n < this.length) { let l = o.length; this.decomposeRight(n, o), R0(o, l) } return Ht.of(o) } decomposeLeft(e, n) { let i = this.left.length; if (e <= i) return this.left.decomposeLeft(e, n); n.push(this.left), this.break && (i++, e >= i && n.push(null)), e > i && this.right.decomposeLeft(e - i, n) } decomposeRight(e, n) { let i = this.left.length, r = i + this.break; if (e >= r) return this.right.decomposeRight(e - r, n); e < i && this.left.decomposeRight(e, n), this.break && e < r && n.push(null), n.push(this.right) } balanced(e, n) { return e.size > 2 * n.size || n.size > 2 * e.size ? Ht.of(this.break ? [e, null, n] : [e, n]) : (this.left = _c(this.left, e), this.right = _c(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this) } updateHeight(e, n = 0, i = !1, r) { let { left: o, right: s } = this, l = n + o.length + this.break, a = null; return r && r.from <= n + o.length && r.more ? a = o = o.updateHeight(e, n, i, r) : o.updateHeight(e, n, i), r && r.from <= l + s.length && r.more ? a = s = s.updateHeight(e, l, i, r) : s.updateHeight(e, l, i), a ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this) } toString() { return this.left + (this.break ? " " : "-") + this.right } } function R0(t, e) { let n, i; t[e] == null && (n = t[e - 1]) instanceof St && (i = t[e + 1]) instanceof St && t.splice(e - 1, 3, new St(n.length + 1 + i.length)) } const dM = 5; class Jp { constructor(e, n) { this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e } get isCovered() { return this.covering && this.nodes[this.nodes.length - 1] == this.covering } span(e, n) { if (this.lineStart > -1) { let i = Math.min(n, this.lineEnd), r = this.nodes[this.nodes.length - 1]; r instanceof an ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new an(i - this.pos, -1)), this.writtenTo = i, n > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1) } this.pos = n } point(e, n, i) { if (e < n || i.heightRelevant) { let r = i.widget ? i.widget.estimatedHeight : 0, o = i.widget ? i.widget.lineBreaks : 0; r < 0 && (r = this.oracle.lineHeight); let s = n - e; i.block ? this.addBlock(new kS(s, r, i)) : (s || o || r >= dM) && this.addLineDeco(r, o, s) } else n > e && this.span(e, n); this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to) } enterLine() { if (this.lineStart > -1) return; let { from: e, to: n } = this.oracle.doc.lineAt(this.pos); this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new an(this.pos - e, -1)), this.writtenTo = this.pos } blankContent(e, n) { let i = new St(n - e); return this.oracle.doc.lineAt(e).to == n && (i.flags |= 4), i } ensureLine() { this.enterLine(); let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null; if (e instanceof an) return e; let n = new an(0, -1); return this.nodes.push(n), n } addBlock(e) { this.enterLine(); let n = e.deco; n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e) } addLineDeco(e, n, i) { let r = this.ensureLine(); r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += n, this.writtenTo = this.pos = this.pos + i } finish(e) { let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1]; this.lineStart > -1 && !(n instanceof an) && !this.isCovered ? this.nodes.push(new an(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)); let i = e; for (let r of this.nodes) r instanceof an && r.updateHeight(this.oracle, i), i += r ? r.length : 1; return this.nodes } static build(e, n, i, r) { let o = new Jp(i, e); return De.spans(n, i, r, o, 0), o.finish(i) } } function pM(t, e, n) { let i = new gM; return De.compare(t, e, n, i, 0), i.changes } class gM { constructor() { this.changes = [] } compareRange() { } comparePoint(e, n, i, r) { (e < n || i && i.heightRelevant || r && r.heightRelevant) && fd(e, n, this.changes, 5) } } function mM(t, e) { let n = t.getBoundingClientRect(), i = t.ownerDocument, r = i.defaultView || window, o = Math.max(0, n.left), s = Math.min(r.innerWidth, n.right), l = Math.max(0, n.top), a = Math.min(r.innerHeight, n.bottom); for (let c = t.parentNode; c && c != i.body;)if (c.nodeType == 1) { let u = c, f = window.getComputedStyle(u); if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && f.overflow != "visible") { let h = u.getBoundingClientRect(); o = Math.max(o, h.left), s = Math.min(s, h.right), l = Math.max(l, h.top), a = Math.min(c == t.parentNode ? r.innerHeight : a, h.bottom) } c = f.position == "absolute" || f.position == "fixed" ? u.offsetParent : u.parentNode } else if (c.nodeType == 11) c = c.host; else break; return { left: o - n.left, right: Math.max(o, s) - n.left, top: l - (n.top + e), bottom: Math.max(l, a) - (n.top + e) } } function vM(t, e) { let n = t.getBoundingClientRect(); return { left: 0, right: n.right - n.left, top: e, bottom: n.bottom - (n.top + e) } } class Rf { constructor(e, n, i, r) { this.from = e, this.to = n, this.size = i, this.displaySize = r } static same(e, n) { if (e.length != n.length) return !1; for (let i = 0; i < e.length; i++) { let r = e[i], o = n[i]; if (r.from != o.from || r.to != o.to || r.size != o.size) return !1 } return !0 } draw(e, n) { return de.replace({ widget: new yM(this.displaySize * (n ? e.scaleY : e.scaleX), n) }).range(this.from, this.to) } } class yM extends Ii { constructor(e, n) { super(), this.size = e, this.vertical = n } eq(e) { return e.size == this.size && e.vertical == this.vertical } toDOM() { let e = document.createElement("div"); return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e } get estimatedHeight() { return this.vertical ? this.size : -1 } } class I0 { constructor(e) { this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = D0, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Ge.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1; let n = e.facet(Kp).some(i => typeof i != "function" && i.class == "cm-lineWrapping"); this.heightOracle = new uM(n), this.stateDeco = e.facet(vl).filter(i => typeof i != "function"), this.heightMap = Ht.empty().applyChanges(this.stateDeco, Be.empty, this.heightOracle.setDoc(e.doc), [new Sn(0, 0, 0, e.doc.length)]); for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++); this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = de.set(this.lineGaps.map(i => i.draw(this, !1))), this.computeVisibleRanges() } updateForViewport() { let e = [this.viewport], { main: n } = this.state.selection; for (let i = 0; i <= 1; i++) { let r = i ? n.head : n.anchor; if (!e.some(({ from: o, to: s }) => r >= o && r <= s)) { let { from: o, to: s } = this.lineBlockAt(r); e.push(new ga(o, s)) } } return this.viewports = e.sort((i, r) => i.from - r.from), this.updateScaler() } updateScaler() { let e = this.scaler; return this.scaler = this.heightMap.height <= 7e6 ? D0 : new eg(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2 } updateViewportLines() { this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, e => { this.viewportLines.push(Bs(e, this.scaler)) }) } update(e, n = null) { this.state = e.state; let i = this.stateDeco; this.stateDeco = this.state.facet(vl).filter(u => typeof u != "function"); let r = e.changedRanges, o = Sn.extendWithRanges(r, pM(i, this.stateDeco, e ? e.changes : ut.empty(this.state.doc.length))), s = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop); _0(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || jo) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height); let a = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport; (n && (n.range.head < a.from || n.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, n)); let c = a.from != this.viewport.from || a.to != this.viewport.to; this.viewport = a, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(aS) && (this.mustEnforceCursorAssoc = !0) } measure(e) { let n = e.contentDOM, i = window.getComputedStyle(n), r = this.heightOracle, o = i.whiteSpace; this.defaultTextDirection = i.direction == "rtl" ? Ge.RTL : Ge.LTR; let s = this.heightOracle.mustRefreshForWrapping(o), l = n.getBoundingClientRect(), a = s || this.mustMeasureContent || this.contentDOMHeight != l.height; this.contentDOMHeight = l.height, this.mustMeasureContent = !1; let c = 0, u = 0; if (l.width && l.height) { let { scaleX: w, scaleY: y } = D1(n, l); (w > .005 && Math.abs(this.scaleX - w) > .005 || y > .005 && Math.abs(this.scaleY - y) > .005) && (this.scaleX = w, this.scaleY = y, c |= 8, s = a = !0) } let f = (parseInt(i.paddingTop) || 0) * this.scaleY, h = (parseInt(i.paddingBottom) || 0) * this.scaleY; (this.paddingTop != f || this.paddingBottom != h) && (this.paddingTop = f, this.paddingBottom = h, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8); let d = e.scrollDOM.scrollTop * this.scaleY; this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = Q1(e.scrollDOM); let p = (this.printing ? vM : mM)(n, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom; this.pixelViewport = p; let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left; if (v != this.inView && (this.inView = v, v && (a = !0)), !this.inView && !this.scrollTarget) return 0; let b = l.width; if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), a) { let w = e.docView.measureVisibleLineHeights(this.viewport); if (r.mustRefreshForHeights(w) && (s = !0), s || r.lineWrapping && Math.abs(b - this.contentDOMWidth) > r.charWidth) { let { lineHeight: y, charWidth: C, textHeight: O } = e.docView.measureTextSize(); s = y > 0 && r.refresh(o, y, C, O, b / C, w), s && (e.docView.minWidth = 0, c |= 8) } g > 0 && m > 0 ? u = Math.max(g, m) : g < 0 && m < 0 && (u = Math.min(g, m)), _0(); for (let y of this.viewports) { let C = y.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(y); this.heightMap = (s ? Ht.empty().applyChanges(this.stateDeco, Be.empty, this.heightOracle, [new Sn(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, s, new fM(y.from, C)) } jo && (c |= 2) } let x = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to); return x && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || x) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c } get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top) } get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom) } getViewport(e, n) { let i = .5 - Math.max(-.5, Math.min(.5, e / 1e3 / 2)), r = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: l } = this, a = new ga(r.lineAt(s - i * 1e3, Ue.ByHeight, o, 0, 0).from, r.lineAt(l + (1 - i) * 1e3, Ue.ByHeight, o, 0, 0).to); if (n) { let { head: c } = n.range; if (c < a.from || c > a.to) { let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = r.lineAt(c, Ue.ByPos, o, 0, 0), h; n.y == "center" ? h = (f.top + f.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < a.from ? h = f.top : h = f.bottom - u, a = new ga(r.lineAt(h - 1e3 / 2, Ue.ByHeight, o, 0, 0).from, r.lineAt(h + u + 1e3 / 2, Ue.ByHeight, o, 0, 0).to) } } return a } mapViewport(e, n) { let i = n.mapPos(e.from, -1), r = n.mapPos(e.to, 1); return new ga(this.heightMap.lineAt(i, Ue.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, Ue.ByPos, this.heightOracle, 0, 0).to) } viewportIsAppropriate({ from: e, to: n }, i = 0) { if (!this.inView) return !0; let { top: r } = this.heightMap.lineAt(e, Ue.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, Ue.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: l } = this; return (e == 0 || r <= s - Math.max(10, Math.min(-i, 250))) && (n == this.state.doc.length || o >= l + Math.max(10, Math.min(i, 250))) && r > s - 2 * 1e3 && o < l + 2 * 1e3 } mapLineGaps(e, n) { if (!e.length || n.empty) return e; let i = []; for (let r of e) n.touchesRange(r.from, r.to) || i.push(new Rf(n.mapPos(r.from), n.mapPos(r.to), r.size, r.displaySize)); return i } ensureLineGaps(e, n) { let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, o = r >> 1, s = r << 1; if (this.defaultTextDirection != Ge.LTR && !i) return []; let l = [], a = (u, f, h, d) => { if (f - u < o) return; let p = this.state.selection.main, g = [p.from]; p.empty || g.push(p.to); for (let v of g) if (v > u && v < f) { a(u, v - 10, h, d), a(v + 10, f, h, d); return } let m = OM(e, v => v.from >= h.from && v.to <= h.to && Math.abs(v.from - u) < o && Math.abs(v.to - f) < o && !g.some(b => v.from < b && v.to > b)); if (!m) { if (f < h.to && n && i && n.visibleRanges.some(x => x.from <= f && x.to >= f)) { let x = n.moveToLineBoundary(z.cursor(f), !1, !0).head; x > u && (f = x) } let v = this.gapSize(h, u, f, d), b = i || v < 2e6 ? v : 2e6; m = new Rf(u, f, v, b) } l.push(m) }, c = u => { if (u.length < s || u.type != Wt.Text) return; let f = bM(u.from, u.to, this.stateDeco); if (f.total < s) return; let h = this.scrollTarget ? this.scrollTarget.range.head : null, d, p; if (i) { let g = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, v; if (h != null) { let b = va(f, h), x = ((this.visibleBottom - this.visibleTop) / 2 + g) / u.height; m = b - x, v = b + x } else m = (this.visibleTop - u.top - g) / u.height, v = (this.visibleBottom - u.top + g) / u.height; d = ma(f, m), p = ma(f, v) } else { let g = f.total * this.heightOracle.charWidth, m = r * this.heightOracle.charWidth, v = 0; if (g > 2e6) for (let C of e) C.from >= u.from && C.from < u.to && C.size != C.displaySize && C.from * this.heightOracle.charWidth + v < this.pixelViewport.left && (v = C.size - C.displaySize); let b = this.pixelViewport.left + v, x = this.pixelViewport.right + v, w, y; if (h != null) { let C = va(f, h), O = ((x - b) / 2 + m) / g; w = C - O, y = C + O } else w = (b - m) / g, y = (x + m) / g; d = ma(f, w), p = ma(f, y) } d > u.from && a(u.from, d, u, f), p < u.to && a(p, u.to, u, f) }; for (let u of this.viewportLines) Array.isArray(u.type) ? u.type.forEach(c) : c(u); return l } gapSize(e, n, i, r) { let o = va(r, i) - va(r, n); return this.heightOracle.lineWrapping ? e.height * o : r.total * this.heightOracle.charWidth * o } updateLineGaps(e) { Rf.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = de.set(e.map(n => n.draw(this, this.heightOracle.lineWrapping)))) } computeVisibleRanges() { let e = this.stateDeco; this.lineGaps.length && (e = e.concat(this.lineGapDeco)); let n = []; De.spans(e, this.viewport.from, this.viewport.to, { span(r, o) { n.push({ from: r, to: o }) }, point() { } }, 20); let i = n.length != this.visibleRanges.length || this.visibleRanges.some((r, o) => r.from != n[o].from || r.to != n[o].to); return this.visibleRanges = n, i ? 4 : 0 } lineBlockAt(e) { return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find(n => n.from <= e && n.to >= e) || Bs(this.heightMap.lineAt(e, Ue.ByPos, this.heightOracle, 0, 0), this.scaler) } lineBlockAtHeight(e) { return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find(n => n.top <= e && n.bottom >= e) || Bs(this.heightMap.lineAt(this.scaler.fromDOM(e), Ue.ByHeight, this.heightOracle, 0, 0), this.scaler) } scrollAnchorAt(e) { let n = this.lineBlockAtHeight(e + 8); return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0] } elementAtHeight(e) { return Bs(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler) } get docHeight() { return this.scaler.toDOM(this.heightMap.height) } get contentHeight() { return this.docHeight + this.paddingTop + this.paddingBottom } } class ga { constructor(e, n) { this.from = e, this.to = n } } function bM(t, e, n) { let i = [], r = t, o = 0; return De.spans(n, t, e, { span() { }, point(s, l) { s > r && (i.push({ from: r, to: s }), o += s - r), r = l } }, 20), r < e && (i.push({ from: r, to: e }), o += e - r), { total: o, ranges: i } } function ma({ total: t, ranges: e }, n) { if (n <= 0) return e[0].from; if (n >= 1) return e[e.length - 1].to; let i = Math.floor(t * n); for (let r = 0; ; r++) { let { from: o, to: s } = e[r], l = s - o; if (i <= l) return o + i; i -= l } } function va(t, e) { let n = 0; for (let { from: i, to: r } of t.ranges) { if (e <= r) { n += e - i; break } n += r - i } return n / t.total } function OM(t, e) { for (let n of t) if (e(n)) return n } const D0 = { toDOM(t) { return t }, fromDOM(t) { return t }, scale: 1, eq(t) { return t == this } }; class eg { constructor(e, n, i) { let r = 0, o = 0, s = 0; this.viewports = i.map(({ from: l, to: a }) => { let c = n.lineAt(l, Ue.ByPos, e, 0, 0).top, u = n.lineAt(a, Ue.ByPos, e, 0, 0).bottom; return r += u - c, { from: l, to: a, top: c, bottom: u, domTop: 0, domBottom: 0 } }), this.scale = (7e6 - r) / (n.height - r); for (let l of this.viewports) l.domTop = s + (l.top - o) * this.scale, s = l.domBottom = l.domTop + (l.bottom - l.top), o = l.bottom } toDOM(e) { for (let n = 0, i = 0, r = 0; ; n++) { let o = n < this.viewports.length ? this.viewports[n] : null; if (!o || e < o.top) return r + (e - i) * this.scale; if (e <= o.bottom) return o.domTop + (e - o.top); i = o.bottom, r = o.domBottom } } fromDOM(e) { for (let n = 0, i = 0, r = 0; ; n++) { let o = n < this.viewports.length ? this.viewports[n] : null; if (!o || e < o.domTop) return i + (e - r) / this.scale; if (e <= o.domBottom) return o.top + (e - o.domTop); i = o.bottom, r = o.domBottom } } eq(e) { return e instanceof eg ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, i) => n.from == e.viewports[i].from && n.to == e.viewports[i].to) : !1 } } function Bs(t, e) { if (e.scale == 1) return t; let n = e.toDOM(t.top), i = e.toDOM(t.bottom); return new Yn(t.from, t.length, n, i - n, Array.isArray(t._content) ? t._content.map(r => Bs(r, e)) : t._content) } const ya = se.define({ combine: t => t.join(" ") }), Od = se.define({ combine: t => t.indexOf(!0) > -1 }), Sd = cr.newName(), PS = cr.newName(), AS = cr.newName(), MS = { "&light": "." + PS, "&dark": "." + AS }; function xd(t, e, n) { return new cr(e, { finish(i) { return /&/.test(i) ? i.replace(/&\w*/, r => { if (r == "&") return t; if (!n || !n[r]) throw new RangeError(`Unsupported selector: ${r}`); return n[r] }) : t + " " + i } }) } const SM = xd("." + Sd, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0, overflowAnchor: "none" }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0, zIndex: 300 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace": { backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)", backgroundPosition: "center" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, MS), xM = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 }, If = le.ie && le.ie_version <= 11; class wM { constructor(e) { this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new lA, this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver(n => { for (let i of n) this.queue.push(i); (le.ie && le.ie_version <= 11 || le.ios && e.composing) && n.some(i => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush() }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && !(le.chrome && le.chrome_version < 126) && (this.editContext = new TM(e), e.state.facet(Ui) && (e.contentDOM.editContext = this.editContext.editContext)), If && (this.onCharData = n => { this.queue.push({ target: n.target, type: "characterData", oldValue: n.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => { var n; ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize() }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver(n => { this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event"))) }, { threshold: [0, .001] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver(n => { n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event")) }, {})), this.listenForScroll(), this.readSelectionRange() } onScrollChanged(e) { this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure() } onScroll(e) { this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e) } onResize() { this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => { this.resizeTimeout = -1, this.view.requestMeasure() }, 50)) } onPrint(e) { (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => { this.view.viewState.printing = !1, this.view.requestMeasure() }, 500)) } updateGaps(e) { if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, i) => n != e[i]))) { this.gapIntersection.disconnect(); for (let n of e) this.gapIntersection.observe(n); this.gaps = e } } onSelectionChange(e) { let n = this.selectionChanged; if (!this.readSelectionRange() || this.delayedAndroidKey) return; let { view: i } = this, r = this.selectionRange; if (i.state.facet(Ui) ? i.root.activeElement != this.dom : !tc(this.dom, r)) return; let o = r.anchorNode && i.docView.nearest(r.anchorNode); if (o && o.ignoreEvent(e)) { n || (this.selectionChanged = !1); return } (le.ie && le.ie_version <= 11 || le.android && le.chrome) && !i.state.selection.main.empty && r.focusNode && Ys(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1) } readSelectionRange() { let { view: e } = this, n = gl(e.root); if (!n) return !1; let i = le.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && CM(this.view, n) || n; if (!i || this.selectionRange.eq(i)) return !1; let r = tc(this.dom, i); return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && cA(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), r && (this.selectionChanged = !0), !0) } setSelectionRange(e, n) { this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1 } clearSelectionRange() { this.selectionRange.set(null, 0, null, 0) } listenForScroll() { this.parentCheck = -1; let e = 0, n = null; for (let i = this.dom; i;)if (i.nodeType == 1) !n && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(i), i = i.assignedSlot || i.parentNode; else if (i.nodeType == 11) i = i.host; else break; if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) { for (let i of this.scrollTargets) i.removeEventListener("scroll", this.onScroll); for (let i of this.scrollTargets = n) i.addEventListener("scroll", this.onScroll) } } ignore(e) { if (!this.active) return e(); try { return this.stop(), e() } finally { this.start(), this.clear() } } start() { this.active || (this.observer.observe(this.dom, xM), If && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0) } stop() { this.active && (this.active = !1, this.observer.disconnect(), If && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData)) } clear() { this.processRecords(), this.queue.length = 0, this.selectionChanged = !1 } delayAndroidKey(e, n) { var i; if (!this.delayedAndroidKey) { let r = () => { let o = this.delayedAndroidKey; o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Mo(this.dom, o.key, o.keyCode)) }; this.flushingAndroidKey = this.view.win.requestAnimationFrame(r) } (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = { key: e, keyCode: n, force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force) }) } clearDelayedAndroidKey() { this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1 } flushSoon() { this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1, this.flush() })) } forceFlush() { this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush() } pendingRecords() { for (let e of this.observer.takeRecords()) this.queue.push(e); return this.queue } processRecords() { let e = this.pendingRecords(); e.length && (this.queue = []); let n = -1, i = -1, r = !1; for (let o of e) { let s = this.readMutation(o); s && (s.typeOver && (r = !0), n == -1 ? { from: n, to: i } = s : (n = Math.min(s.from, n), i = Math.max(s.to, i))) } return { from: n, to: i, typeOver: r } } readChange() { let { from: e, to: n, typeOver: i } = this.processRecords(), r = this.selectionChanged && tc(this.dom, this.selectionRange); if (e < 0 && !r) return null; e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1; let o = new HA(this.view, e, n, i); return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o } flush(e = !0) { if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1; e && this.readSelectionRange(); let n = this.readChange(); if (!n) return this.view.requestMeasure(), !1; let i = this.view.state, r = yS(this.view, n); return this.view.state == i && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), r } readMutation(e) { let n = this.view.docView.nearest(e.target); if (!n || n.ignoreMutation(e)) return null; if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") { let i = B0(n, e.previousSibling || e.target.previousSibling, -1), r = B0(n, e.nextSibling || e.target.nextSibling, 1); return { from: i ? n.posAfter(i) : n.posAtStart, to: r ? n.posBefore(r) : n.posAtEnd, typeOver: !1 } } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null } setWindow(e) { e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win)) } addWindowListeners(e) { e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange) } removeWindowListeners(e) { e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange) } update(e) { this.editContext && (this.editContext.update(e), e.startState.facet(Ui) != e.state.facet(Ui) && (e.view.contentDOM.editContext = e.state.facet(Ui) ? this.editContext.editContext : null)) } destroy() { var e, n, i; this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect(); for (let r of this.scrollTargets) r.removeEventListener("scroll", this.onScroll); this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy()) } } function B0(t, e, n) { for (; e;) { let i = He.get(e); if (i && i.parent == t) return i; let r = e.parentNode; e = r != t.dom ? r : n > 0 ? e.nextSibling : e.previousSibling } return null } function L0(t, e) { let n = e.startContainer, i = e.startOffset, r = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor); return Ys(s.node, s.offset, r, o) && ([n, i, r, o] = [r, o, n, i]), { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: o } } function CM(t, e) { if (e.getComposedRanges) { let r = e.getComposedRanges(t.root)[0]; if (r) return L0(t, r) } let n = null; function i(r) { r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0] } return t.contentDOM.addEventListener("beforeinput", i, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), n ? L0(t, n) : null } class TM {
        constructor(e) {
            this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = Object.create(null), this.resetRange(e.state); let n = this.editContext = new window.EditContext({ text: e.state.doc.sliceString(this.from, this.to), selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))), selectionEnd: this.toContextPos(e.state.selection.main.head) }); this.handlers.textupdate = i => {
                let { anchor: r } = e.state.selection.main, o = {
                    from: this.toEditorPos(i.updateRangeStart), to: this.toEditorPos(i.updateRangeEnd), insert: Be.of(i.text.split(`
`))
                }; o.from == this.from && r < this.from ? o.from = r : o.to == this.to && r > this.to && (o.to = r), !(o.from == o.to && !o.insert.length) && (this.pendingContextChange = o, e.state.readOnly || Zp(e, o, z.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd))), this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)))
            }, this.handlers.characterboundsupdate = i => { let r = [], o = null; for (let s = this.toEditorPos(i.rangeStart), l = this.toEditorPos(i.rangeEnd); s < l; s++) { let a = e.coordsForChar(s); o = a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) || o || new DOMRect, r.push(o) } n.updateCharacterBounds(i.rangeStart, r) }, this.handlers.textformatupdate = i => { let r = []; for (let o of i.getTextFormats()) { let s = o.underlineStyle, l = o.underlineThickness; if (s != "None" && l != "None") { let a = `text-decoration: underline ${s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`; r.push(de.mark({ attributes: { style: a } }).range(this.toEditorPos(o.rangeStart), this.toEditorPos(o.rangeEnd))) } } e.dispatch({ effects: uS.of(de.set(r)) }) }, this.handlers.compositionstart = () => { e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0) }, this.handlers.compositionend = () => { e.inputState.composing = -1, e.inputState.compositionFirstChange = null }; for (let i in this.handlers) n.addEventListener(i, this.handlers[i]); this.measureReq = { read: i => { this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect()); let r = gl(i.root); r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect()) } }
        } applyEdits(e) { let n = 0, i = !1, r = this.pendingContextChange; return e.changes.iterChanges((o, s, l, a, c) => { if (i) return; let u = c.length - (s - o); if (r && s >= r.to) if (r.from == o && r.to == s && r.insert.eq(c)) { r = this.pendingContextChange = null, n += u, this.to += u; return } else r = null, this.revertPending(e.state); if (o += n, s += n, s <= this.from) this.from += u, this.to += u; else if (o < this.to) { if (o < this.from || s > this.to || this.to - this.from + c.length > 3e4) { i = !0; return } this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), c.toString()), this.to += u } n += u }), r && !i && this.revertPending(e.state), !i } update(e) { let n = this.pendingContextChange; !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.resetRange(e.state), this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)), this.setSelection(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq) } resetRange(e) { let { head: n } = e.selection.main; this.from = Math.max(0, n - 1e4), this.to = Math.min(e.doc.length, n + 1e4) } revertPending(e) { let n = this.pendingContextChange; this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to)) } setSelection(e) { let { main: n } = e.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), r = this.toContextPos(n.head); (this.editContext.selectionStart != i || this.editContext.selectionEnd != r) && this.editContext.updateSelection(i, r) } rangeIsValid(e) { let { head: n } = e.selection.main; return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3) } toEditorPos(e) { return e + this.from } toContextPos(e) { return e - this.from } destroy() { for (let e in this.handlers) this.editContext.removeEventListener(e, this.handlers[e]) }
    } class ie { get state() { return this.viewState.state } get viewport() { return this.viewState.viewport } get visibleRanges() { return this.viewState.visibleRanges } get inView() { return this.viewState.inView } get composing() { return this.inputState.composing > 0 } get compositionStarted() { return this.inputState.composing >= 0 } get root() { return this._root } get win() { return this.dom.ownerDocument.defaultView || window } constructor(e = {}) { var n; this.plugins = [], this.pluginMap = new Map, this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom); let { dispatch: i } = e; this.dispatchTransactions = e.dispatchTransactions || i && (r => r.forEach(o => i(o, this))) || (r => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || aA(e.parent) || document, this.viewState = new I0(e.state || _e.create(e)), e.scrollTo && e.scrollTo.is(ha) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Rs).map(r => new Mf(r)); for (let r of this.plugins) r.update(this); this.observer = new wM(this), this.inputState = new XA(this), this.inputState.ensureHandlers(this.plugins), this.docView = new g0(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure()) } dispatch(...e) { let n = e.length == 1 && e[0] instanceof lt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)]; this.dispatchTransactions(n, this) } update(e) { if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress"); let n = !1, i = !1, r, o = this.state; for (let h of e) { if (h.startState != o) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state."); o = h.state } if (this.destroyed) { this.viewState.state = o; return } let s = this.hasFocus, l = 0, a = null; e.some(h => h.annotation(CS)) ? (this.inputState.notifiedFocused = s, l = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, a = TS(o, s), a || (l = 1)); let c = this.observer.delayedAndroidKey, u = null; if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (u = null)) : this.observer.clear(), o.facet(_e.phrases) != this.state.facet(_e.phrases)) return this.setState(o); r = Ec.create(this, o, e), r.flags |= l; let f = this.viewState.scrollTarget; try { this.updateState = 2; for (let h of e) { if (f && (f = f.map(h.changes)), h.scrollIntoView) { let { main: d } = h.state.selection; f = new Eo(d.empty ? d : z.cursor(d.head, d.head > d.anchor ? -1 : 1)) } for (let d of h.effects) d.is(ha) && (f = d.value.clip(this.state)) } this.viewState.update(r, f), this.bidiCache = Rc.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), n = this.docView.update(r), this.state.facet(Is) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some(h => h.isUserEvent("select.pointer"))) } finally { this.updateState = 0 } if (r.startState.facet(ya) != r.state.facet(ya) && (this.viewState.mustMeasureContent = !0), (n || i || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !r.empty) for (let h of this.state.facet(md)) try { h(r) } catch (d) { Kt(this.state, d, "update listener") } (a || u) && Promise.resolve().then(() => { a && this.state == a.startState && this.dispatch(a), u && !yS(this, u) && c.force && Mo(this.contentDOM, c.key, c.keyCode) }) } setState(e) { if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress"); if (this.destroyed) { this.viewState.state = e; return } this.updateState = 2; let n = this.hasFocus; try { for (let i of this.plugins) i.destroy(this); this.viewState = new I0(e), this.plugins = e.facet(Rs).map(i => new Mf(i)), this.pluginMap.clear(); for (let i of this.plugins) i.update(this); this.docView.destroy(), this.docView = new g0(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [] } finally { this.updateState = 0 } n && this.focus(), this.requestMeasure() } updatePlugins(e) { let n = e.startState.facet(Rs), i = e.state.facet(Rs); if (n != i) { let r = []; for (let o of i) { let s = n.indexOf(o); if (s < 0) r.push(new Mf(o)); else { let l = this.plugins[s]; l.mustUpdate = e, r.push(l) } } for (let o of this.plugins) o.mustUpdate != e && o.destroy(this); this.plugins = r, this.pluginMap.clear() } else for (let r of this.plugins) r.mustUpdate = e; for (let r = 0; r < this.plugins.length; r++)this.plugins[r].update(this); n != i && this.inputState.ensureHandlers(this.plugins) } docViewUpdate() { for (let e of this.plugins) { let n = e.value; if (n && n.docViewUpdate) try { n.docViewUpdate(this) } catch (i) { Kt(this.state, i, "doc view update listener") } } } measure(e = !0) { if (this.destroyed) return; if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) { this.measureScheduled = -1, this.requestMeasure(); return } this.measureScheduled = 0, e && this.observer.forceFlush(); let n = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState; Math.abs(r - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1; try { for (let l = 0; ; l++) { if (s < 0) if (Q1(i)) o = -1, s = this.viewState.heightMap.height; else { let d = this.viewState.scrollAnchorAt(r); o = d.from, s = d.top } this.updateState = 1; let a = this.viewState.measure(this); if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null) break; if (l > 5) { console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize"); break } let c = []; a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]); let u = c.map(d => { try { return d.read(this) } catch (p) { return Kt(this.state, p), Q0 } }), f = Ec.create(this, this.state, []), h = !1; f.flags |= a, n ? n.flags |= a : n = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), h = this.docView.update(f), h && this.docViewUpdate()); for (let d = 0; d < c.length; d++)if (u[d] != Q0) try { let p = c[d]; p.write && p.write(u[d], this) } catch (p) { Kt(this.state, p) } if (h && this.docView.updateSelection(!0), !f.viewportChanged && this.measureRequests.length == 0) { if (this.viewState.editorHeight) if (this.viewState.scrollTarget) { this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1; continue } else { let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s; if (p > 1 || p < -1) { r = r + p, i.scrollTop = r / this.scaleY, s = -1; continue } } break } } } finally { this.updateState = 0, this.measureScheduled = -1 } if (n && !n.empty) for (let l of this.state.facet(md)) l(n) } get themeClasses() { return Sd + " " + (this.state.facet(Od) ? AS : PS) + " " + this.state.facet(ya) } updateAttrs() { let e = N0(this, fS, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), n = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(Ui) ? "true" : "false", class: "cm-content", style: `${le.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" }; this.state.readOnly && (n["aria-readonly"] = "true"), N0(this, Kp, n); let i = this.observer.ignore(() => { let r = ud(this.contentDOM, this.contentAttrs, n), o = ud(this.dom, this.editorAttrs, e); return r || o }); return this.editorAttrs = e, this.contentAttrs = n, i } showAnnouncements(e) { let n = !0; for (let i of e) for (let r of i.effects) if (r.is(ie.announce)) { n && (this.announceDOM.textContent = ""), n = !1; let o = this.announceDOM.appendChild(document.createElement("div")); o.textContent = r.value } } mountStyles() { this.styleModules = this.state.facet(Is); let e = this.state.facet(ie.cspNonce); cr.mount(this.root, this.styleModules.concat(SM).reverse(), e ? { nonce: e } : void 0) } readMeasured() { if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update"); this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1) } requestMeasure(e) { if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) { if (this.measureRequests.indexOf(e) > -1) return; if (e.key != null) { for (let n = 0; n < this.measureRequests.length; n++)if (this.measureRequests[n].key === e.key) { this.measureRequests[n] = e; return } } this.measureRequests.push(e) } } plugin(e) { let n = this.pluginMap.get(e); return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find(i => i.spec == e) || null), n && n.update(this).value } get documentTop() { return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop } get documentPadding() { return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom } } get scaleX() { return this.viewState.scaleX } get scaleY() { return this.viewState.scaleY } elementAtHeight(e) { return this.readMeasured(), this.viewState.elementAtHeight(e) } lineBlockAtHeight(e) { return this.readMeasured(), this.viewState.lineBlockAtHeight(e) } get viewportLineBlocks() { return this.viewState.viewportLines } lineBlockAt(e) { return this.viewState.lineBlockAt(e) } get contentHeight() { return this.viewState.contentHeight } moveByChar(e, n, i) { return _f(this, e, O0(this, e, n, i)) } moveByGroup(e, n) { return _f(this, e, O0(this, e, n, i => QA(this, e.head, i))) } visualLineSide(e, n) { let i = this.bidiSpans(e), r = this.textDirectionAt(e.from), o = i[n ? i.length - 1 : 0]; return z.cursor(o.side(n, r) + e.from, o.forward(!n, r) ? 1 : -1) } moveToLineBoundary(e, n, i = !0) { return LA(this, e, n, i) } moveVertically(e, n, i) { return _f(this, e, NA(this, e, n, i)) } domAtPos(e) { return this.docView.domAtPos(e) } posAtDOM(e, n = 0) { return this.docView.posFromDOM(e, n) } posAtCoords(e, n = !0) { return this.readMeasured(), vS(this, e, n) } coordsAtPos(e, n = 1) { this.readMeasured(); let i = this.docView.coordsAt(e, n); if (!i || i.left == i.right) return i; let r = this.state.doc.lineAt(e), o = this.bidiSpans(r), s = o[Zi.find(o, e - r.from, -1, n)]; return Eu(i, s.dir == Ge.LTR == n > 0) } coordsForChar(e) { return this.readMeasured(), this.docView.coordsForChar(e) } get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth } get defaultLineHeight() { return this.viewState.heightOracle.lineHeight } get textDirection() { return this.viewState.defaultTextDirection } textDirectionAt(e) { return !this.state.facet(lS) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e)) } get lineWrapping() { return this.viewState.heightOracle.lineWrapping } bidiSpans(e) { if (e.length > $M) return J1(e.length); let n = this.textDirectionAt(e.from), i; for (let o of this.bidiCache) if (o.from == e.from && o.dir == n && (o.fresh || Z1(o.isolates, i = p0(this, e)))) return o.order; i || (i = p0(this, e)); let r = SA(e.text, n, i); return this.bidiCache.push(new Rc(e.from, e.to, n, i, !0, r)), r } get hasFocus() { var e; return (this.dom.ownerDocument.hasFocus() || le.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM } focus() { this.observer.ignore(() => { B1(this.contentDOM), this.docView.updateSelection() }) } setRoot(e) { this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles()) } destroy() { this.root.activeElement == this.contentDOM && this.contentDOM.blur(); for (let e of this.plugins) e.destroy(this); this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0 } static scrollIntoView(e, n = {}) { return ha.of(new Eo(typeof e == "number" ? z.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin)) } scrollSnapshot() { let { scrollTop: e, scrollLeft: n } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e); return ha.of(new Eo(z.cursor(i.from), "start", "start", i.top - e, n, !0)) } setTabFocusMode(e) { e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e) } static domEventHandlers(e) { return ct.define(() => ({}), { eventHandlers: e }) } static domEventObservers(e) { return ct.define(() => ({}), { eventObservers: e }) } static theme(e, n) { let i = cr.newName(), r = [ya.of(i), Is.of(xd(`.${i}`, e))]; return n && n.dark && r.push(Od.of(!0)), r } static baseTheme(e) { return yr.lowest(Is.of(xd("." + Sd, e, MS))) } static findFromDOM(e) { var n; let i = e.querySelector(".cm-content"), r = i && He.get(i) || He.get(e); return ((n = r == null ? void 0 : r.rootView) === null || n === void 0 ? void 0 : n.view) || null } } ie.styleModule = Is; ie.inputHandler = oS; ie.clipboardInputFilter = Up; ie.clipboardOutputFilter = Gp; ie.scrollHandler = cS; ie.focusChangeEffect = sS; ie.perLineTextDirection = lS; ie.exceptionSink = rS; ie.updateListener = md; ie.editable = Ui; ie.mouseSelectionStyle = iS; ie.dragMovesSelection = nS; ie.clickAddsSelectionRange = tS; ie.decorations = vl; ie.outerDecorations = hS; ie.atomicRanges = Yp; ie.bidiIsolatedRanges = dS; ie.scrollMargins = pS; ie.darkTheme = Od; ie.cspNonce = se.define({ combine: t => t.length ? t[0] : "" }); ie.contentAttributes = Kp; ie.editorAttributes = fS; ie.lineWrapping = ie.contentAttributes.of({ class: "cm-lineWrapping" }); ie.announce = Ce.define(); const $M = 4096, Q0 = {}; class Rc { constructor(e, n, i, r, o, s) { this.from = e, this.to = n, this.dir = i, this.isolates = r, this.fresh = o, this.order = s } static update(e, n) { if (n.empty && !e.some(o => o.fresh)) return e; let i = [], r = e.length ? e[e.length - 1].dir : Ge.LTR; for (let o = Math.max(0, e.length - 10); o < e.length; o++) { let s = e[o]; s.dir == r && !n.touchesRange(s.from, s.to) && i.push(new Rc(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order)) } return i } } function N0(t, e, n) { for (let i = t.state.facet(e), r = i.length - 1; r >= 0; r--) { let o = i[r], s = typeof o == "function" ? o(t) : o; s && cd(s, n) } return n } const kM = le.mac ? "mac" : le.windows ? "win" : le.linux ? "linux" : "key"; function PM(t, e) { const n = t.split(/-(?!$)/); let i = n[n.length - 1]; i == "Space" && (i = " "); let r, o, s, l; for (let a = 0; a < n.length - 1; ++a) { const c = n[a]; if (/^(cmd|meta|m)$/i.test(c)) l = !0; else if (/^a(lt)?$/i.test(c)) r = !0; else if (/^(c|ctrl|control)$/i.test(c)) o = !0; else if (/^s(hift)?$/i.test(c)) s = !0; else if (/^mod$/i.test(c)) e == "mac" ? l = !0 : o = !0; else throw new Error("Unrecognized modifier name: " + c) } return r && (i = "Alt-" + i), o && (i = "Ctrl-" + i), l && (i = "Meta-" + i), s && (i = "Shift-" + i), i } function ba(t, e, n) { return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t } const AM = yr.default(ie.domEventHandlers({ keydown(t, e) { return _S(ES(e.state), t, e, "editor") } })), Iu = se.define({ enables: AM }), z0 = new WeakMap; function ES(t) { let e = t.facet(Iu), n = z0.get(e); return n || z0.set(e, n = _M(e.reduce((i, r) => i.concat(r), []))), n } function MM(t, e, n) { return _S(ES(t.state), e, t, n) } let Gi = null; const EM = 4e3; function _M(t, e = kM) { let n = Object.create(null), i = Object.create(null), r = (s, l) => { let a = i[s]; if (a == null) i[s] = l; else if (a != l) throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix") }, o = (s, l, a, c, u) => { var f, h; let d = n[s] || (n[s] = Object.create(null)), p = l.split(/ (?!$)/).map(v => PM(v, e)); for (let v = 1; v < p.length; v++) { let b = p.slice(0, v).join(" "); r(b, !0), d[b] || (d[b] = { preventDefault: !0, stopPropagation: !1, run: [x => { let w = Gi = { view: x, prefix: b, scope: s }; return setTimeout(() => { Gi == w && (Gi = null) }, EM), !0 }] }) } let g = p.join(" "); r(g, !1); let m = d[g] || (d[g] = { preventDefault: !1, stopPropagation: !1, run: ((h = (f = d._any) === null || f === void 0 ? void 0 : f.run) === null || h === void 0 ? void 0 : h.slice()) || [] }); a && m.run.push(a), c && (m.preventDefault = !0), u && (m.stopPropagation = !0) }; for (let s of t) { let l = s.scope ? s.scope.split(" ") : ["editor"]; if (s.any) for (let c of l) { let u = n[c] || (n[c] = Object.create(null)); u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] }); let { any: f } = s; for (let h in u) u[h].run.push(d => f(d, wd)) } let a = s[e] || s.key; if (a) for (let c of l) o(c, a, s.run, s.preventDefault, s.stopPropagation), s.shift && o(c, "Shift-" + a, s.shift, s.preventDefault, s.stopPropagation) } return n } let wd = null; function _S(t, e, n, i) { wd = e; let r = iA(e), o = xt(r, 0), s = bn(o) == r.length && r != " ", l = "", a = !1, c = !1, u = !1; Gi && Gi.view == n && Gi.scope == i && (l = Gi.prefix + " ", OS.indexOf(e.keyCode) < 0 && (c = !0, Gi = null)); let f = new Set, h = m => { if (m) { for (let v of m.run) if (!f.has(v) && (f.add(v), v(n))) return m.stopPropagation && (u = !0), !0; m.preventDefault && (m.stopPropagation && (u = !0), c = !0) } return !1 }, d = t[i], p, g; return d && (h(d[l + ba(r, e, !s)]) ? a = !0 : s && (e.altKey || e.metaKey || e.ctrlKey) && !(le.windows && e.ctrlKey && e.altKey) && (p = ur[e.keyCode]) && p != r ? (h(d[l + ba(p, e, !0)]) || e.shiftKey && (g = pl[e.keyCode]) != r && g != p && h(d[l + ba(g, e, !1)])) && (a = !0) : s && e.shiftKey && h(d[l + ba(r, e, !0)]) && (a = !0), !a && h(d._any) && (a = !0)), c && (a = !0), a && u && e.stopPropagation(), wd = null, a } class ql { constructor(e, n, i, r, o) { this.className = e, this.left = n, this.top = i, this.width = r, this.height = o } draw() { let e = document.createElement("div"); return e.className = this.className, this.adjust(e), e } update(e, n) { return n.className != this.className ? !1 : (this.adjust(e), !0) } adjust(e) { e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px" } eq(e) { return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className } static forRange(e, n, i) { if (i.empty) { let r = e.coordsAtPos(i.head, i.assoc || 1); if (!r) return []; let o = RS(e); return [new ql(n, r.left - o.left, r.top - o.top, null, r.bottom - r.top)] } else return RM(e, n, i) } } function RS(t) { let e = t.scrollDOM.getBoundingClientRect(); return { left: (t.textDirection == Ge.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY } } function W0(t, e, n, i) { let r = t.coordsAtPos(e, n * 2); if (!r) return i; let o = t.dom.getBoundingClientRect(), s = (r.top + r.bottom) / 2, l = t.posAtCoords({ x: o.left + 1, y: s }), a = t.posAtCoords({ x: o.right - 1, y: s }); return l == null || a == null ? i : { from: Math.max(i.from, Math.min(l, a)), to: Math.min(i.to, Math.max(l, a)) } } function RM(t, e, n) { if (n.to <= t.viewport.from || n.from >= t.viewport.to) return []; let i = Math.max(n.from, t.viewport.from), r = Math.min(n.to, t.viewport.to), o = t.textDirection == Ge.LTR, s = t.contentDOM, l = s.getBoundingClientRect(), a = RS(t), c = s.querySelector(".cm-line"), u = c && window.getComputedStyle(c), f = l.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), h = l.right - (u ? parseInt(u.paddingRight) : 0), d = yd(t, i), p = yd(t, r), g = d.type == Wt.Text ? d : null, m = p.type == Wt.Text ? p : null; if (g && (t.lineWrapping || d.widgetLineBreaks) && (g = W0(t, i, 1, g)), m && (t.lineWrapping || p.widgetLineBreaks) && (m = W0(t, r, -1, m)), g && m && g.from == m.from && g.to == m.to) return b(x(n.from, n.to, g)); { let y = g ? x(n.from, null, g) : w(d, !1), C = m ? x(null, n.to, m) : w(p, !0), O = []; return (g || d).to < (m || p).from - (g && m ? 1 : 0) || d.widgetLineBreaks > 1 && y.bottom + t.defaultLineHeight / 2 < C.top ? O.push(v(f, y.bottom, h, C.top)) : y.bottom < C.top && t.elementAtHeight((y.bottom + C.top) / 2).type == Wt.Text && (y.bottom = C.top = (y.bottom + C.top) / 2), b(y).concat(O).concat(b(C)) } function v(y, C, O, P) { return new ql(e, y - a.left, C - a.top - .01, O - y, P - C + .01) } function b({ top: y, bottom: C, horizontal: O }) { let P = []; for (let M = 0; M < O.length; M += 2)P.push(v(O[M], y, O[M + 1], C)); return P } function x(y, C, O) { let P = 1e9, M = -1e9, A = []; function B(K, _, j, W, G) { let ae = t.coordsAtPos(K, K == O.to ? -2 : 2), ge = t.coordsAtPos(j, j == O.from ? 2 : -2); !ae || !ge || (P = Math.min(ae.top, ge.top, P), M = Math.max(ae.bottom, ge.bottom, M), G == Ge.LTR ? A.push(o && _ ? f : ae.left, o && W ? h : ge.right) : A.push(!o && W ? f : ge.left, !o && _ ? h : ae.right)) } let R = y ?? O.from, X = C ?? O.to; for (let K of t.visibleRanges) if (K.to > R && K.from < X) for (let _ = Math.max(K.from, R), j = Math.min(K.to, X); ;) { let W = t.state.doc.lineAt(_); for (let G of t.bidiSpans(W)) { let ae = G.from + W.from, ge = G.to + W.from; if (ae >= j) break; ge > _ && B(Math.max(ae, _), y == null && ae <= R, Math.min(ge, j), C == null && ge >= X, G.dir) } if (_ = W.to + 1, _ >= j) break } return A.length == 0 && B(R, y == null, X, C == null, t.textDirection), { top: P, bottom: M, horizontal: A } } function w(y, C) { let O = l.top + (C ? y.top : y.bottom); return { top: O, bottom: O, horizontal: [] } } } function IM(t, e) { return t.constructor == e.constructor && t.eq(e) } class DM { constructor(e, n) { this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e) } update(e) { e.startState.facet(rc) != e.state.facet(rc) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq)) } docViewUpdate(e) { this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq) } setOrder(e) { let n = 0, i = e.facet(rc); for (; n < i.length && i[n] != this.layer;)n++; this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n) } measure() { return this.layer.markers(this.view) } scale() { let { scaleX: e, scaleY: n } = this.view; (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`) } draw(e) { if (e.length != this.drawn.length || e.some((n, i) => !IM(n, this.drawn[i]))) { let n = this.dom.firstChild, i = 0; for (let r of e) r.update && n && r.constructor && this.drawn[i].constructor && r.update(n, this.drawn[i]) ? (n = n.nextSibling, i++) : this.dom.insertBefore(r.draw(), n); for (; n;) { let r = n.nextSibling; n.remove(), n = r } this.drawn = e } } destroy() { this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove() } } const rc = se.define(); function IS(t) { return [ct.define(e => new DM(e, t)), rc.of(t)] } const DS = !le.ios, yl = se.define({ combine(t) { return fi(t, { cursorBlinkRate: 1200, drawRangeCursor: !0 }, { cursorBlinkRate: (e, n) => Math.min(e, n), drawRangeCursor: (e, n) => e || n }) } }); function BM(t = {}) { return [yl.of(t), LM, QM, NM, aS.of(!0)] } function BS(t) { return t.startState.facet(yl) != t.state.facet(yl) } const LM = IS({ above: !0, markers(t) { let { state: e } = t, n = e.facet(yl), i = []; for (let r of e.selection.ranges) { let o = r == e.selection.main; if (r.empty ? !o || DS : n.drawRangeCursor) { let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = r.empty ? r : z.cursor(r.head, r.head > r.anchor ? -1 : 1); for (let a of ql.forRange(t, s, l)) i.push(a) } } return i }, update(t, e) { t.transactions.some(i => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink"); let n = BS(t); return n && H0(t.state, e), t.docChanged || t.selectionSet || n }, mount(t, e) { H0(e.state, t) }, class: "cm-cursorLayer" }); function H0(t, e) { e.style.animationDuration = t.facet(yl).cursorBlinkRate + "ms" } const QM = IS({ above: !1, markers(t) { return t.state.selection.ranges.map(e => e.empty ? [] : ql.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n)) }, update(t, e) { return t.docChanged || t.selectionSet || t.viewportChanged || BS(t) }, class: "cm-selectionLayer" }), Cd = { ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } }, ".cm-content": { "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } } } }; DS && (Cd[".cm-line"].caretColor = Cd[".cm-content"].caretColor = "transparent !important"); const NM = yr.highest(ie.theme(Cd)), LS = Ce.define({ map(t, e) { return t == null ? null : e.mapPos(t) } }), Ls = bt.define({ create() { return null }, update(t, e) { return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, i) => i.is(LS) ? i.value : n, t) } }), zM = ct.fromClass(class { constructor(t) { this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) } } update(t) { var e; let n = t.state.field(Ls); n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Ls) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq)) } readPos() { let { view: t } = this, e = t.state.field(Ls), n = e != null && t.coordsAtPos(e); if (!n) return null; let i = t.scrollDOM.getBoundingClientRect(); return { left: n.left - i.left + t.scrollDOM.scrollLeft * t.scaleX, top: n.top - i.top + t.scrollDOM.scrollTop * t.scaleY, height: n.bottom - n.top } } drawCursor(t) { if (this.cursor) { let { scaleX: e, scaleY: n } = this.view; t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px" } } destroy() { this.cursor && this.cursor.remove() } setDropPos(t) { this.view.state.field(Ls) != t && this.view.dispatch({ effects: LS.of(t) }) } }, { eventObservers: { dragover(t) { this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY })) }, dragleave(t) { (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null) }, dragend() { this.setDropPos(null) }, drop() { this.setDropPos(null) } } }); function WM() { return [Ls, zM] } function F0(t, e, n, i, r) { e.lastIndex = 0; for (let o = t.iterRange(n, i), s = n, l; !o.next().done; s += o.value.length)if (!o.lineBreak) for (; l = e.exec(o.value);)r(s + l.index, l) } function HM(t, e) { let n = t.visibleRanges; if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to) return n; let i = []; for (let { from: r, to: o } of n) r = Math.max(t.state.doc.lineAt(r).from, r - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = o : i.push({ from: r, to: o }); return i } class FM { constructor(e) { const { regexp: n, decoration: i, decorate: r, boundary: o, maxLength: s = 1e3 } = e; if (!n.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set"); if (this.regexp = n, r) this.addMatch = (l, a, c, u) => r(u, c, c + l[0].length, l, a); else if (typeof i == "function") this.addMatch = (l, a, c, u) => { let f = i(l, a, c); f && u(c, c + l[0].length, f) }; else if (i) this.addMatch = (l, a, c, u) => u(c, c + l[0].length, i); else throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator"); this.boundary = o, this.maxLength = s } createDeco(e) { let n = new ar, i = n.add.bind(n); for (let { from: r, to: o } of HM(e, this.maxLength)) F0(e.state.doc, this.regexp, r, o, (s, l) => this.addMatch(l, e, s, i)); return n.finish() } updateDeco(e, n) { let i = 1e9, r = -1; return e.docChanged && e.changes.iterChanges((o, s, l, a) => { a > e.view.viewport.from && l < e.view.viewport.to && (i = Math.min(l, i), r = Math.max(a, r)) }), e.viewportChanged || r - i > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, n.map(e.changes), i, r) : n } updateRange(e, n, i, r) { for (let o of e.visibleRanges) { let s = Math.max(o.from, i), l = Math.min(o.to, r); if (l > s) { let a = e.state.doc.lineAt(s), c = a.to < l ? e.state.doc.lineAt(l) : a, u = Math.max(o.from, a.from), f = Math.min(o.to, c.to); if (this.boundary) { for (; s > a.from; s--)if (this.boundary.test(a.text[s - 1 - a.from])) { u = s; break } for (; l < c.to; l++)if (this.boundary.test(c.text[l - c.from])) { f = l; break } } let h = [], d, p = (g, m, v) => h.push(v.range(g, m)); if (a == c) for (this.regexp.lastIndex = u - a.from; (d = this.regexp.exec(a.text)) && d.index < f - a.from;)this.addMatch(d, e, d.index + a.from, p); else F0(e.state.doc, this.regexp, u, f, (g, m) => this.addMatch(m, e, g, p)); n = n.update({ filterFrom: u, filterTo: f, filter: (g, m) => g < u || m > f, add: h }) } } return n } } const Td = /x/.unicode != null ? "gu" : "g", jM = new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Td), qM = { 0: "null", 7: "bell", 8: "backspace", 10: "newline", 11: "vertical tab", 13: "carriage return", 27: "escape", 8203: "zero width space", 8204: "zero width non-joiner", 8205: "zero width joiner", 8206: "left-to-right mark", 8207: "right-to-left mark", 8232: "line separator", 8237: "left-to-right override", 8238: "right-to-left override", 8294: "left-to-right isolate", 8295: "right-to-left isolate", 8297: "pop directional isolate", 8233: "paragraph separator", 65279: "zero width no-break space", 65532: "object replacement" }; let Df = null; function VM() { var t; if (Df == null && typeof document < "u" && document.body) { let e = document.body.style; Df = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null } return Df || !1 } const oc = se.define({ combine(t) { let e = fi(t, { render: null, specialChars: jM, addSpecialChars: null }); return (e.replaceTabs = !VM()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Td)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Td)), e } }); function XM(t = {}) { return [oc.of(t), UM()] } let j0 = null; function UM() { return j0 || (j0 = ct.fromClass(class { constructor(t) { this.view = t, this.decorations = de.none, this.decorationCache = Object.create(null), this.decorator = this.makeDecorator(t.state.facet(oc)), this.decorations = this.decorator.createDeco(t) } makeDecorator(t) { return new FM({ regexp: t.specialChars, decoration: (e, n, i) => { let { doc: r } = n.state, o = xt(e[0], 0); if (o == 9) { let s = r.lineAt(i), l = n.state.tabSize, a = ss(s.text, l, i - s.from); return de.replace({ widget: new ZM((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX) }) } return this.decorationCache[o] || (this.decorationCache[o] = de.replace({ widget: new YM(t, o) })) }, boundary: t.replaceTabs ? void 0 : /[^]/ }) } update(t) { let e = t.state.facet(oc); t.startState.facet(oc) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations) } }, { decorations: t => t.decorations })) } const GM = "•"; function KM(t) { return t >= 32 ? GM : t == 10 ? "␤" : String.fromCharCode(9216 + t) } class YM extends Ii { constructor(e, n) { super(), this.options = e, this.code = n } eq(e) { return e.code == this.code } toDOM(e) { let n = KM(this.code), i = e.state.phrase("Control character") + " " + (qM[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, i, n); if (r) return r; let o = document.createElement("span"); return o.textContent = n, o.title = i, o.setAttribute("aria-label", i), o.className = "cm-specialChar", o } ignoreEvent() { return !1 } } class ZM extends Ii { constructor(e) { super(), this.width = e } eq(e) { return e.width == this.width } toDOM() { let e = document.createElement("span"); return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e } ignoreEvent() { return !1 } } function JM() { return tE } const eE = de.line({ class: "cm-activeLine" }), tE = ct.fromClass(class { constructor(t) { this.decorations = this.getDeco(t) } update(t) { (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view)) } getDeco(t) { let e = -1, n = []; for (let i of t.state.selection.ranges) { let r = t.lineBlockAt(i.head); r.from > e && (n.push(eE.range(r.from)), e = r.from) } return de.set(n) } }, { decorations: t => t.decorations }), $d = 2e3; function nE(t, e, n) { let i = Math.min(e.line, n.line), r = Math.max(e.line, n.line), o = []; if (e.off > $d || n.off > $d || e.col < 0 || n.col < 0) { let s = Math.min(e.off, n.off), l = Math.max(e.off, n.off); for (let a = i; a <= r; a++) { let c = t.doc.line(a); c.length <= l && o.push(z.range(c.from + s, c.to + l)) } } else { let s = Math.min(e.col, n.col), l = Math.max(e.col, n.col); for (let a = i; a <= r; a++) { let c = t.doc.line(a), u = nd(c.text, s, t.tabSize, !0); if (u < 0) o.push(z.cursor(c.to)); else { let f = nd(c.text, l, t.tabSize); o.push(z.range(c.from + u, c.from + f)) } } } return o } function iE(t, e) { let n = t.coordsAtPos(t.viewport.from); return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1 } function q0(t, e) { let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = t.state.doc.lineAt(n), r = n - i.from, o = r > $d ? -1 : r == i.length ? iE(t, e.clientX) : ss(i.text, t.state.tabSize, n - i.from); return { line: i.number, col: o, off: r } } function rE(t, e) { let n = q0(t, e), i = t.state.selection; return n ? { update(r) { if (r.docChanged) { let o = r.changes.mapPos(r.startState.doc.line(n.line).from), s = r.state.doc.lineAt(o); n = { line: s.number, col: n.col, off: Math.min(n.off, s.length) }, i = i.map(r.changes) } }, get(r, o, s) { let l = q0(t, r); if (!l) return i; let a = nE(t.state, n, l); return a.length ? s ? z.create(a.concat(i.ranges)) : z.create(a) : i } } : null } function oE(t) { let e = (t == null ? void 0 : t.eventFilter) || (n => n.altKey && n.button == 0); return ie.mouseSelectionStyle.of((n, i) => e(i) ? rE(n, i) : null) } const sE = { Alt: [18, t => !!t.altKey], Control: [17, t => !!t.ctrlKey], Shift: [16, t => !!t.shiftKey], Meta: [91, t => !!t.metaKey] }, lE = { style: "cursor: crosshair" }; function aE(t = {}) { let [e, n] = sE[t.key || "Alt"], i = ct.fromClass(class { constructor(r) { this.view = r, this.isDown = !1 } set(r) { this.isDown != r && (this.isDown = r, this.view.update([])) } }, { eventObservers: { keydown(r) { this.set(r.keyCode == e || n(r)) }, keyup(r) { (r.keyCode == e || !n(r)) && this.set(!1) }, mousemove(r) { this.set(n(r)) } } }); return [i, ie.contentAttributes.of(r => { var o; return !((o = r.plugin(i)) === null || o === void 0) && o.isDown ? lE : null })] } const Ss = "-10000px"; class QS { constructor(e, n, i, r) { this.facet = n, this.createTooltipView = i, this.removeTooltipView = r, this.input = e.state.facet(n), this.tooltips = this.input.filter(s => s); let o = null; this.tooltipViews = this.tooltips.map(s => o = i(s, o)) } update(e, n) { var i; let r = e.state.facet(this.facet), o = r.filter(a => a); if (r === this.input) { for (let a of this.tooltipViews) a.update && a.update(e); return !1 } let s = [], l = n ? [] : null; for (let a = 0; a < o.length; a++) { let c = o[a], u = -1; if (c) { for (let f = 0; f < this.tooltips.length; f++) { let h = this.tooltips[f]; h && h.create == c.create && (u = f) } if (u < 0) s[a] = this.createTooltipView(c, a ? s[a - 1] : null), l && (l[a] = !!c.above); else { let f = s[a] = this.tooltipViews[u]; l && (l[a] = n[u]), f.update && f.update(e) } } } for (let a of this.tooltipViews) s.indexOf(a) < 0 && (this.removeTooltipView(a), (i = a.destroy) === null || i === void 0 || i.call(a)); return n && (l.forEach((a, c) => n[c] = a), n.length = l.length), this.input = r, this.tooltips = o, this.tooltipViews = s, !0 } } function cE(t) { let { win: e } = t; return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth } } const Bf = se.define({ combine: t => { var e, n, i; return { position: le.ios ? "absolute" : ((e = t.find(r => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed", parent: ((n = t.find(r => r.parent)) === null || n === void 0 ? void 0 : n.parent) || null, tooltipSpace: ((i = t.find(r => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || cE } } }), V0 = new WeakMap, tg = ct.fromClass(class { constructor(t) { this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1; let e = t.state.facet(Bf); this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new QS(t, ng, (n, i) => this.createTooltip(n, i), n => { this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove() }), this.above = this.manager.tooltips.map(n => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(n => { Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon() }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure() } createContainer() { this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom } observeIntersection() { if (this.intersectionObserver) { this.intersectionObserver.disconnect(); for (let t of this.manager.tooltipViews) this.intersectionObserver.observe(t.dom) } } measureSoon() { this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => { this.measureTimeout = -1, this.maybeMeasure() }, 50)) } update(t) { t.transactions.length && (this.lastTransaction = Date.now()); let e = this.manager.update(t, this.above); e && this.observeIntersection(); let n = e || t.geometryChanged, i = t.state.facet(Bf); if (i.position != this.position && !this.madeAbsolute) { this.position = i.position; for (let r of this.manager.tooltipViews) r.dom.style.position = this.position; n = !0 } if (i.parent != this.parent) { this.parent && this.container.remove(), this.parent = i.parent, this.createContainer(); for (let r of this.manager.tooltipViews) this.container.appendChild(r.dom); n = !0 } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses); n && this.maybeMeasure() } createTooltip(t, e) { let n = t.create(this.view), i = e ? e.dom : null; if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) { let r = document.createElement("div"); r.className = "cm-tooltip-arrow", n.dom.appendChild(r) } return n.dom.style.position = this.position, n.dom.style.top = Ss, n.dom.style.left = "0px", this.container.insertBefore(n.dom, i), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n } destroy() { var t, e, n; this.view.win.removeEventListener("resize", this.measureSoon); for (let i of this.manager.tooltipViews) i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i); this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout) } readMeasure() { let t = this.view.dom.getBoundingClientRect(), e = 1, n = 1, i = !1; if (this.position == "fixed" && this.manager.tooltipViews.length) { let { dom: r } = this.manager.tooltipViews[0]; if (le.gecko) i = r.offsetParent != this.container.ownerDocument.body; else if (r.style.top == Ss && r.style.left == "0px") { let o = r.getBoundingClientRect(); i = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1 } } if (i || this.position == "absolute") if (this.parent) { let r = this.parent.getBoundingClientRect(); r.width && r.height && (e = r.width / this.parent.offsetWidth, n = r.height / this.parent.offsetHeight) } else ({ scaleX: e, scaleY: n } = this.view.viewState); return { editor: t, parent: this.parent ? this.container.getBoundingClientRect() : t, pos: this.manager.tooltips.map((r, o) => { let s = this.manager.tooltipViews[o]; return s.getCoords ? s.getCoords(r.pos) : this.view.coordsAtPos(r.pos) }), size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()), space: this.view.state.facet(Bf).tooltipSpace(this.view), scaleX: e, scaleY: n, makeAbsolute: i } } writeMeasure(t) { var e; if (t.makeAbsolute) { this.madeAbsolute = !0, this.position = "absolute"; for (let l of this.manager.tooltipViews) l.dom.style.position = "absolute" } let { editor: n, space: i, scaleX: r, scaleY: o } = t, s = []; for (let l = 0; l < this.manager.tooltips.length; l++) { let a = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: u } = c, f = t.pos[l], h = t.size[l]; if (!f || f.bottom <= Math.max(n.top, i.top) || f.top >= Math.min(n.bottom, i.bottom) || f.right < Math.max(n.left, i.left) - .1 || f.left > Math.min(n.right, i.right) + .1) { u.style.top = Ss; continue } let d = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, g = h.right - h.left, m = (e = V0.get(c)) !== null && e !== void 0 ? e : h.bottom - h.top, v = c.offset || fE, b = this.view.textDirection == Ge.LTR, x = h.width > i.right - i.left ? b ? i.left : i.right - h.width : b ? Math.max(i.left, Math.min(f.left - (d ? 14 : 0) + v.x, i.right - g)) : Math.min(Math.max(i.left, f.left - g + (d ? 14 : 0) - v.x), i.right - g), w = this.above[l]; !a.strictSide && (w ? f.top - (h.bottom - h.top) - v.y < i.top : f.bottom + (h.bottom - h.top) + v.y > i.bottom) && w == i.bottom - f.bottom > f.top - i.top && (w = this.above[l] = !w); let y = (w ? f.top - i.top : i.bottom - f.bottom) - p; if (y < m && c.resize !== !1) { if (y < this.view.defaultLineHeight) { u.style.top = Ss; continue } V0.set(c, m), u.style.height = (m = y) / o + "px" } else u.style.height && (u.style.height = ""); let C = w ? f.top - m - p - v.y : f.bottom + p + v.y, O = x + g; if (c.overlap !== !0) for (let P of s) P.left < O && P.right > x && P.top < C + m && P.bottom > C && (C = w ? P.top - m - 2 - p : P.bottom + p + 2); if (this.position == "absolute" ? (u.style.top = (C - t.parent.top) / o + "px", u.style.left = (x - t.parent.left) / r + "px") : (u.style.top = C / o + "px", u.style.left = x / r + "px"), d) { let P = f.left + (b ? v.x : -v.x) - (x + 14 - 7); d.style.left = P / r + "px" } c.overlap !== !0 && s.push({ left: x, top: C, right: O, bottom: C + m }), u.classList.toggle("cm-tooltip-above", w), u.classList.toggle("cm-tooltip-below", !w), c.positioned && c.positioned(t.space) } } maybeMeasure() { if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView))) for (let t of this.manager.tooltipViews) t.dom.style.top = Ss } }, { eventObservers: { scroll() { this.maybeMeasure() } } }), uE = ie.baseTheme({ ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" }, "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" }, "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" }, "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" }, ".cm-tooltip-arrow": { height: "7px", width: `${7 * 2}px`, position: "absolute", zIndex: -1, overflow: "hidden", "&:before, &:after": { content: "''", position: "absolute", width: 0, height: 0, borderLeft: "7px solid transparent", borderRight: "7px solid transparent" }, ".cm-tooltip-above &": { bottom: "-7px", "&:before": { borderTop: "7px solid #bbb" }, "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" } }, ".cm-tooltip-below &": { top: "-7px", "&:before": { borderBottom: "7px solid #bbb" }, "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" } } }, "&dark .cm-tooltip .cm-tooltip-arrow": { "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" }, "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" } } }), fE = { x: 0, y: 0 }, ng = se.define({ enables: [tg, uE] }), Ic = se.define({ combine: t => t.reduce((e, n) => e.concat(n), []) }); class Du { static create(e) { return new Du(e) } constructor(e) { this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new QS(e, Ic, (n, i) => this.createHostedView(n, i), n => n.dom.remove()) } createHostedView(e, n) { let i = e.create(this.view); return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i } mount(e) { for (let n of this.manager.tooltipViews) n.mount && n.mount(e); this.mounted = !0 } positioned(e) { for (let n of this.manager.tooltipViews) n.positioned && n.positioned(e) } update(e) { this.manager.update(e) } destroy() { var e; for (let n of this.manager.tooltipViews) (e = n.destroy) === null || e === void 0 || e.call(n) } passProp(e) { let n; for (let i of this.manager.tooltipViews) { let r = i[e]; if (r !== void 0) { if (n === void 0) n = r; else if (n !== r) return } } return n } get offset() { return this.passProp("offset") } get getCoords() { return this.passProp("getCoords") } get overlap() { return this.passProp("overlap") } get resize() { return this.passProp("resize") } } const hE = ng.compute([Ic], t => { let e = t.facet(Ic); return e.length === 0 ? null : { pos: Math.min(...e.map(n => n.pos)), end: Math.max(...e.map(n => { var i; return (i = n.end) !== null && i !== void 0 ? i : n.pos })), create: Du.create, above: e[0].above, arrow: e.some(n => n.arrow) } }); class dE { constructor(e, n, i, r, o) { this.view = e, this.source = n, this.field = i, this.setHover = r, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this)) } update() { this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20)) } get active() { return this.view.state.field(this.field) } checkHover() { if (this.hoverTimeout = -1, this.active.length) return; let e = Date.now() - this.lastMove.time; e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover() } startHover() { clearTimeout(this.restartTimeout); let { view: e, lastMove: n } = this, i = e.docView.nearest(n.target); if (!i) return; let r, o = 1; if (i instanceof Yi) r = i.posAtStart; else { if (r = e.posAtCoords(n), r == null) return; let l = e.coordsAtPos(r); if (!l || n.y < l.top || n.y > l.bottom || n.x < l.left - e.defaultCharacterWidth || n.x > l.right + e.defaultCharacterWidth) return; let a = e.bidiSpans(e.state.doc.lineAt(r)).find(u => u.from <= r && u.to >= r), c = a && a.dir == Ge.RTL ? -1 : 1; o = n.x < l.left ? -c : c } let s = this.source(e, r, o); if (s != null && s.then) { let l = this.pending = { pos: r }; s.then(a => { this.pending == l && (this.pending = null, a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) })) }, a => Kt(e.state, a, "hover tooltip")) } else s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) }) } get tooltip() { let e = this.view.plugin(tg), n = e ? e.manager.tooltips.findIndex(i => i.create == Du.create) : -1; return n > -1 ? e.manager.tooltipViews[n] : null } mousemove(e) { var n, i; this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime)); let { active: r, tooltip: o } = this; if (r.length && o && !pE(o.dom, e) || this.pending) { let { pos: s } = r[0] || this.pending, l = (i = (n = r[0]) === null || n === void 0 ? void 0 : n.end) !== null && i !== void 0 ? i : s; (s == l ? this.view.posAtCoords(this.lastMove) != s : !gE(this.view, s, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null) } } mouseleave(e) { clearTimeout(this.hoverTimeout), this.hoverTimeout = -1; let { active: n } = this; if (n.length) { let { tooltip: i } = this; i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) }) } } watchTooltipLeave(e) { let n = i => { e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) }) }; e.addEventListener("mouseleave", n) } destroy() { clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove) } } const Oa = 4; function pE(t, e) { let { left: n, right: i, top: r, bottom: o } = t.getBoundingClientRect(), s; if (s = t.querySelector(".cm-tooltip-arrow")) { let l = s.getBoundingClientRect(); r = Math.min(l.top, r), o = Math.max(l.bottom, o) } return e.clientX >= n - Oa && e.clientX <= i + Oa && e.clientY >= r - Oa && e.clientY <= o + Oa } function gE(t, e, n, i, r, o) { let s = t.scrollDOM.getBoundingClientRect(), l = t.documentTop + t.documentPadding.top + t.contentHeight; if (s.left > i || s.right < i || s.top > r || Math.min(s.bottom, l) < r) return !1; let a = t.posAtCoords({ x: i, y: r }, !1); return a >= e && a <= n } function mE(t, e = {}) { let n = Ce.define(), i = bt.define({ create() { return [] }, update(r, o) { if (r.length && (e.hideOnChange && (o.docChanged || o.selection) ? r = [] : e.hideOn && (r = r.filter(s => !e.hideOn(o, s))), o.docChanged)) { let s = []; for (let l of r) { let a = o.changes.mapPos(l.pos, -1, Tt.TrackDel); if (a != null) { let c = Object.assign(Object.create(null), l); c.pos = a, c.end != null && (c.end = o.changes.mapPos(c.end)), s.push(c) } } r = s } for (let s of o.effects) s.is(n) && (r = s.value), s.is(vE) && (r = []); return r }, provide: r => Ic.from(r) }); return { active: i, extension: [i, ct.define(r => new dE(r, t, i, n, e.hoverTime || 300)), hE] } } function NS(t, e) { let n = t.plugin(tg); if (!n) return null; let i = n.manager.tooltips.indexOf(e); return i < 0 ? null : n.manager.tooltipViews[i] } const vE = Ce.define(), X0 = se.define({ combine(t) { let e, n; for (let i of t) e = e || i.topContainer, n = n || i.bottomContainer; return { topContainer: e, bottomContainer: n } } }); function bl(t, e) { let n = t.plugin(zS), i = n ? n.specs.indexOf(e) : -1; return i > -1 ? n.panels[i] : null } const zS = ct.fromClass(class { constructor(t) { this.input = t.state.facet(Ol), this.specs = this.input.filter(n => n), this.panels = this.specs.map(n => n(t)); let e = t.state.facet(X0); this.top = new Sa(t, !0, e.topContainer), this.bottom = new Sa(t, !1, e.bottomContainer), this.top.sync(this.panels.filter(n => n.top)), this.bottom.sync(this.panels.filter(n => !n.top)); for (let n of this.panels) n.dom.classList.add("cm-panel"), n.mount && n.mount() } update(t) { let e = t.state.facet(X0); this.top.container != e.topContainer && (this.top.sync([]), this.top = new Sa(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Sa(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses(); let n = t.state.facet(Ol); if (n != this.input) { let i = n.filter(a => a), r = [], o = [], s = [], l = []; for (let a of i) { let c = this.specs.indexOf(a), u; c < 0 ? (u = a(t.view), l.push(u)) : (u = this.panels[c], u.update && u.update(t)), r.push(u), (u.top ? o : s).push(u) } this.specs = i, this.panels = r, this.top.sync(o), this.bottom.sync(s); for (let a of l) a.dom.classList.add("cm-panel"), a.mount && a.mount() } else for (let i of this.panels) i.update && i.update(t) } destroy() { this.top.sync([]), this.bottom.sync([]) } }, { provide: t => ie.scrollMargins.of(e => { let n = e.plugin(t); return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() } }) }); class Sa { constructor(e, n, i) { this.view = e, this.top = n, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses() } sync(e) { for (let n of this.panels) n.destroy && e.indexOf(n) < 0 && n.destroy(); this.panels = e, this.syncDOM() } syncDOM() { if (this.panels.length == 0) { this.dom && (this.dom.remove(), this.dom = void 0); return } if (!this.dom) { this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0"; let n = this.container || this.view.dom; n.insertBefore(this.dom, this.top ? n.firstChild : null) } let e = this.dom.firstChild; for (let n of this.panels) if (n.dom.parentNode == this.dom) { for (; e != n.dom;)e = U0(e); e = e.nextSibling } else this.dom.insertBefore(n.dom, e); for (; e;)e = U0(e) } scrollMargin() { return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top) } syncClasses() { if (!(!this.container || this.classes == this.view.themeClasses)) { for (let e of this.classes.split(" ")) e && this.container.classList.remove(e); for (let e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e) } } } function U0(t) { let e = t.nextSibling; return t.remove(), e } const Ol = se.define({ enables: zS }); class Mi extends jr { compare(e) { return this == e || this.constructor == e.constructor && this.eq(e) } eq(e) { return !1 } destroy(e) { } } Mi.prototype.elementClass = ""; Mi.prototype.toDOM = void 0; Mi.prototype.mapMode = Tt.TrackBefore; Mi.prototype.startSide = Mi.prototype.endSide = -1; Mi.prototype.point = !0; const sc = se.define(), yE = se.define(), bE = { class: "", renderEmptyElements: !1, elementStyle: "", markers: () => De.empty, lineMarker: () => null, widgetMarker: () => null, lineMarkerChange: null, initialSpacer: null, updateSpacer: null, domEventHandlers: {} }, Js = se.define(); function OE(t) { return [WS(), Js.of(Object.assign(Object.assign({}, bE), t))] } const kd = se.define({ combine: t => t.some(e => e) }); function WS(t) { let e = [SE]; return t && t.fixed === !1 && e.push(kd.of(!0)), e } const SE = ct.fromClass(class { constructor(t) { this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Js).map(e => new K0(t, e)); for (let e of this.gutters) this.dom.appendChild(e.dom); this.fixed = !t.state.facet(kd), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM) } update(t) { if (this.updateGutters(t)) { let e = this.prevViewport, n = t.view.viewport, i = Math.min(e.to, n.to) - Math.max(e.from, n.from); this.syncGutters(i < (n.to - n.from) * .8) } t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(kd) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport } syncGutters(t) { let e = this.dom.nextSibling; t && this.dom.remove(); let n = De.iter(this.view.state.facet(sc), this.view.viewport.from), i = [], r = this.gutters.map(o => new xE(o, this.view.viewport, -this.view.documentPadding.top)); for (let o of this.view.viewportLineBlocks) if (i.length && (i = []), Array.isArray(o.type)) { let s = !0; for (let l of o.type) if (l.type == Wt.Text && s) { Pd(n, i, l.from); for (let a of r) a.line(this.view, l, i); s = !1 } else if (l.widget) for (let a of r) a.widget(this.view, l) } else if (o.type == Wt.Text) { Pd(n, i, o.from); for (let s of r) s.line(this.view, o, i) } else if (o.widget) for (let s of r) s.widget(this.view, o); for (let o of r) o.finish(); t && this.view.scrollDOM.insertBefore(this.dom, e) } updateGutters(t) { let e = t.startState.facet(Js), n = t.state.facet(Js), i = t.docChanged || t.heightChanged || t.viewportChanged || !De.eq(t.startState.facet(sc), t.state.facet(sc), t.view.viewport.from, t.view.viewport.to); if (e == n) for (let r of this.gutters) r.update(t) && (i = !0); else { i = !0; let r = []; for (let o of n) { let s = e.indexOf(o); s < 0 ? r.push(new K0(this.view, o)) : (this.gutters[s].update(t), r.push(this.gutters[s])) } for (let o of this.gutters) o.dom.remove(), r.indexOf(o) < 0 && o.destroy(); for (let o of r) this.dom.appendChild(o.dom); this.gutters = r } return i } destroy() { for (let t of this.gutters) t.destroy(); this.dom.remove() } }, { provide: t => ie.scrollMargins.of(e => { let n = e.plugin(t); return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == Ge.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX } }) }); function G0(t) { return Array.isArray(t) ? t : [t] } function Pd(t, e, n) { for (; t.value && t.from <= n;)t.from == n && e.push(t.value), t.next() } class xE { constructor(e, n, i) { this.gutter = e, this.height = i, this.i = 0, this.cursor = De.iter(e.markers, n.from) } addElement(e, n, i) { let { gutter: r } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY; if (this.i == r.elements.length) { let l = new HS(e, s, o, i); r.elements.push(l), r.dom.appendChild(l.dom) } else r.elements[this.i].update(e, s, o, i); this.height = n.bottom, this.i++ } line(e, n, i) { let r = []; Pd(this.cursor, r, n.from), i.length && (r = r.concat(i)); let o = this.gutter.config.lineMarker(e, n, r); o && r.unshift(o); let s = this.gutter; r.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, r) } widget(e, n) { let i = this.gutter.config.widgetMarker(e, n.widget, n), r = i ? [i] : null; for (let o of e.state.facet(yE)) { let s = o(e, n.widget, n); s && (r || (r = [])).push(s) } r && this.addElement(e, n, r) } finish() { let e = this.gutter; for (; e.elements.length > this.i;) { let n = e.elements.pop(); e.dom.removeChild(n.dom), n.destroy() } } } class K0 { constructor(e, n) { this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""); for (let i in n.domEventHandlers) this.dom.addEventListener(i, r => { let o = r.target, s; if (o != this.dom && this.dom.contains(o)) { for (; o.parentNode != this.dom;)o = o.parentNode; let a = o.getBoundingClientRect(); s = (a.top + a.bottom) / 2 } else s = r.clientY; let l = e.lineBlockAtHeight(s - e.documentTop); n.domEventHandlers[i](e, l, r) && r.preventDefault() }); this.markers = G0(n.markers(e)), n.initialSpacer && (this.spacer = new HS(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none") } update(e) { let n = this.markers; if (this.markers = G0(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) { let r = this.config.updateSpacer(this.spacer.markers[0], e); r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]) } let i = e.view.viewport; return !De.eq(this.markers, n, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1) } destroy() { for (let e of this.elements) e.destroy() } } class HS { constructor(e, n, i, r) { this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, i, r) } update(e, n, i, r) { this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), wE(this.markers, r) || this.setMarkers(e, r) } setMarkers(e, n) { let i = "cm-gutterElement", r = this.dom.firstChild; for (let o = 0, s = 0; ;) { let l = s, a = o < n.length ? n[o++] : null, c = !1; if (a) { let u = a.elementClass; u && (i += " " + u); for (let f = s; f < this.markers.length; f++)if (this.markers[f].compare(a)) { l = f, c = !0; break } } else l = this.markers.length; for (; s < l;) { let u = this.markers[s++]; if (u.toDOM) { u.destroy(r); let f = r.nextSibling; r.remove(), r = f } } if (!a) break; a.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(a.toDOM(e), r)), c && s++ } this.dom.className = i, this.markers = n } destroy() { this.setMarkers(null, []) } } function wE(t, e) { if (t.length != e.length) return !1; for (let n = 0; n < t.length; n++)if (!t[n].compare(e[n])) return !1; return !0 } const CE = se.define(), TE = se.define(), yo = se.define({ combine(t) { return fi(t, { formatNumber: String, domEventHandlers: {} }, { domEventHandlers(e, n) { let i = Object.assign({}, e); for (let r in n) { let o = i[r], s = n[r]; i[r] = o ? (l, a, c) => o(l, a, c) || s(l, a, c) : s } return i } }) } }); class Lf extends Mi { constructor(e) { super(), this.number = e } eq(e) { return this.number == e.number } toDOM() { return document.createTextNode(this.number) } } function Qf(t, e) { return t.state.facet(yo).formatNumber(e, t.state) } const $E = Js.compute([yo], t => ({ class: "cm-lineNumbers", renderEmptyElements: !1, markers(e) { return e.state.facet(CE) }, lineMarker(e, n, i) { return i.some(r => r.toDOM) ? null : new Lf(Qf(e, e.state.doc.lineAt(n.from).number)) }, widgetMarker: (e, n, i) => { for (let r of e.state.facet(TE)) { let o = r(e, n, i); if (o) return o } return null }, lineMarkerChange: e => e.startState.facet(yo) != e.state.facet(yo), initialSpacer(e) { return new Lf(Qf(e, Y0(e.state.doc.lines))) }, updateSpacer(e, n) { let i = Qf(n.view, Y0(n.view.state.doc.lines)); return i == e.number ? e : new Lf(i) }, domEventHandlers: t.facet(yo).domEventHandlers })); function FS(t = {}) { return [yo.of(t), WS(), $E] } function Y0(t) { let e = 9; for (; e < t;)e = e * 10 + 9; return e } const kE = new class extends Mi { constructor() { super(...arguments), this.elementClass = "cm-activeLineGutter" } }, PE = sc.compute(["selection"], t => { let e = [], n = -1; for (let i of t.selection.ranges) { let r = t.doc.lineAt(i.head).from; r > n && (n = r, e.push(kE.range(r))) } return De.of(e) }); function AE() { return PE } const jS = 1024; let ME = 0; class Nf { constructor(e, n) { this.from = e, this.to = n } } class $e { constructor(e = {}) { this.id = ME++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => { throw new Error("This node type doesn't define a deserialize function") }) } add(e) { if (this.perNode) throw new RangeError("Can't add per-node props to node types"); return typeof e != "function" && (e = Jt.match(e)), n => { let i = e(n); return i === void 0 ? null : [this, i] } } } $e.closedBy = new $e({ deserialize: t => t.split(" ") }); $e.openedBy = new $e({ deserialize: t => t.split(" ") }); $e.group = new $e({ deserialize: t => t.split(" ") }); $e.isolate = new $e({ deserialize: t => { if (t && t != "rtl" && t != "ltr" && t != "auto") throw new RangeError("Invalid value for isolate: " + t); return t || "auto" } }); $e.contextHash = new $e({ perNode: !0 }); $e.lookAhead = new $e({ perNode: !0 }); $e.mounted = new $e({ perNode: !0 }); class Dc { constructor(e, n, i) { this.tree = e, this.overlay = n, this.parser = i } static get(e) { return e && e.props && e.props[$e.mounted.id] } } const EE = Object.create(null); class Jt { constructor(e, n, i, r = 0) { this.name = e, this.props = n, this.id = i, this.flags = r } static define(e) { let n = e.props && e.props.length ? Object.create(null) : EE, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new Jt(e.name || "", n, e.id, i); if (e.props) { for (let o of e.props) if (Array.isArray(o) || (o = o(r)), o) { if (o[0].perNode) throw new RangeError("Can't store a per-node prop on a node type"); n[o[0].id] = o[1] } } return r } prop(e) { return this.props[e.id] } get isTop() { return (this.flags & 1) > 0 } get isSkipped() { return (this.flags & 2) > 0 } get isError() { return (this.flags & 4) > 0 } get isAnonymous() { return (this.flags & 8) > 0 } is(e) { if (typeof e == "string") { if (this.name == e) return !0; let n = this.prop($e.group); return n ? n.indexOf(e) > -1 : !1 } return this.id == e } static match(e) { let n = Object.create(null); for (let i in e) for (let r of i.split(" ")) n[r] = e[i]; return i => { for (let r = i.prop($e.group), o = -1; o < (r ? r.length : 0); o++) { let s = n[o < 0 ? i.name : r[o]]; if (s) return s } } } } Jt.none = new Jt("", Object.create(null), 0, 8); class ig { constructor(e) { this.types = e; for (let n = 0; n < e.length; n++)if (e[n].id != n) throw new RangeError("Node type ids should correspond to array positions when creating a node set") } extend(...e) { let n = []; for (let i of this.types) { let r = null; for (let o of e) { let s = o(i); s && (r || (r = Object.assign({}, i.props)), r[s[0].id] = s[1]) } n.push(r ? new Jt(i.name, r, i.id, i.flags) : i) } return new ig(n) } } const xa = new WeakMap, Z0 = new WeakMap; var ft; (function (t) { t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays" })(ft || (ft = {})); class at { constructor(e, n, i, r, o) { if (this.type = e, this.children = n, this.positions = i, this.length = r, this.props = null, o && o.length) { this.props = Object.create(null); for (let [s, l] of o) this.props[typeof s == "number" ? s : s.id] = l } } toString() { let e = Dc.get(this); if (e && !e.overlay) return e.tree.toString(); let n = ""; for (let i of this.children) { let r = i.toString(); r && (n && (n += ","), n += r) } return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n } cursor(e = 0) { return new Md(this.topNode, e) } cursorAt(e, n = 0, i = 0) { let r = xa.get(this) || this.topNode, o = new Md(r); return o.moveTo(e, n), xa.set(this, o._tree), o } get topNode() { return new Zt(this, 0, 0, null) } resolve(e, n = 0) { let i = Sl(xa.get(this) || this.topNode, e, n, !1); return xa.set(this, i), i } resolveInner(e, n = 0) { let i = Sl(Z0.get(this) || this.topNode, e, n, !0); return Z0.set(this, i), i } resolveStack(e, n = 0) { return IE(this, e, n) } iterate(e) { let { enter: n, leave: i, from: r = 0, to: o = this.length } = e, s = e.mode || 0, l = (s & ft.IncludeAnonymous) > 0; for (let a = this.cursor(s | ft.IncludeAnonymous); ;) { let c = !1; if (a.from <= o && a.to >= r && (!l && a.type.isAnonymous || n(a) !== !1)) { if (a.firstChild()) continue; c = !0 } for (; c && i && (l || !a.type.isAnonymous) && i(a), !a.nextSibling();) { if (!a.parent()) return; c = !0 } } } prop(e) { return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e) } get propValues() { let e = []; if (this.props) for (let n in this.props) e.push([+n, this.props[n]]); return e } balance(e = {}) { return this.children.length <= 8 ? this : sg(Jt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, i, r) => new at(this.type, n, i, r, this.propValues), e.makeTree || ((n, i, r) => new at(Jt.none, n, i, r))) } static build(e) { return DE(e) } } at.empty = new at(Jt.none, [], [], 0); class rg { constructor(e, n) { this.buffer = e, this.index = n } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } get pos() { return this.index } next() { this.index -= 4 } fork() { return new rg(this.buffer, this.index) } } class hr { constructor(e, n, i) { this.buffer = e, this.length = n, this.set = i } get type() { return Jt.none } toString() { let e = []; for (let n = 0; n < this.buffer.length;)e.push(this.childString(n)), n = this.buffer[n + 3]; return e.join(",") } childString(e) { let n = this.buffer[e], i = this.buffer[e + 3], r = this.set.types[n], o = r.name; if (/\W/.test(o) && !r.isError && (o = JSON.stringify(o)), e += 4, i == e) return o; let s = []; for (; e < i;)s.push(this.childString(e)), e = this.buffer[e + 3]; return o + "(" + s.join(",") + ")" } findChild(e, n, i, r, o) { let { buffer: s } = this, l = -1; for (let a = e; a != n && !(qS(o, r, s[a + 1], s[a + 2]) && (l = a, i > 0)); a = s[a + 3]); return l } slice(e, n, i) { let r = this.buffer, o = new Uint16Array(n - e), s = 0; for (let l = e, a = 0; l < n;) { o[a++] = r[l++], o[a++] = r[l++] - i; let c = o[a++] = r[l++] - i; o[a++] = r[l++] - e, s = Math.max(s, c) } return new hr(o, s, this.set) } } function qS(t, e, n, i) { switch (t) { case -2: return n < e; case -1: return i >= e && n < e; case 0: return n < e && i > e; case 1: return n <= e && i > e; case 2: return i > e; case 4: return !0 } } function Sl(t, e, n, i) { for (var r; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e);) { let s = !i && t instanceof Zt && t.index < 0 ? null : t.parent; if (!s) return t; t = s } let o = i ? 0 : ft.IgnoreOverlays; if (i) for (let s = t, l = s.parent; l; s = l, l = s.parent)s instanceof Zt && s.index < 0 && ((r = l.enter(e, n, o)) === null || r === void 0 ? void 0 : r.from) != s.from && (t = l); for (; ;) { let s = t.enter(e, n, o); if (!s) return t; t = s } } class VS { cursor(e = 0) { return new Md(this, e) } getChild(e, n = null, i = null) { let r = J0(this, e, n, i); return r.length ? r[0] : null } getChildren(e, n = null, i = null) { return J0(this, e, n, i) } resolve(e, n = 0) { return Sl(this, e, n, !1) } resolveInner(e, n = 0) { return Sl(this, e, n, !0) } matchContext(e) { return Ad(this.parent, e) } enterUnfinishedNodesBefore(e) { let n = this.childBefore(e), i = this; for (; n;) { let r = n.lastChild; if (!r || r.to != n.to) break; r.type.isError && r.from == r.to ? (i = n, n = r.prevSibling) : n = r } return i } get node() { return this } get next() { return this.parent } } class Zt extends VS { constructor(e, n, i, r) { super(), this._tree = e, this.from = n, this.index = i, this._parent = r } get type() { return this._tree.type } get name() { return this._tree.type.name } get to() { return this.from + this._tree.length } nextChild(e, n, i, r, o = 0) { for (let s = this; ;) { for (let { children: l, positions: a } = s._tree, c = n > 0 ? l.length : -1; e != c; e += n) { let u = l[e], f = a[e] + s.from; if (qS(r, i, f, f + u.length)) { if (u instanceof hr) { if (o & ft.ExcludeBuffers) continue; let h = u.findChild(0, u.buffer.length, n, i - f, r); if (h > -1) return new Zn(new _E(s, u, e, f), null, h) } else if (o & ft.IncludeAnonymous || !u.type.isAnonymous || og(u)) { let h; if (!(o & ft.IgnoreMounts) && (h = Dc.get(u)) && !h.overlay) return new Zt(h.tree, f, e, s); let d = new Zt(u, f, e, s); return o & ft.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(n < 0 ? u.children.length - 1 : 0, n, i, r) } } } if (o & ft.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s)) return null } } get firstChild() { return this.nextChild(0, 1, 0, 4) } get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4) } childAfter(e) { return this.nextChild(0, 1, e, 2) } childBefore(e) { return this.nextChild(this._tree.children.length - 1, -1, e, -2) } enter(e, n, i = 0) { let r; if (!(i & ft.IgnoreOverlays) && (r = Dc.get(this._tree)) && r.overlay) { let o = e - this.from; for (let { from: s, to: l } of r.overlay) if ((n > 0 ? s <= o : s < o) && (n < 0 ? l >= o : l > o)) return new Zt(r.tree, r.overlay[0].from + this.from, -1, this) } return this.nextChild(0, 1, e, n, i) } nextSignificantParent() { let e = this; for (; e.type.isAnonymous && e._parent;)e = e._parent; return e } get parent() { return this._parent ? this._parent.nextSignificantParent() : null } get nextSibling() { return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null } get prevSibling() { return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null } get tree() { return this._tree } toTree() { return this._tree } toString() { return this._tree.toString() } } function J0(t, e, n, i) { let r = t.cursor(), o = []; if (!r.firstChild()) return o; if (n != null) { for (let s = !1; !s;)if (s = r.type.is(n), !r.nextSibling()) return o } for (; ;) { if (i != null && r.type.is(i)) return o; if (r.type.is(e) && o.push(r.node), !r.nextSibling()) return i == null ? o : [] } } function Ad(t, e, n = e.length - 1) { for (let i = t; n >= 0; i = i.parent) { if (!i) return !1; if (!i.type.isAnonymous) { if (e[n] && e[n] != i.name) return !1; n-- } } return !0 } class _E { constructor(e, n, i, r) { this.parent = e, this.buffer = n, this.index = i, this.start = r } } class Zn extends VS { get name() { return this.type.name } get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] } get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] } constructor(e, n, i) { super(), this.context = e, this._parent = n, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]] } child(e, n, i) { let { buffer: r } = this.context, o = r.findChild(this.index + 4, r.buffer[this.index + 3], e, n - this.context.start, i); return o < 0 ? null : new Zn(this.context, this, o) } get firstChild() { return this.child(1, 0, 4) } get lastChild() { return this.child(-1, 0, 4) } childAfter(e) { return this.child(1, e, 2) } childBefore(e) { return this.child(-1, e, -2) } enter(e, n, i = 0) { if (i & ft.ExcludeBuffers) return null; let { buffer: r } = this.context, o = r.findChild(this.index + 4, r.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n); return o < 0 ? null : new Zn(this.context, this, o) } get parent() { return this._parent || this.context.parent.nextSignificantParent() } externalSibling(e) { return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4) } get nextSibling() { let { buffer: e } = this.context, n = e.buffer[this.index + 3]; return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Zn(this.context, this._parent, n) : this.externalSibling(1) } get prevSibling() { let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0; return this.index == n ? this.externalSibling(-1) : new Zn(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4)) } get tree() { return null } toTree() { let e = [], n = [], { buffer: i } = this.context, r = this.index + 4, o = i.buffer[this.index + 3]; if (o > r) { let s = i.buffer[this.index + 1]; e.push(i.slice(r, o, s)), n.push(0) } return new at(this.type, e, n, this.to - this.from) } toString() { return this.context.buffer.childString(this.index) } } function XS(t) { if (!t.length) return null; let e = 0, n = t[0]; for (let o = 1; o < t.length; o++) { let s = t[o]; (s.from > n.from || s.to < n.to) && (n = s, e = o) } let i = n instanceof Zt && n.index < 0 ? null : n.parent, r = t.slice(); return i ? r[e] = i : r.splice(e, 1), new RE(r, n) } class RE { constructor(e, n) { this.heads = e, this.node = n } get next() { return XS(this.heads) } } function IE(t, e, n) { let i = t.resolveInner(e, n), r = null; for (let o = i instanceof Zt ? i : i.context.parent; o; o = o.parent)if (o.index < 0) { let s = o.parent; (r || (r = [i])).push(s.resolve(e, n)), o = s } else { let s = Dc.get(o.tree); if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) { let l = new Zt(s.tree, s.overlay[0].from + o.from, -1, o); (r || (r = [i])).push(Sl(l, e, n, !1)) } } return r ? XS(r) : i } class Md { get name() { return this.type.name } constructor(e, n = 0) { if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Zt) this.yieldNode(e); else { this._tree = e.context.parent, this.buffer = e.context; for (let i = e._parent; i; i = i._parent)this.stack.unshift(i.index); this.bufferNode = e, this.yieldBuf(e.index) } } yieldNode(e) { return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1 } yieldBuf(e, n) { this.index = e; let { start: i, buffer: r } = this.buffer; return this.type = n || r.set.types[r.buffer[e]], this.from = i + r.buffer[e + 1], this.to = i + r.buffer[e + 2], !0 } yield(e) { return e ? e instanceof Zt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1 } toString() { return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString() } enterChild(e, n, i) { if (!this.buffer) return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, i, this.mode)); let { buffer: r } = this.buffer, o = r.findChild(this.index + 4, r.buffer[this.index + 3], e, n - this.buffer.start, i); return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o)) } firstChild() { return this.enterChild(1, 0, 4) } lastChild() { return this.enterChild(-1, 0, 4) } childAfter(e) { return this.enterChild(1, e, 2) } childBefore(e) { return this.enterChild(-1, e, -2) } enter(e, n, i = this.mode) { return this.buffer ? i & ft.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, i)) } parent() { if (!this.buffer) return this.yieldNode(this.mode & ft.IncludeAnonymous ? this._tree._parent : this._tree.parent); if (this.stack.length) return this.yieldBuf(this.stack.pop()); let e = this.mode & ft.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent(); return this.buffer = null, this.yieldNode(e) } sibling(e) { if (!this.buffer) return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1; let { buffer: n } = this.buffer, i = this.stack.length - 1; if (e < 0) { let r = i < 0 ? 0 : this.stack[i] + 4; if (this.index != r) return this.yieldBuf(n.findChild(r, this.index, -1, 0, 4)) } else { let r = n.buffer[this.index + 3]; if (r < (i < 0 ? n.buffer.length : n.buffer[this.stack[i] + 3])) return this.yieldBuf(r) } return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1 } nextSibling() { return this.sibling(1) } prevSibling() { return this.sibling(-1) } atLastNode(e) { let n, i, { buffer: r } = this; if (r) { if (e > 0) { if (this.index < r.buffer.buffer.length) return !1 } else for (let o = 0; o < this.index; o++)if (r.buffer.buffer[o + 3] < this.index) return !1; ({ index: n, parent: i } = r) } else ({ index: n, _parent: i } = this._tree); for (; i; { index: n, _parent: i } = i)if (n > -1) for (let o = n + e, s = e < 0 ? -1 : i._tree.children.length; o != s; o += e) { let l = i._tree.children[o]; if (this.mode & ft.IncludeAnonymous || l instanceof hr || !l.type.isAnonymous || og(l)) return !1 } return !0 } move(e, n) { if (n && this.enterChild(e, 0, 4)) return !0; for (; ;) { if (this.sibling(e)) return !0; if (this.atLastNode(e) || !this.parent()) return !1 } } next(e = !0) { return this.move(1, e) } prev(e = !0) { return this.move(-1, e) } moveTo(e, n = 0) { for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent();); for (; this.enterChild(1, e, n);); return this } get node() { if (!this.buffer) return this._tree; let e = this.bufferNode, n = null, i = 0; if (e && e.context == this.buffer) e: for (let r = this.index, o = this.stack.length; o >= 0;) { for (let s = e; s; s = s._parent)if (s.index == r) { if (r == this.index) return s; n = s, i = o + 1; break e } r = this.stack[--o] } for (let r = i; r < this.stack.length; r++)n = new Zn(this.buffer, n, this.stack[r]); return this.bufferNode = new Zn(this.buffer, n, this.index) } get tree() { return this.buffer ? null : this._tree._tree } iterate(e, n) { for (let i = 0; ;) { let r = !1; if (this.type.isAnonymous || e(this) !== !1) { if (this.firstChild()) { i++; continue } this.type.isAnonymous || (r = !0) } for (; r && n && n(this), r = this.type.isAnonymous, !this.nextSibling();) { if (!i) return; this.parent(), i--, r = !0 } } } matchContext(e) { if (!this.buffer) return Ad(this.node.parent, e); let { buffer: n } = this.buffer, { types: i } = n.set; for (let r = e.length - 1, o = this.stack.length - 1; r >= 0; o--) { if (o < 0) return Ad(this._tree, e, r); let s = i[n.buffer[this.stack[o]]]; if (!s.isAnonymous) { if (e[r] && e[r] != s.name) return !1; r-- } } return !0 } } function og(t) { return t.children.some(e => e instanceof hr || !e.type.isAnonymous || og(e)) } function DE(t) { var e; let { buffer: n, nodeSet: i, maxBufferLength: r = jS, reused: o = [], minRepeatType: s = i.types.length } = t, l = Array.isArray(n) ? new rg(n, n.length) : n, a = i.types, c = 0, u = 0; function f(y, C, O, P, M, A) { let { id: B, start: R, end: X, size: K } = l, _ = u, j = c; for (; K < 0;)if (l.next(), K == -1) { let J = o[B]; O.push(J), P.push(R - y); return } else if (K == -3) { c = B; return } else if (K == -4) { u = B; return } else throw new RangeError(`Unrecognized record size: ${K}`); let W = a[B], G, ae, ge = R - y; if (X - R <= r && (ae = m(l.pos - C, M))) { let J = new Uint16Array(ae.size - ae.skip), ce = l.pos - ae.size, Oe = J.length; for (; l.pos > ce;)Oe = v(ae.start, J, Oe); G = new hr(J, X - ae.start, i), ge = ae.start - y } else { let J = l.pos - K; l.next(); let ce = [], Oe = [], Le = B >= s ? B : -1, Qe = 0, Ae = X; for (; l.pos > J;)Le >= 0 && l.id == Le && l.size >= 0 ? (l.end <= Ae - r && (p(ce, Oe, R, Qe, l.end, Ae, Le, _, j), Qe = ce.length, Ae = l.end), l.next()) : A > 2500 ? h(R, J, ce, Oe) : f(R, J, ce, Oe, Le, A + 1); if (Le >= 0 && Qe > 0 && Qe < ce.length && p(ce, Oe, R, Qe, R, Ae, Le, _, j), ce.reverse(), Oe.reverse(), Le > -1 && Qe > 0) { let U = d(W, j); G = sg(W, ce, Oe, 0, ce.length, 0, X - R, U, U) } else G = g(W, ce, Oe, X - R, _ - X, j) } O.push(G), P.push(ge) } function h(y, C, O, P) { let M = [], A = 0, B = -1; for (; l.pos > C;) { let { id: R, start: X, end: K, size: _ } = l; if (_ > 4) l.next(); else { if (B > -1 && X < B) break; B < 0 && (B = K - r), M.push(R, X, K), A++, l.next() } } if (A) { let R = new Uint16Array(A * 4), X = M[M.length - 2]; for (let K = M.length - 3, _ = 0; K >= 0; K -= 3)R[_++] = M[K], R[_++] = M[K + 1] - X, R[_++] = M[K + 2] - X, R[_++] = _; O.push(new hr(R, M[2] - X, i)), P.push(X - y) } } function d(y, C) { return (O, P, M) => { let A = 0, B = O.length - 1, R, X; if (B >= 0 && (R = O[B]) instanceof at) { if (!B && R.type == y && R.length == M) return R; (X = R.prop($e.lookAhead)) && (A = P[B] + R.length + X) } return g(y, O, P, M, A, C) } } function p(y, C, O, P, M, A, B, R, X) { let K = [], _ = []; for (; y.length > P;)K.push(y.pop()), _.push(C.pop() + O - M); y.push(g(i.types[B], K, _, A - M, R - A, X)), C.push(M - O) } function g(y, C, O, P, M, A, B) { if (A) { let R = [$e.contextHash, A]; B = B ? [R].concat(B) : [R] } if (M > 25) { let R = [$e.lookAhead, M]; B = B ? [R].concat(B) : [R] } return new at(y, C, O, P, B) } function m(y, C) { let O = l.fork(), P = 0, M = 0, A = 0, B = O.end - r, R = { size: 0, start: 0, skip: 0 }; e: for (let X = O.pos - y; O.pos > X;) { let K = O.size; if (O.id == C && K >= 0) { R.size = P, R.start = M, R.skip = A, A += 4, P += 4, O.next(); continue } let _ = O.pos - K; if (K < 0 || _ < X || O.start < B) break; let j = O.id >= s ? 4 : 0, W = O.start; for (O.next(); O.pos > _;) { if (O.size < 0) if (O.size == -3) j += 4; else break e; else O.id >= s && (j += 4); O.next() } M = W, P += K, A += j } return (C < 0 || P == y) && (R.size = P, R.start = M, R.skip = A), R.size > 4 ? R : void 0 } function v(y, C, O) { let { id: P, start: M, end: A, size: B } = l; if (l.next(), B >= 0 && P < s) { let R = O; if (B > 4) { let X = l.pos - (B - 4); for (; l.pos > X;)O = v(y, C, O) } C[--O] = R, C[--O] = A - y, C[--O] = M - y, C[--O] = P } else B == -3 ? c = P : B == -4 && (u = P); return O } let b = [], x = []; for (; l.pos > 0;)f(t.start || 0, t.bufferStart || 0, b, x, -1, 0); let w = (e = t.length) !== null && e !== void 0 ? e : b.length ? x[0] + b[0].length : 0; return new at(a[t.topID], b.reverse(), x.reverse(), w) } const ev = new WeakMap; function lc(t, e) { if (!t.isAnonymous || e instanceof hr || e.type != t) return 1; let n = ev.get(e); if (n == null) { n = 1; for (let i of e.children) { if (i.type != t || !(i instanceof at)) { n = 1; break } n += lc(t, i) } ev.set(e, n) } return n } function sg(t, e, n, i, r, o, s, l, a) { let c = 0; for (let p = i; p < r; p++)c += lc(t, e[p]); let u = Math.ceil(c * 1.5 / 8), f = [], h = []; function d(p, g, m, v, b) { for (let x = m; x < v;) { let w = x, y = g[x], C = lc(t, p[x]); for (x++; x < v; x++) { let O = lc(t, p[x]); if (C + O >= u) break; C += O } if (x == w + 1) { if (C > u) { let O = p[w]; d(O.children, O.positions, 0, O.children.length, g[w] + b); continue } f.push(p[w]) } else { let O = g[x - 1] + p[x - 1].length - y; f.push(sg(t, p, g, w, x, y, O, null, a)) } h.push(y + b - o) } } return d(e, n, i, r, 0), (l || a)(f, h, s) } class BE { constructor() { this.map = new WeakMap } setBuffer(e, n, i) { let r = this.map.get(e); r || this.map.set(e, r = new Map), r.set(n, i) } getBuffer(e, n) { let i = this.map.get(e); return i && i.get(n) } set(e, n) { e instanceof Zn ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Zt && this.map.set(e.tree, n) } get(e) { return e instanceof Zn ? this.getBuffer(e.context.buffer, e.index) : e instanceof Zt ? this.map.get(e.tree) : void 0 } cursorSet(e, n) { e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n) } cursorGet(e) { return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree) } } class Qr { constructor(e, n, i, r, o = !1, s = !1) { this.from = e, this.to = n, this.tree = i, this.offset = r, this.open = (o ? 1 : 0) | (s ? 2 : 0) } get openStart() { return (this.open & 1) > 0 } get openEnd() { return (this.open & 2) > 0 } static addTree(e, n = [], i = !1) { let r = [new Qr(0, e.length, e, 0, !1, i)]; for (let o of n) o.to > e.length && r.push(o); return r } static applyChanges(e, n, i = 128) { if (!n.length) return e; let r = [], o = 1, s = e.length ? e[0] : null; for (let l = 0, a = 0, c = 0; ; l++) { let u = l < n.length ? n[l] : null, f = u ? u.fromA : 1e9; if (f - a >= i) for (; s && s.from < f;) { let h = s; if (a >= h.from || f <= h.to || c) { let d = Math.max(h.from, a) - c, p = Math.min(h.to, f) - c; h = d >= p ? null : new Qr(d, p, h.tree, h.offset + c, l > 0, !!u) } if (h && r.push(h), s.to > f) break; s = o < e.length ? e[o++] : null } if (!u) break; a = u.toA, c = u.toA - u.toB } return r } } class US { startParse(e, n, i) { return typeof e == "string" && (e = new LE(e)), i = i ? i.length ? i.map(r => new Nf(r.from, r.to)) : [new Nf(0, 0)] : [new Nf(0, e.length)], this.createParse(e, n || [], i) } parse(e, n, i) { let r = this.startParse(e, n, i); for (; ;) { let o = r.advance(); if (o) return o } } } class LE { constructor(e) { this.string = e } get length() { return this.string.length } chunk(e) { return this.string.slice(e) } get lineChunks() { return !1 } read(e, n) { return this.string.slice(e, n) } } new $e({ perNode: !0 }); let QE = 0; class yn { constructor(e, n, i, r) { this.name = e, this.set = n, this.base = i, this.modified = r, this.id = QE++ } toString() { let { name: e } = this; for (let n of this.modified) n.name && (e = `${n.name}(${e})`); return e } static define(e, n) { let i = typeof e == "string" ? e : "?"; if (e instanceof yn && (n = e), n != null && n.base) throw new Error("Can not derive from a modified tag"); let r = new yn(i, [], null, []); if (r.set.push(r), n) for (let o of n.set) r.set.push(o); return r } static defineModifier(e) { let n = new Bc(e); return i => i.modified.indexOf(n) > -1 ? i : Bc.get(i.base || i, i.modified.concat(n).sort((r, o) => r.id - o.id)) } } let NE = 0; class Bc { constructor(e) { this.name = e, this.instances = [], this.id = NE++ } static get(e, n) { if (!n.length) return e; let i = n[0].instances.find(l => l.base == e && zE(n, l.modified)); if (i) return i; let r = [], o = new yn(e.name, r, e, n); for (let l of n) l.instances.push(o); let s = WE(n); for (let l of e.set) if (!l.modified.length) for (let a of s) r.push(Bc.get(l, a)); return o } } function zE(t, e) { return t.length == e.length && t.every((n, i) => n == e[i]) } function WE(t) { let e = [[]]; for (let n = 0; n < t.length; n++)for (let i = 0, r = e.length; i < r; i++)e.push(e[i].concat(t[n])); return e.sort((n, i) => i.length - n.length) } function GS(t) { let e = Object.create(null); for (let n in t) { let i = t[n]; Array.isArray(i) || (i = [i]); for (let r of n.split(" ")) if (r) { let o = [], s = 2, l = r; for (let f = 0; ;) { if (l == "..." && f > 0 && f + 3 == r.length) { s = 1; break } let h = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l); if (!h) throw new RangeError("Invalid path: " + r); if (o.push(h[0] == "*" ? "" : h[0][0] == '"' ? JSON.parse(h[0]) : h[0]), f += h[0].length, f == r.length) break; let d = r[f++]; if (f == r.length && d == "!") { s = 0; break } if (d != "/") throw new RangeError("Invalid path: " + r); l = r.slice(f) } let a = o.length - 1, c = o[a]; if (!c) throw new RangeError("Invalid path: " + r); let u = new Lc(i, s, a > 0 ? o.slice(0, a) : null); e[c] = u.sort(e[c]) } } return KS.add(e) } const KS = new $e; class Lc { constructor(e, n, i, r) { this.tags = e, this.mode = n, this.context = i, this.next = r } get opaque() { return this.mode == 0 } get inherit() { return this.mode == 1 } sort(e) { return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e) } get depth() { return this.context ? this.context.length : 0 } } Lc.empty = new Lc([], 2, null); function YS(t, e) { let n = Object.create(null); for (let o of t) if (!Array.isArray(o.tag)) n[o.tag.id] = o.class; else for (let s of o.tag) n[s.id] = o.class; let { scope: i, all: r = null } = e || {}; return { style: o => { let s = r; for (let l of o) for (let a of l.set) { let c = n[a.id]; if (c) { s = s ? s + " " + c : c; break } } return s }, scope: i } } function HE(t, e) { let n = null; for (let i of t) { let r = i.style(e); r && (n = n ? n + " " + r : r) } return n } function FE(t, e, n, i = 0, r = t.length) { let o = new jE(i, Array.isArray(e) ? e : [e], n); o.highlightRange(t.cursor(), i, r, "", o.highlighters), o.flush(r) } class jE { constructor(e, n, i) { this.at = e, this.highlighters = n, this.span = i, this.class = "" } startSpan(e, n) { n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n) } flush(e) { e > this.at && this.class && this.span(this.at, e, this.class) } highlightRange(e, n, i, r, o) { let { type: s, from: l, to: a } = e; if (l >= i || a <= n) return; s.isTop && (o = this.highlighters.filter(d => !d.scope || d.scope(s))); let c = r, u = qE(e) || Lc.empty, f = HE(o, u.tags); if (f && (c && (c += " "), c += f, u.mode == 1 && (r += (r ? " " : "") + f)), this.startSpan(Math.max(n, l), c), u.opaque) return; let h = e.tree && e.tree.prop($e.mounted); if (h && h.overlay) { let d = e.node.enter(h.overlay[0].from + l, 1), p = this.highlighters.filter(m => !m.scope || m.scope(h.tree.type)), g = e.firstChild(); for (let m = 0, v = l; ; m++) { let b = m < h.overlay.length ? h.overlay[m] : null, x = b ? b.from + l : a, w = Math.max(n, v), y = Math.min(i, x); if (w < y && g) for (; e.from < y && (this.highlightRange(e, w, y, r, o), this.startSpan(Math.min(y, e.to), c), !(e.to >= x || !e.nextSibling()));); if (!b || x > i) break; v = b.to + l, v > n && (this.highlightRange(d.cursor(), Math.max(n, b.from + l), Math.min(i, v), "", p), this.startSpan(Math.min(i, v), c)) } g && e.parent() } else if (e.firstChild()) { h && (r = ""); do if (!(e.to <= n)) { if (e.from >= i) break; this.highlightRange(e, n, i, r, o), this.startSpan(Math.min(i, e.to), c) } while (e.nextSibling()); e.parent() } } } function qE(t) { let e = t.type.prop(KS); for (; e && e.context && !t.matchContext(e.context);)e = e.next; return e || null } const Z = yn.define, wa = Z(), Vi = Z(), tv = Z(Vi), nv = Z(Vi), Xi = Z(), Ca = Z(Xi), zf = Z(Xi), qn = Z(), Cr = Z(qn), Fn = Z(), jn = Z(), Ed = Z(), xs = Z(Ed), Ta = Z(), F = { comment: wa, lineComment: Z(wa), blockComment: Z(wa), docComment: Z(wa), name: Vi, variableName: Z(Vi), typeName: tv, tagName: Z(tv), propertyName: nv, attributeName: Z(nv), className: Z(Vi), labelName: Z(Vi), namespace: Z(Vi), macroName: Z(Vi), literal: Xi, string: Ca, docString: Z(Ca), character: Z(Ca), attributeValue: Z(Ca), number: zf, integer: Z(zf), float: Z(zf), bool: Z(Xi), regexp: Z(Xi), escape: Z(Xi), color: Z(Xi), url: Z(Xi), keyword: Fn, self: Z(Fn), null: Z(Fn), atom: Z(Fn), unit: Z(Fn), modifier: Z(Fn), operatorKeyword: Z(Fn), controlKeyword: Z(Fn), definitionKeyword: Z(Fn), moduleKeyword: Z(Fn), operator: jn, derefOperator: Z(jn), arithmeticOperator: Z(jn), logicOperator: Z(jn), bitwiseOperator: Z(jn), compareOperator: Z(jn), updateOperator: Z(jn), definitionOperator: Z(jn), typeOperator: Z(jn), controlOperator: Z(jn), punctuation: Ed, separator: Z(Ed), bracket: xs, angleBracket: Z(xs), squareBracket: Z(xs), paren: Z(xs), brace: Z(xs), content: qn, heading: Cr, heading1: Z(Cr), heading2: Z(Cr), heading3: Z(Cr), heading4: Z(Cr), heading5: Z(Cr), heading6: Z(Cr), contentSeparator: Z(qn), list: Z(qn), quote: Z(qn), emphasis: Z(qn), strong: Z(qn), link: Z(qn), monospace: Z(qn), strikethrough: Z(qn), inserted: Z(), deleted: Z(), changed: Z(), invalid: Z(), meta: Ta, documentMeta: Z(Ta), annotation: Z(Ta), processingInstruction: Z(Ta), definition: yn.defineModifier("definition"), constant: yn.defineModifier("constant"), function: yn.defineModifier("function"), standard: yn.defineModifier("standard"), local: yn.defineModifier("local"), special: yn.defineModifier("special") }; for (let t in F) { let e = F[t]; e instanceof yn && (e.name = t) } YS([{ tag: F.link, class: "tok-link" }, { tag: F.heading, class: "tok-heading" }, { tag: F.emphasis, class: "tok-emphasis" }, { tag: F.strong, class: "tok-strong" }, { tag: F.keyword, class: "tok-keyword" }, { tag: F.atom, class: "tok-atom" }, { tag: F.bool, class: "tok-bool" }, { tag: F.url, class: "tok-url" }, { tag: F.labelName, class: "tok-labelName" }, { tag: F.inserted, class: "tok-inserted" }, { tag: F.deleted, class: "tok-deleted" }, { tag: F.literal, class: "tok-literal" }, { tag: F.string, class: "tok-string" }, { tag: F.number, class: "tok-number" }, { tag: [F.regexp, F.escape, F.special(F.string)], class: "tok-string2" }, { tag: F.variableName, class: "tok-variableName" }, { tag: F.local(F.variableName), class: "tok-variableName tok-local" }, { tag: F.definition(F.variableName), class: "tok-variableName tok-definition" }, { tag: F.special(F.variableName), class: "tok-variableName2" }, { tag: F.definition(F.propertyName), class: "tok-propertyName tok-definition" }, { tag: F.typeName, class: "tok-typeName" }, { tag: F.namespace, class: "tok-namespace" }, { tag: F.className, class: "tok-className" }, { tag: F.macroName, class: "tok-macroName" }, { tag: F.propertyName, class: "tok-propertyName" }, { tag: F.operator, class: "tok-operator" }, { tag: F.comment, class: "tok-comment" }, { tag: F.meta, class: "tok-meta" }, { tag: F.invalid, class: "tok-invalid" }, { tag: F.punctuation, class: "tok-punctuation" }]); var Wf; const bo = new $e; function VE(t) { return se.define({ combine: t ? e => e.concat(t) : void 0 }) } const XE = new $e; class En { constructor(e, n, i = [], r = "") { this.data = e, this.name = r, _e.prototype.hasOwnProperty("tree") || Object.defineProperty(_e.prototype, "tree", { get() { return yt(this) } }), this.parser = n, this.extension = [dr.of(this), _e.languageData.of((o, s, l) => { let a = iv(o, s, l), c = a.type.prop(bo); if (!c) return []; let u = o.facet(c), f = a.type.prop(XE); if (f) { let h = a.resolve(s - a.from, l); for (let d of f) if (d.test(h, o)) { let p = o.facet(d.facet); return d.type == "replace" ? p : p.concat(u) } } return u })].concat(i) } isActiveAt(e, n, i = -1) { return iv(e, n, i).type.prop(bo) == this.data } findRegions(e) { let n = e.facet(dr); if ((n == null ? void 0 : n.data) == this.data) return [{ from: 0, to: e.doc.length }]; if (!n || !n.allowsNesting) return []; let i = [], r = (o, s) => { if (o.prop(bo) == this.data) { i.push({ from: s, to: s + o.length }); return } let l = o.prop($e.mounted); if (l) { if (l.tree.prop(bo) == this.data) { if (l.overlay) for (let a of l.overlay) i.push({ from: a.from + s, to: a.to + s }); else i.push({ from: s, to: s + o.length }); return } else if (l.overlay) { let a = i.length; if (r(l.tree, l.overlay[0].from + s), i.length > a) return } } for (let a = 0; a < o.children.length; a++) { let c = o.children[a]; c instanceof at && r(c, o.positions[a] + s) } }; return r(yt(e), 0), i } get allowsNesting() { return !0 } } En.setState = Ce.define(); function iv(t, e, n) { let i = t.facet(dr), r = yt(t).topNode; if (!i || i.allowsNesting) for (let o = r; o; o = o.enter(e, n, ft.ExcludeBuffers))o.type.isTop && (r = o); return r } class Qc extends En { constructor(e, n, i) { super(e, n, [], i), this.parser = n } static define(e) { let n = VE(e.languageData); return new Qc(n, e.parser.configure({ props: [bo.add(i => i.isTop ? n : void 0)] }), e.name) } configure(e, n) { return new Qc(this.data, this.parser.configure(e), n || this.name) } get allowsNesting() { return this.parser.hasWrappers() } } function yt(t) { let e = t.field(En.state, !1); return e ? e.tree : at.empty } class UE { constructor(e) { this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter() } get length() { return this.doc.length } syncTo(e) { return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length } chunk(e) { return this.syncTo(e), this.string } get lineChunks() { return !0 } read(e, n) { let i = this.cursorPos - this.string.length; return e < i || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - i, n - i) } } let ws = null; class Nc { constructor(e, n, i = [], r, o, s, l, a) { this.parser = e, this.state = n, this.fragments = i, this.tree = r, this.treeLen = o, this.viewport = s, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [] } static create(e, n, i) { return new Nc(e, n, [], at.empty, 0, i, [], null) } startParse() { return this.parser.startParse(new UE(this.state.doc), this.fragments) } work(e, n) { return n != null && n >= this.state.doc.length && (n = void 0), this.tree != at.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => { var i; if (typeof e == "number") { let r = Date.now() + e; e = () => Date.now() > r } for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ;) { let r = this.parse.advance(); if (r) if (this.fragments = this.withoutTempSkipped(Qr.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (n ?? this.state.doc.length)) this.parse = this.startParse(); else return !0; if (e()) return !1 } }) } takeTree() { let e, n; this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => { for (; !(n = this.parse.advance());); }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Qr.addTree(this.tree, this.fragments, !0)), this.parse = null) } withContext(e) { let n = ws; ws = this; try { return e() } finally { ws = n } } withoutTempSkipped(e) { for (let n; n = this.tempSkipped.pop();)e = rv(e, n.from, n.to); return e } changes(e, n) { let { fragments: i, tree: r, treeLen: o, viewport: s, skipped: l } = this; if (this.takeTree(), !e.empty) { let a = []; if (e.iterChangedRanges((c, u, f, h) => a.push({ fromA: c, toA: u, fromB: f, toB: h })), i = Qr.applyChanges(i, a), r = at.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) { l = []; for (let c of this.skipped) { let u = e.mapPos(c.from, 1), f = e.mapPos(c.to, -1); u < f && l.push({ from: u, to: f }) } } } return new Nc(this.parser, n, i, r, o, s, l, this.scheduleOn) } updateViewport(e) { if (this.viewport.from == e.from && this.viewport.to == e.to) return !1; this.viewport = e; let n = this.skipped.length; for (let i = 0; i < this.skipped.length; i++) { let { from: r, to: o } = this.skipped[i]; r < e.to && o > e.from && (this.fragments = rv(this.fragments, r, o), this.skipped.splice(i--, 1)) } return this.skipped.length >= n ? !1 : (this.reset(), !0) } reset() { this.parse && (this.takeTree(), this.parse = null) } skipUntilInView(e, n) { this.skipped.push({ from: e, to: n }) } static getSkippingParser(e) { return new class extends US { createParse(n, i, r) { let o = r[0].from, s = r[r.length - 1].to; return { parsedPos: o, advance() { let a = ws; if (a) { for (let c of r) a.tempSkipped.push(c); e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e) } return this.parsedPos = s, new at(Jt.none, [], [], s - o) }, stoppedAt: null, stopAt() { } } } } } isDone(e) { e = Math.min(e, this.state.doc.length); let n = this.fragments; return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e } static get() { return ws } } function rv(t, e, n) { return Qr.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]) } class qo { constructor(e) { this.context = e, this.tree = e.tree } apply(e) { if (!e.docChanged && this.tree == this.context.tree) return this; let n = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to); return n.work(20, i) || n.takeTree(), new qo(n) } static init(e) { let n = Math.min(3e3, e.doc.length), i = Nc.create(e.facet(dr).parser, e, { from: 0, to: n }); return i.work(20, n) || i.takeTree(), new qo(i) } } En.state = bt.define({ create: qo.init, update(t, e) { for (let n of e.effects) if (n.is(En.setState)) return n.value; return e.startState.facet(dr) != e.state.facet(dr) ? qo.init(e.state) : t.apply(e) } }); let ZS = t => { let e = setTimeout(() => t(), 500); return () => clearTimeout(e) }; typeof requestIdleCallback < "u" && (ZS = t => { let e = -1, n = setTimeout(() => { e = requestIdleCallback(t, { timeout: 500 - 100 }) }, 100); return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e) }); const Hf = typeof navigator < "u" && (!((Wf = navigator.scheduling) === null || Wf === void 0) && Wf.isInputPending) ? () => navigator.scheduling.isInputPending() : null, GE = ct.fromClass(class { constructor(e) { this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork() } update(e) { let n = this.view.state.field(En.state).context; (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n) } scheduleWork() { if (this.working) return; let { state: e } = this.view, n = e.field(En.state); (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = ZS(this.work)) } work(e) { this.working = null; let n = Date.now(); if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0) return; let { state: i, viewport: { to: r } } = this.view, o = i.field(En.state); if (o.tree == o.context.tree && o.context.isDone(r + 1e5)) return; let s = Date.now() + Math.min(this.chunkBudget, 100, e && !Hf ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = o.context.treeLen < r && i.doc.length > r + 1e3, a = o.context.work(() => Hf && Hf() || Date.now() > s, r + (l ? 0 : 1e5)); this.chunkBudget -= Date.now() - n, (a || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: En.setState.of(new qo(o.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(o.context) } checkAsyncSchedule(e) { e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch(n => Kt(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null) } destroy() { this.working && this.working() } isWorking() { return !!(this.working || this.workScheduled > 0) } }, { eventHandlers: { focus() { this.scheduleWork() } } }), dr = se.define({ combine(t) { return t.length ? t[0] : null }, enables: t => [En.state, GE, ie.contentAttributes.compute([t], e => { let n = e.facet(t); return n && n.name ? { "data-language": n.name } : {} })] }); class KE { constructor(e, n = []) { this.language = e, this.support = n, this.extension = [e, n] } } const YE = se.define(), Bu = se.define({ combine: t => { if (!t.length) return "  "; let e = t[0]; if (!e || /\S/.test(e) || Array.from(e).some(n => n != e[0])) throw new Error("Invalid indent unit: " + JSON.stringify(t[0])); return e } }); function zc(t) { let e = t.facet(Bu); return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length } function xl(t, e) { let n = "", i = t.tabSize, r = t.facet(Bu)[0]; if (r == "	") { for (; e >= i;)n += "	", e -= i; r = " " } for (let o = 0; o < e; o++)n += r; return n } function lg(t, e) { t instanceof _e && (t = new Lu(t)); for (let i of t.state.facet(YE)) { let r = i(t, e); if (r !== void 0) return r } let n = yt(t.state); return n.length >= e ? ZE(t, n, e) : null } class Lu { constructor(e, n = {}) { this.state = e, this.options = n, this.unit = zc(e) } lineAt(e, n = 1) { let i = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: o } = this.options; return r != null && r >= i.from && r <= i.to ? o && r == e ? { text: "", from: e } : (n < 0 ? r < e : r <= e) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i } textAfterPos(e, n = 1) { if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return ""; let { text: i, from: r } = this.lineAt(e, n); return i.slice(e - r, Math.min(i.length, e + 100 - r)) } column(e, n = 1) { let { text: i, from: r } = this.lineAt(e, n), o = this.countColumn(i, e - r), s = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1; return s > -1 && (o += s - this.countColumn(i, i.search(/\S|$/))), o } countColumn(e, n = e.length) { return ss(e, this.state.tabSize, n) } lineIndent(e, n = 1) { let { text: i, from: r } = this.lineAt(e, n), o = this.options.overrideIndentation; if (o) { let s = o(r); if (s > -1) return s } return this.countColumn(i, i.search(/\S|$/)) } get simulatedBreak() { return this.options.simulateBreak || null } } const JS = new $e; function ZE(t, e, n) { let i = e.resolveStack(n), r = i.node.enterUnfinishedNodesBefore(n); if (r != i.node) { let o = []; for (let s = r; s != i.node; s = s.parent)o.push(s); for (let s = o.length - 1; s >= 0; s--)i = { node: o[s], next: i } } return ex(i, t, n) } function ex(t, e, n) { for (let i = t; i; i = i.next) { let r = e2(i.node); if (r) return r(ag.create(e, n, i)) } return 0 } function JE(t) { return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak } function e2(t) { let e = t.type.prop(JS); if (e) return e; let n = t.firstChild, i; if (n && (i = n.type.prop($e.closedBy))) { let r = t.lastChild, o = r && i.indexOf(r.name) > -1; return s => tx(s, !0, 1, void 0, o && !JE(s) ? r.from : void 0) } return t.parent == null ? t2 : null } function t2() { return 0 } class ag extends Lu { constructor(e, n, i) { super(e.state, e.options), this.base = e, this.pos = n, this.context = i } get node() { return this.context.node } static create(e, n, i) { return new ag(e, n, i) } get textAfter() { return this.textAfterPos(this.pos) } get baseIndent() { return this.baseIndentFor(this.node) } baseIndentFor(e) { let n = this.state.doc.lineAt(e.from); for (; ;) { let i = e.resolve(n.from); for (; i.parent && i.parent.from == i.from;)i = i.parent; if (n2(i, e)) break; n = this.state.doc.lineAt(i.from) } return this.lineIndent(n.from) } continue() { return ex(this.context.next, this.base, this.pos) } } function n2(t, e) { for (let n = e; n; n = n.parent)if (t == n) return !0; return !1 } function i2(t) { let e = t.node, n = e.childAfter(e.from), i = e.lastChild; if (!n) return null; let r = t.options.simulateBreak, o = t.state.doc.lineAt(n.from), s = r == null || r <= o.from ? o.to : Math.min(o.to, r); for (let l = n.to; ;) { let a = e.childAfter(l); if (!a || a == i) return null; if (!a.type.isSkipped) { if (a.from >= s) return null; let c = /^ */.exec(o.text.slice(n.to - o.from))[0].length; return { from: n.from, to: n.to + c } } l = a.to } } function Ff({ closing: t, align: e = !0, units: n = 1 }) { return i => tx(i, e, n, t) } function tx(t, e, n, i, r) { let o = t.textAfter, s = o.match(/^\s*/)[0].length, l = i && o.slice(s, s + i.length) == i || r == t.pos + s, a = e ? i2(t) : null; return a ? l ? t.column(a.from) : t.column(a.to) : t.baseIndent + (l ? 0 : t.unit * n) } const r2 = 200; function o2() { return _e.transactionFilter.of(t => { if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete")) return t; let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head); if (!e.length) return t; let n = t.newDoc, { head: i } = t.newSelection.main, r = n.lineAt(i); if (i > r.from + r2) return t; let o = n.sliceString(r.from, i); if (!e.some(c => c.test(o))) return t; let { state: s } = t, l = -1, a = []; for (let { head: c } of s.selection.ranges) { let u = s.doc.lineAt(c); if (u.from == l) continue; l = u.from; let f = lg(s, u.from); if (f == null) continue; let h = /^\s*/.exec(u.text)[0], d = xl(s, f); h != d && a.push({ from: u.from, to: u.from + h.length, insert: d }) } return a.length ? [t, { changes: a, sequential: !0 }] : t }) } const s2 = se.define(), nx = new $e; function l2(t) { let e = t.firstChild, n = t.lastChild; return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null } function a2(t, e, n) { let i = yt(t); if (i.length < n) return null; let r = i.resolveStack(n, 1), o = null; for (let s = r; s; s = s.next) { let l = s.node; if (l.to <= n || l.from > n) continue; if (o && l.from < e) break; let a = l.type.prop(nx); if (a && (l.to < i.length - 50 || i.length == t.doc.length || !c2(l))) { let c = a(l, t); c && c.from <= n && c.from >= e && c.to > n && (o = c) } } return o } function c2(t) { let e = t.lastChild; return e && e.to == t.to && e.type.isError } function Wc(t, e, n) { for (let i of t.facet(s2)) { let r = i(t, e, n); if (r) return r } return a2(t, e, n) } function ix(t, e) { let n = e.mapPos(t.from, 1), i = e.mapPos(t.to, -1); return n >= i ? void 0 : { from: n, to: i } } const Qu = Ce.define({ map: ix }), Vl = Ce.define({ map: ix }); function rx(t) { let e = []; for (let { head: n } of t.state.selection.ranges) e.some(i => i.from <= n && i.to >= n) || e.push(t.lineBlockAt(n)); return e } const Ur = bt.define({ create() { return de.none }, update(t, e) { t = t.map(e.changes); for (let n of e.effects) if (n.is(Qu) && !u2(t, n.value.from, n.value.to)) { let { preparePlaceholder: i } = e.state.facet(cg), r = i ? de.replace({ widget: new v2(i(e.state, n.value)) }) : ov; t = t.update({ add: [r.range(n.value.from, n.value.to)] }) } else n.is(Vl) && (t = t.update({ filter: (i, r) => n.value.from != i || n.value.to != r, filterFrom: n.value.from, filterTo: n.value.to })); if (e.selection) { let n = !1, { head: i } = e.selection.main; t.between(i, i, (r, o) => { r < i && o > i && (n = !0) }), n && (t = t.update({ filterFrom: i, filterTo: i, filter: (r, o) => o <= i || r >= i })) } return t }, provide: t => ie.decorations.from(t), toJSON(t, e) { let n = []; return t.between(0, e.doc.length, (i, r) => { n.push(i, r) }), n }, fromJSON(t) { if (!Array.isArray(t) || t.length % 2) throw new RangeError("Invalid JSON for fold state"); let e = []; for (let n = 0; n < t.length;) { let i = t[n++], r = t[n++]; if (typeof i != "number" || typeof r != "number") throw new RangeError("Invalid JSON for fold state"); e.push(ov.range(i, r)) } return de.set(e, !0) } }); function Hc(t, e, n) { var i; let r = null; return (i = t.field(Ur, !1)) === null || i === void 0 || i.between(e, n, (o, s) => { (!r || r.from > o) && (r = { from: o, to: s }) }), r } function u2(t, e, n) { let i = !1; return t.between(e, e, (r, o) => { r == e && o == n && (i = !0) }), i } function ox(t, e) { return t.field(Ur, !1) ? e : e.concat(Ce.appendConfig.of(lx())) } const f2 = t => { for (let e of rx(t)) { let n = Wc(t.state, e.from, e.to); if (n) return t.dispatch({ effects: ox(t.state, [Qu.of(n), sx(t, n)]) }), !0 } return !1 }, h2 = t => { if (!t.state.field(Ur, !1)) return !1; let e = []; for (let n of rx(t)) { let i = Hc(t.state, n.from, n.to); i && e.push(Vl.of(i), sx(t, i, !1)) } return e.length && t.dispatch({ effects: e }), e.length > 0 }; function sx(t, e, n = !0) { let i = t.state.doc.lineAt(e.from).number, r = t.state.doc.lineAt(e.to).number; return ie.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${i} ${t.state.phrase("to")} ${r}.`) } const d2 = t => { let { state: e } = t, n = []; for (let i = 0; i < e.doc.length;) { let r = t.lineBlockAt(i), o = Wc(e, r.from, r.to); o && n.push(Qu.of(o)), i = (o ? t.lineBlockAt(o.to) : r).to + 1 } return n.length && t.dispatch({ effects: ox(t.state, n) }), !!n.length }, p2 = t => { let e = t.state.field(Ur, !1); if (!e || !e.size) return !1; let n = []; return e.between(0, t.state.doc.length, (i, r) => { n.push(Vl.of({ from: i, to: r })) }), t.dispatch({ effects: n }), !0 }, g2 = [{ key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: f2 }, { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: h2 }, { key: "Ctrl-Alt-[", run: d2 }, { key: "Ctrl-Alt-]", run: p2 }], m2 = { placeholderDOM: null, preparePlaceholder: null, placeholderText: "…" }, cg = se.define({ combine(t) { return fi(t, m2) } }); function lx(t) { let e = [Ur, O2]; return t && e.push(cg.of(t)), e } function ax(t, e) { let { state: n } = t, i = n.facet(cg), r = s => { let l = t.lineBlockAt(t.posAtDOM(s.target)), a = Hc(t.state, l.from, l.to); a && t.dispatch({ effects: Vl.of(a) }), s.preventDefault() }; if (i.placeholderDOM) return i.placeholderDOM(t, r, e); let o = document.createElement("span"); return o.textContent = i.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = r, o } const ov = de.replace({ widget: new class extends Ii { toDOM(t) { return ax(t, null) } } }); class v2 extends Ii { constructor(e) { super(), this.value = e } eq(e) { return this.value == e.value } toDOM(e) { return ax(e, this.value) } } const y2 = { openText: "⌄", closedText: "›", markerDOM: null, domEventHandlers: {}, foldingChanged: () => !1 }; class jf extends Mi { constructor(e, n) { super(), this.config = e, this.open = n } eq(e) { return this.config == e.config && this.open == e.open } toDOM(e) { if (this.config.markerDOM) return this.config.markerDOM(this.open); let n = document.createElement("span"); return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n } } function b2(t = {}) { let e = Object.assign(Object.assign({}, y2), t), n = new jf(e, !0), i = new jf(e, !1), r = ct.fromClass(class { constructor(s) { this.from = s.viewport.from, this.markers = this.buildMarkers(s) } update(s) { (s.docChanged || s.viewportChanged || s.startState.facet(dr) != s.state.facet(dr) || s.startState.field(Ur, !1) != s.state.field(Ur, !1) || yt(s.startState) != yt(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view)) } buildMarkers(s) { let l = new ar; for (let a of s.viewportLineBlocks) { let c = Hc(s.state, a.from, a.to) ? i : Wc(s.state, a.from, a.to) ? n : null; c && l.add(a.from, a.from, c) } return l.finish() } }), { domEventHandlers: o } = e; return [r, OE({ class: "cm-foldGutter", markers(s) { var l; return ((l = s.plugin(r)) === null || l === void 0 ? void 0 : l.markers) || De.empty }, initialSpacer() { return new jf(e, !1) }, domEventHandlers: Object.assign(Object.assign({}, o), { click: (s, l, a) => { if (o.click && o.click(s, l, a)) return !0; let c = Hc(s.state, l.from, l.to); if (c) return s.dispatch({ effects: Vl.of(c) }), !0; let u = Wc(s.state, l.from, l.to); return u ? (s.dispatch({ effects: Qu.of(u) }), !0) : !1 } }) }), lx()] } const O2 = ie.baseTheme({ ".cm-foldPlaceholder": { backgroundColor: "#eee", border: "1px solid #ddd", color: "#888", borderRadius: ".2em", margin: "0 1px", padding: "0 1px", cursor: "pointer" }, ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" } }); class Nu { constructor(e, n) { this.specs = e; let i; function r(l) { let a = cr.newName(); return (i || (i = Object.create(null)))["." + a] = l, a } const o = typeof n.all == "string" ? n.all : n.all ? r(n.all) : void 0, s = n.scope; this.scope = s instanceof En ? l => l.prop(bo) == s.data : s ? l => l == s : void 0, this.style = YS(e.map(l => ({ tag: l.tag, class: l.class || r(Object.assign({}, l, { tag: null })) })), { all: o }).style, this.module = i ? new cr(i) : null, this.themeType = n.themeType } static define(e, n) { return new Nu(e, n || {}) } } const _d = se.define(), cx = se.define({ combine(t) { return t.length ? [t[0]] : null } }); function qf(t) { let e = t.facet(_d); return e.length ? e : t.facet(cx) } function S2(t, e) { let n = [w2], i; return t instanceof Nu && (t.module && n.push(ie.styleModule.of(t.module)), i = t.themeType), e != null && e.fallback ? n.push(cx.of(t)) : i ? n.push(_d.computeN([ie.darkTheme], r => r.facet(ie.darkTheme) == (i == "dark") ? [t] : [])) : n.push(_d.of(t)), n } class x2 { constructor(e) { this.markCache = Object.create(null), this.tree = yt(e.state), this.decorations = this.buildDeco(e, qf(e.state)), this.decoratedTo = e.viewport.to } update(e) { let n = yt(e.state), i = qf(e.state), r = i != qf(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1); n.length < o.to && !r && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || r) && (this.tree = n, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = o.to) } buildDeco(e, n) { if (!n || !this.tree.length) return de.none; let i = new ar; for (let { from: r, to: o } of e.visibleRanges) FE(this.tree, n, (s, l, a) => { i.add(s, l, this.markCache[a] || (this.markCache[a] = de.mark({ class: a }))) }, r, o); return i.finish() } } const w2 = yr.high(ct.fromClass(x2, { decorations: t => t.decorations })), C2 = Nu.define([{ tag: F.meta, color: "#404740" }, { tag: F.link, textDecoration: "underline" }, { tag: F.heading, textDecoration: "underline", fontWeight: "bold" }, { tag: F.emphasis, fontStyle: "italic" }, { tag: F.strong, fontWeight: "bold" }, { tag: F.strikethrough, textDecoration: "line-through" }, { tag: F.keyword, color: "#708" }, { tag: [F.atom, F.bool, F.url, F.contentSeparator, F.labelName], color: "#219" }, { tag: [F.literal, F.inserted], color: "#164" }, { tag: [F.string, F.deleted], color: "#a11" }, { tag: [F.regexp, F.escape, F.special(F.string)], color: "#e40" }, { tag: F.definition(F.variableName), color: "#00f" }, { tag: F.local(F.variableName), color: "#30a" }, { tag: [F.typeName, F.namespace], color: "#085" }, { tag: F.className, color: "#167" }, { tag: [F.special(F.variableName), F.macroName], color: "#256" }, { tag: F.definition(F.propertyName), color: "#00c" }, { tag: F.comment, color: "#940" }, { tag: F.invalid, color: "#f00" }]), T2 = ie.baseTheme({ "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" }, "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" } }), ux = 1e4, fx = "()[]{}", hx = se.define({ combine(t) { return fi(t, { afterCursor: !0, brackets: fx, maxScanDistance: ux, renderMatch: P2 }) } }), $2 = de.mark({ class: "cm-matchingBracket" }), k2 = de.mark({ class: "cm-nonmatchingBracket" }); function P2(t) { let e = [], n = t.matched ? $2 : k2; return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e } const A2 = bt.define({ create() { return de.none }, update(t, e) { if (!e.docChanged && !e.selection) return t; let n = [], i = e.state.facet(hx); for (let r of e.state.selection.ranges) { if (!r.empty) continue; let o = Jn(e.state, r.head, -1, i) || r.head > 0 && Jn(e.state, r.head - 1, 1, i) || i.afterCursor && (Jn(e.state, r.head, 1, i) || r.head < e.state.doc.length && Jn(e.state, r.head + 1, -1, i)); o && (n = n.concat(i.renderMatch(o, e.state))) } return de.set(n, !0) }, provide: t => ie.decorations.from(t) }), M2 = [A2, T2]; function E2(t = {}) { return [hx.of(t), M2] } const _2 = new $e; function Rd(t, e, n) { let i = t.prop(e < 0 ? $e.openedBy : $e.closedBy); if (i) return i; if (t.name.length == 1) { let r = n.indexOf(t.name); if (r > -1 && r % 2 == (e < 0 ? 1 : 0)) return [n[r + e]] } return null } function Id(t) { let e = t.type.prop(_2); return e ? e(t.node) : t } function Jn(t, e, n, i = {}) { let r = i.maxScanDistance || ux, o = i.brackets || fx, s = yt(t), l = s.resolveInner(e, n); for (let a = l; a; a = a.parent) { let c = Rd(a.type, n, o); if (c && a.from < a.to) { let u = Id(a); if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to)) return R2(t, e, n, a, u, c, o) } } return I2(t, e, n, s, l.type, r, o) } function R2(t, e, n, i, r, o, s) { let l = i.parent, a = { from: r.from, to: r.to }, c = 0, u = l == null ? void 0 : l.cursor(); if (u && (n < 0 ? u.childBefore(i.from) : u.childAfter(i.to))) do if (n < 0 ? u.to <= i.from : u.from >= i.to) { if (c == 0 && o.indexOf(u.type.name) > -1 && u.from < u.to) { let f = Id(u); return { start: a, end: f ? { from: f.from, to: f.to } : void 0, matched: !0 } } else if (Rd(u.type, n, s)) c++; else if (Rd(u.type, -n, s)) { if (c == 0) { let f = Id(u); return { start: a, end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0, matched: !1 } } c-- } } while (n < 0 ? u.prevSibling() : u.nextSibling()); return { start: a, matched: !1 } } function I2(t, e, n, i, r, o, s) { let l = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), a = s.indexOf(l); if (a < 0 || a % 2 == 0 != n > 0) return null; let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), f = 0; for (let h = 0; !u.next().done && h <= o;) { let d = u.value; n < 0 && (h += d.length); let p = e + h * n; for (let g = n > 0 ? 0 : d.length - 1, m = n > 0 ? d.length : -1; g != m; g += n) { let v = s.indexOf(d[g]); if (!(v < 0 || i.resolveInner(p + g, 1).type != r)) if (v % 2 == 0 == n > 0) f++; else { if (f == 1) return { start: c, end: { from: p + g, to: p + g + 1 }, matched: v >> 1 == a >> 1 }; f-- } } n > 0 && (h += d.length) } return u.done ? { start: c, matched: !1 } : null } const D2 = Object.create(null), sv = [Jt.none], lv = [], av = Object.create(null), B2 = Object.create(null); for (let [t, e] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]) B2[t] = L2(D2, e); function Vf(t, e) { lv.indexOf(t) > -1 || (lv.push(t), console.warn(e)) } function L2(t, e) { let n = []; for (let l of e.split(" ")) { let a = []; for (let c of l.split(".")) { let u = t[c] || F[c]; u ? typeof u == "function" ? a.length ? a = a.map(u) : Vf(c, `Modifier ${c} used at start of tag`) : a.length ? Vf(c, `Tag ${c} used as modifier`) : a = Array.isArray(u) ? u : [u] : Vf(c, `Unknown highlighting tag ${c}`) } for (let c of a) n.push(c) } if (!n.length) return 0; let i = e.replace(/ /g, "_"), r = i + " " + n.map(l => l.id), o = av[r]; if (o) return o.id; let s = av[r] = Jt.define({ id: sv.length, name: i, props: [GS({ [i]: n })] }); return sv.push(s), s.id } Ge.RTL, Ge.LTR; const Q2 = t => { let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), i = fg(t.state, n.from); return i.line ? N2(t) : i.block ? W2(t) : !1 }; function ug(t, e) { return ({ state: n, dispatch: i }) => { if (n.readOnly) return !1; let r = t(e, n); return r ? (i(n.update(r)), !0) : !1 } } const N2 = ug(j2, 0), z2 = ug(dx, 0), W2 = ug((t, e) => dx(t, e, F2(e)), 0); function fg(t, e) { let n = t.languageDataAt("commentTokens", e); return n.length ? n[0] : {} } const Cs = 50; function H2(t, { open: e, close: n }, i, r) { let o = t.sliceDoc(i - Cs, i), s = t.sliceDoc(r, r + Cs), l = /\s*$/.exec(o)[0].length, a = /^\s*/.exec(s)[0].length, c = o.length - l; if (o.slice(c - e.length, c) == e && s.slice(a, a + n.length) == n) return { open: { pos: i - l, margin: l && 1 }, close: { pos: r + a, margin: a && 1 } }; let u, f; r - i <= 2 * Cs ? u = f = t.sliceDoc(i, r) : (u = t.sliceDoc(i, i + Cs), f = t.sliceDoc(r - Cs, r)); let h = /^\s*/.exec(u)[0].length, d = /\s*$/.exec(f)[0].length, p = f.length - d - n.length; return u.slice(h, h + e.length) == e && f.slice(p, p + n.length) == n ? { open: { pos: i + h + e.length, margin: /\s/.test(u.charAt(h + e.length)) ? 1 : 0 }, close: { pos: r - d - n.length, margin: /\s/.test(f.charAt(p - 1)) ? 1 : 0 } } : null } function F2(t) { let e = []; for (let n of t.selection.ranges) { let i = t.doc.lineAt(n.from), r = n.to <= i.to ? i : t.doc.lineAt(n.to), o = e.length - 1; o >= 0 && e[o].to > i.from ? e[o].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to }) } return e } function dx(t, e, n = e.selection.ranges) { let i = n.map(o => fg(e, o.from).block); if (!i.every(o => o)) return null; let r = n.map((o, s) => H2(e, i[s], o.from, o.to)); if (t != 2 && !r.every(o => o)) return { changes: e.changes(n.map((o, s) => r[s] ? [] : [{ from: o.from, insert: i[s].open + " " }, { from: o.to, insert: " " + i[s].close }])) }; if (t != 1 && r.some(o => o)) { let o = []; for (let s = 0, l; s < r.length; s++)if (l = r[s]) { let a = i[s], { open: c, close: u } = l; o.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + a.close.length }) } return { changes: o } } return null } function j2(t, e, n = e.selection.ranges) { let i = [], r = -1; for (let { from: o, to: s } of n) { let l = i.length, a = 1e9, c = fg(e, o).line; if (c) { for (let u = o; u <= s;) { let f = e.doc.lineAt(u); if (f.from > r && (o == s || s > f.from)) { r = f.from; let h = /^\s*/.exec(f.text)[0].length, d = h == f.length, p = f.text.slice(h, h + c.length) == c ? h : -1; h < f.text.length && h < a && (a = h), i.push({ line: f, comment: p, token: c, indent: h, empty: d, single: !1 }) } u = f.to + 1 } if (a < 1e9) for (let u = l; u < i.length; u++)i[u].indent < i[u].line.text.length && (i[u].indent = a); i.length == l + 1 && (i[l].single = !0) } } if (t != 2 && i.some(o => o.comment < 0 && (!o.empty || o.single))) { let o = []; for (let { line: l, token: a, indent: c, empty: u, single: f } of i) (f || !u) && o.push({ from: l.from + c, insert: a + " " }); let s = e.changes(o); return { changes: s, selection: e.selection.map(s, 1) } } else if (t != 1 && i.some(o => o.comment >= 0)) { let o = []; for (let { line: s, comment: l, token: a } of i) if (l >= 0) { let c = s.from + l, u = c + a.length; s.text[u - s.from] == " " && u++, o.push({ from: c, to: u }) } return { changes: o } } return null } const Dd = Ri.define(), q2 = Ri.define(), V2 = se.define(), px = se.define({ combine(t) { return fi(t, { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, n) => n }, { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (e, n) => (i, r) => e(i, r) || n(i, r) }) } }), gx = bt.define({ create() { return ei.empty }, update(t, e) { let n = e.state.facet(px), i = e.annotation(Dd); if (i) { let a = Yt.fromTransaction(e, i.selection), c = i.side, u = c == 0 ? t.undone : t.done; return a ? u = Fc(u, u.length, n.minDepth, a) : u = yx(u, e.startState.selection), new ei(c == 0 ? i.rest : u, c == 0 ? u : i.rest) } let r = e.annotation(q2); if ((r == "full" || r == "before") && (t = t.isolate()), e.annotation(lt.addToHistory) === !1) return e.changes.empty ? t : t.addMapping(e.changes.desc); let o = Yt.fromTransaction(e), s = e.annotation(lt.time), l = e.annotation(lt.userEvent); return o ? t = t.addChanges(o, s, l, n, e) : e.selection && (t = t.addSelection(e.startState.selection, s, l, n.newGroupDelay)), (r == "full" || r == "after") && (t = t.isolate()), t }, toJSON(t) { return { done: t.done.map(e => e.toJSON()), undone: t.undone.map(e => e.toJSON()) } }, fromJSON(t) { return new ei(t.done.map(Yt.fromJSON), t.undone.map(Yt.fromJSON)) } }); function X2(t = {}) { return [gx, px.of(t), ie.domEventHandlers({ beforeinput(e, n) { let i = e.inputType == "historyUndo" ? mx : e.inputType == "historyRedo" ? Bd : null; return i ? (e.preventDefault(), i(n)) : !1 } })] } function zu(t, e) { return function ({ state: n, dispatch: i }) { if (!e && n.readOnly) return !1; let r = n.field(gx, !1); if (!r) return !1; let o = r.pop(t, n, e); return o ? (i(o), !0) : !1 } } const mx = zu(0, !1), Bd = zu(1, !1), U2 = zu(0, !0), G2 = zu(1, !0); class Yt { constructor(e, n, i, r, o) { this.changes = e, this.effects = n, this.mapped = i, this.startSelection = r, this.selectionsAfter = o } setSelAfter(e) { return new Yt(this.changes, this.effects, this.mapped, this.startSelection, e) } toJSON() { var e, n, i; return { changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(), mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(), startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(), selectionsAfter: this.selectionsAfter.map(r => r.toJSON()) } } static fromJSON(e) { return new Yt(e.changes && ut.fromJSON(e.changes), [], e.mapped && ni.fromJSON(e.mapped), e.startSelection && z.fromJSON(e.startSelection), e.selectionsAfter.map(z.fromJSON)) } static fromTransaction(e, n) { let i = On; for (let r of e.startState.facet(V2)) { let o = r(e); o.length && (i = i.concat(o)) } return !i.length && e.changes.empty ? null : new Yt(e.changes.invert(e.startState.doc), i, void 0, n || e.startState.selection, On) } static selection(e) { return new Yt(void 0, On, void 0, void 0, e) } } function Fc(t, e, n, i) { let r = e + 1 > n + 20 ? e - n - 1 : 0, o = t.slice(r, e); return o.push(i), o } function K2(t, e) { let n = [], i = !1; return t.iterChangedRanges((r, o) => n.push(r, o)), e.iterChangedRanges((r, o, s, l) => { for (let a = 0; a < n.length;) { let c = n[a++], u = n[a++]; l >= c && s <= u && (i = !0) } }), i } function Y2(t, e) { return t.ranges.length == e.ranges.length && t.ranges.filter((n, i) => n.empty != e.ranges[i].empty).length === 0 } function vx(t, e) { return t.length ? e.length ? t.concat(e) : t : e } const On = [], Z2 = 200; function yx(t, e) { if (t.length) { let n = t[t.length - 1], i = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - Z2)); return i.length && i[i.length - 1].eq(e) ? t : (i.push(e), Fc(t, t.length - 1, 1e9, n.setSelAfter(i))) } else return [Yt.selection([e])] } function J2(t) { let e = t[t.length - 1], n = t.slice(); return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n } function Xf(t, e) { if (!t.length) return t; let n = t.length, i = On; for (; n;) { let r = e_(t[n - 1], e, i); if (r.changes && !r.changes.empty || r.effects.length) { let o = t.slice(0, n); return o[n - 1] = r, o } else e = r.mapped, n--, i = r.selectionsAfter } return i.length ? [Yt.selection(i)] : On } function e_(t, e, n) { let i = vx(t.selectionsAfter.length ? t.selectionsAfter.map(l => l.map(e)) : On, n); if (!t.changes) return Yt.selection(i); let r = t.changes.map(e), o = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(o) : o; return new Yt(r, Ce.mapEffects(t.effects, e), s, t.startSelection.map(o), i) } const t_ = /^(input\.type|delete)($|\.)/; class ei { constructor(e, n, i = 0, r = void 0) { this.done = e, this.undone = n, this.prevTime = i, this.prevUserEvent = r } isolate() { return this.prevTime ? new ei(this.done, this.undone) : this } addChanges(e, n, i, r, o) { let s = this.done, l = s[s.length - 1]; return l && l.changes && !l.changes.empty && e.changes && (!i || t_.test(i)) && (!l.selectionsAfter.length && n - this.prevTime < r.newGroupDelay && r.joinToEvent(o, K2(l.changes, e.changes)) || i == "input.type.compose") ? s = Fc(s, s.length - 1, r.minDepth, new Yt(e.changes.compose(l.changes), vx(Ce.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, On)) : s = Fc(s, s.length, r.minDepth, e), new ei(s, On, n, i) } addSelection(e, n, i, r) { let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : On; return o.length > 0 && n - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && Y2(o[o.length - 1], e) ? this : new ei(yx(this.done, e), this.undone, n, i) } addMapping(e) { return new ei(Xf(this.done, e), Xf(this.undone, e), this.prevTime, this.prevUserEvent) } pop(e, n, i) { let r = e == 0 ? this.done : this.undone; if (r.length == 0) return null; let o = r[r.length - 1], s = o.selectionsAfter[0] || n.selection; if (i && o.selectionsAfter.length) return n.update({ selection: o.selectionsAfter[o.selectionsAfter.length - 1], annotations: Dd.of({ side: e, rest: J2(r), selection: s }), userEvent: e == 0 ? "select.undo" : "select.redo", scrollIntoView: !0 }); if (o.changes) { let l = r.length == 1 ? On : r.slice(0, r.length - 1); return o.mapped && (l = Xf(l, o.mapped)), n.update({ changes: o.changes, selection: o.startSelection, effects: o.effects, annotations: Dd.of({ side: e, rest: l, selection: s }), filter: !1, userEvent: e == 0 ? "undo" : "redo", scrollIntoView: !0 }) } else return null } } ei.empty = new ei(On, On); const n_ = [{ key: "Mod-z", run: mx, preventDefault: !0 }, { key: "Mod-y", mac: "Mod-Shift-z", run: Bd, preventDefault: !0 }, { linux: "Ctrl-Shift-z", run: Bd, preventDefault: !0 }, { key: "Mod-u", run: U2, preventDefault: !0 }, { key: "Alt-u", mac: "Mod-Shift-u", run: G2, preventDefault: !0 }]; function ls(t, e) { return z.create(t.ranges.map(e), t.mainIndex) } function hi(t, e) { return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" }) } function Nn({ state: t, dispatch: e }, n) { let i = ls(t.selection, n); return i.eq(t.selection, !0) ? !1 : (e(hi(t, i)), !0) } function Wu(t, e) { return z.cursor(e ? t.to : t.from) } function bx(t, e) { return Nn(t, n => n.empty ? t.moveByChar(n, e) : Wu(n, e)) } function It(t) { return t.textDirectionAt(t.state.selection.main.head) == Ge.LTR } const Ox = t => bx(t, !It(t)), Sx = t => bx(t, It(t)); function xx(t, e) { return Nn(t, n => n.empty ? t.moveByGroup(n, e) : Wu(n, e)) } const i_ = t => xx(t, !It(t)), r_ = t => xx(t, It(t)); function o_(t, e, n) { if (e.type.prop(n)) return !0; let i = e.to - e.from; return i && (i > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild } function Hu(t, e, n) { let i = yt(t).resolveInner(e.head), r = n ? $e.closedBy : $e.openedBy; for (let a = e.head; ;) { let c = n ? i.childAfter(a) : i.childBefore(a); if (!c) break; o_(t, c, r) ? i = c : a = n ? c.to : c.from } let o = i.type.prop(r), s, l; return o && (s = n ? Jn(t, i.from, 1) : Jn(t, i.to, -1)) && s.matched ? l = n ? s.end.to : s.end.from : l = n ? i.to : i.from, z.cursor(l, n ? -1 : 1) } const s_ = t => Nn(t, e => Hu(t.state, e, !It(t))), l_ = t => Nn(t, e => Hu(t.state, e, It(t))); function wx(t, e) { return Nn(t, n => { if (!n.empty) return Wu(n, e); let i = t.moveVertically(n, e); return i.head != n.head ? i : t.moveToLineBoundary(n, e) }) } const Cx = t => wx(t, !1), Tx = t => wx(t, !0); function $x(t) { let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, i = 0, r; if (e) { for (let o of t.state.facet(ie.scrollMargins)) { let s = o(t); s != null && s.top && (n = Math.max(s == null ? void 0 : s.top, n)), s != null && s.bottom && (i = Math.max(s == null ? void 0 : s.bottom, i)) } r = t.scrollDOM.clientHeight - n - i } else r = (t.dom.ownerDocument.defaultView || window).innerHeight; return { marginTop: n, marginBottom: i, selfScroll: e, height: Math.max(t.defaultLineHeight, r - 5) } } function kx(t, e) { let n = $x(t), { state: i } = t, r = ls(i.selection, s => s.empty ? t.moveVertically(s, e, n.height) : Wu(s, e)); if (r.eq(i.selection)) return !1; let o; if (n.selfScroll) { let s = t.coordsAtPos(i.selection.main.head), l = t.scrollDOM.getBoundingClientRect(), a = l.top + n.marginTop, c = l.bottom - n.marginBottom; s && s.top > a && s.bottom < c && (o = ie.scrollIntoView(r.main.head, { y: "start", yMargin: s.top - a })) } return t.dispatch(hi(i, r), { effects: o }), !0 } const cv = t => kx(t, !1), Ld = t => kx(t, !0); function br(t, e, n) { let i = t.lineBlockAt(e.head), r = t.moveToLineBoundary(e, n); if (r.head == e.head && r.head != (n ? i.to : i.from) && (r = t.moveToLineBoundary(e, n, !1)), !n && r.head == i.from && i.length) { let o = /^\s*/.exec(t.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length; o && e.head != i.from + o && (r = z.cursor(i.from + o)) } return r } const a_ = t => Nn(t, e => br(t, e, !0)), c_ = t => Nn(t, e => br(t, e, !1)), u_ = t => Nn(t, e => br(t, e, !It(t))), f_ = t => Nn(t, e => br(t, e, It(t))), h_ = t => Nn(t, e => z.cursor(t.lineBlockAt(e.head).from, 1)), d_ = t => Nn(t, e => z.cursor(t.lineBlockAt(e.head).to, -1)); function p_(t, e, n) { let i = !1, r = ls(t.selection, o => { let s = Jn(t, o.head, -1) || Jn(t, o.head, 1) || o.head > 0 && Jn(t, o.head - 1, 1) || o.head < t.doc.length && Jn(t, o.head + 1, -1); if (!s || !s.end) return o; i = !0; let l = s.start.from == o.head ? s.end.to : s.end.from; return n ? z.range(o.anchor, l) : z.cursor(l) }); return i ? (e(hi(t, r)), !0) : !1 } const g_ = ({ state: t, dispatch: e }) => p_(t, e, !1); function $n(t, e) { let n = ls(t.state.selection, i => { let r = e(i); return z.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0) }); return n.eq(t.state.selection) ? !1 : (t.dispatch(hi(t.state, n)), !0) } function Px(t, e) { return $n(t, n => t.moveByChar(n, e)) } const Ax = t => Px(t, !It(t)), Mx = t => Px(t, It(t)); function Ex(t, e) { return $n(t, n => t.moveByGroup(n, e)) } const m_ = t => Ex(t, !It(t)), v_ = t => Ex(t, It(t)), y_ = t => $n(t, e => Hu(t.state, e, !It(t))), b_ = t => $n(t, e => Hu(t.state, e, It(t))); function _x(t, e) { return $n(t, n => t.moveVertically(n, e)) } const Rx = t => _x(t, !1), Ix = t => _x(t, !0); function Dx(t, e) { return $n(t, n => t.moveVertically(n, e, $x(t).height)) } const uv = t => Dx(t, !1), fv = t => Dx(t, !0), O_ = t => $n(t, e => br(t, e, !0)), S_ = t => $n(t, e => br(t, e, !1)), x_ = t => $n(t, e => br(t, e, !It(t))), w_ = t => $n(t, e => br(t, e, It(t))), C_ = t => $n(t, e => z.cursor(t.lineBlockAt(e.head).from)), T_ = t => $n(t, e => z.cursor(t.lineBlockAt(e.head).to)), hv = ({ state: t, dispatch: e }) => (e(hi(t, { anchor: 0 })), !0), dv = ({ state: t, dispatch: e }) => (e(hi(t, { anchor: t.doc.length })), !0), pv = ({ state: t, dispatch: e }) => (e(hi(t, { anchor: t.selection.main.anchor, head: 0 })), !0), gv = ({ state: t, dispatch: e }) => (e(hi(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), $_ = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), k_ = ({ state: t, dispatch: e }) => { let n = Fu(t).map(({ from: i, to: r }) => z.range(i, Math.min(r + 1, t.doc.length))); return e(t.update({ selection: z.create(n), userEvent: "select" })), !0 }, P_ = ({ state: t, dispatch: e }) => { let n = ls(t.selection, i => { let r = yt(t), o = r.resolveStack(i.from, 1); if (i.empty) { let s = r.resolveStack(i.from, -1); s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s) } for (let s = o; s; s = s.next) { let { node: l } = s; if ((l.from < i.from && l.to >= i.to || l.to > i.to && l.from <= i.from) && s.next) return z.range(l.to, l.from) } return i }); return n.eq(t.selection) ? !1 : (e(hi(t, n)), !0) }, A_ = ({ state: t, dispatch: e }) => { let n = t.selection, i = null; return n.ranges.length > 1 ? i = z.create([n.main]) : n.main.empty || (i = z.create([z.cursor(n.main.head)])), i ? (e(hi(t, i)), !0) : !1 }; function Xl(t, e) { if (t.state.readOnly) return !1; let n = "delete.selection", { state: i } = t, r = i.changeByRange(o => { let { from: s, to: l } = o; if (s == l) { let a = e(o); a < s ? (n = "delete.backward", a = $a(t, a, !1)) : a > s && (n = "delete.forward", a = $a(t, a, !0)), s = Math.min(s, a), l = Math.max(l, a) } else s = $a(t, s, !1), l = $a(t, l, !0); return s == l ? { range: o } : { changes: { from: s, to: l }, range: z.cursor(s, s < o.head ? -1 : 1) } }); return r.changes.empty ? !1 : (t.dispatch(i.update(r, { scrollIntoView: !0, userEvent: n, effects: n == "delete.selection" ? ie.announce.of(i.phrase("Selection deleted")) : void 0 })), !0) } function $a(t, e, n) { if (t instanceof ie) for (let i of t.state.facet(ie.atomicRanges).map(r => r(t))) i.between(e, e, (r, o) => { r < e && o > e && (e = n ? o : r) }); return e } const Bx = (t, e, n) => Xl(t, i => { let r = i.from, { state: o } = t, s = o.doc.lineAt(r), l, a; if (n && !e && r > s.from && r < s.from + 200 && !/[^ \t]/.test(l = s.text.slice(0, r - s.from))) { if (l[l.length - 1] == "	") return r - 1; let c = ss(l, o.tabSize), u = c % zc(o) || zc(o); for (let f = 0; f < u && l[l.length - 1 - f] == " "; f++)r--; a = r } else a = kt(s.text, r - s.from, e, e) + s.from, a == r && s.number != (e ? o.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(a - s.from, r - s.from)) && (a = kt(s.text, a - s.from, !1, !1) + s.from); return a }), Qd = t => Bx(t, !1, !0), Lx = t => Bx(t, !0, !1), Qx = (t, e) => Xl(t, n => { let i = n.head, { state: r } = t, o = r.doc.lineAt(i), s = r.charCategorizer(i); for (let l = null; ;) { if (i == (e ? o.to : o.from)) { i == n.head && o.number != (e ? r.doc.lines : 1) && (i += e ? 1 : -1); break } let a = kt(o.text, i - o.from, e) + o.from, c = o.text.slice(Math.min(i, a) - o.from, Math.max(i, a) - o.from), u = s(c); if (l != null && u != l) break; (c != " " || i != n.head) && (l = u), i = a } return i }), Nx = t => Qx(t, !1), M_ = t => Qx(t, !0), E_ = t => Xl(t, e => { let n = t.lineBlockAt(e.head).to; return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1) }), __ = t => Xl(t, e => { let n = t.moveToLineBoundary(e, !1).head; return e.head > n ? n : Math.max(0, e.head - 1) }), R_ = t => Xl(t, e => { let n = t.moveToLineBoundary(e, !0).head; return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1) }), I_ = ({ state: t, dispatch: e }) => { if (t.readOnly) return !1; let n = t.changeByRange(i => ({ changes: { from: i.from, to: i.to, insert: Be.of(["", ""]) }, range: z.cursor(i.from) })); return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0 }, D_ = ({ state: t, dispatch: e }) => { if (t.readOnly) return !1; let n = t.changeByRange(i => { if (!i.empty || i.from == 0 || i.from == t.doc.length) return { range: i }; let r = i.from, o = t.doc.lineAt(r), s = r == o.from ? r - 1 : kt(o.text, r - o.from, !1) + o.from, l = r == o.to ? r + 1 : kt(o.text, r - o.from, !0) + o.from; return { changes: { from: s, to: l, insert: t.doc.slice(r, l).append(t.doc.slice(s, r)) }, range: z.cursor(l) } }); return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0) }; function Fu(t) { let e = [], n = -1; for (let i of t.selection.ranges) { let r = t.doc.lineAt(i.from), o = t.doc.lineAt(i.to); if (!i.empty && i.to == o.from && (o = t.doc.lineAt(i.to - 1)), n >= r.number) { let s = e[e.length - 1]; s.to = o.to, s.ranges.push(i) } else e.push({ from: r.from, to: o.to, ranges: [i] }); n = o.number + 1 } return e } function zx(t, e, n) { if (t.readOnly) return !1; let i = [], r = []; for (let o of Fu(t)) { if (n ? o.to == t.doc.length : o.from == 0) continue; let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1), l = s.length + 1; if (n) { i.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t.lineBreak }); for (let a of o.ranges) r.push(z.range(Math.min(t.doc.length, a.anchor + l), Math.min(t.doc.length, a.head + l))) } else { i.push({ from: s.from, to: o.from }, { from: o.to, insert: t.lineBreak + s.text }); for (let a of o.ranges) r.push(z.range(a.anchor - l, a.head - l)) } } return i.length ? (e(t.update({ changes: i, scrollIntoView: !0, selection: z.create(r, t.selection.mainIndex), userEvent: "move.line" })), !0) : !1 } const B_ = ({ state: t, dispatch: e }) => zx(t, e, !1), L_ = ({ state: t, dispatch: e }) => zx(t, e, !0); function Wx(t, e, n) { if (t.readOnly) return !1; let i = []; for (let r of Fu(t)) n ? i.push({ from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak }) : i.push({ from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) }); return e(t.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0 } const Q_ = ({ state: t, dispatch: e }) => Wx(t, e, !1), N_ = ({ state: t, dispatch: e }) => Wx(t, e, !0), z_ = t => { if (t.state.readOnly) return !1; let { state: e } = t, n = e.changes(Fu(e).map(({ from: r, to: o }) => (r > 0 ? r-- : o < e.doc.length && o++, { from: r, to: o }))), i = ls(e.selection, r => { let o; if (t.lineWrapping) { let s = t.lineBlockAt(r.head), l = t.coordsAtPos(r.head, r.assoc || 1); l && (o = s.bottom + t.documentTop - l.bottom + t.defaultLineHeight / 2) } return t.moveVertically(r, !0, o) }).map(n); return t.dispatch({ changes: n, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0 }; function W_(t, e) { if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e }; let n = yt(t).resolveInner(e), i = n.childBefore(e), r = n.childAfter(e), o; return i && r && i.to <= e && r.from >= e && (o = i.type.prop($e.closedBy)) && o.indexOf(r.name) > -1 && t.doc.lineAt(i.to).from == t.doc.lineAt(r.from).from && !/\S/.test(t.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null } const mv = Hx(!1), H_ = Hx(!0); function Hx(t) { return ({ state: e, dispatch: n }) => { if (e.readOnly) return !1; let i = e.changeByRange(r => { let { from: o, to: s } = r, l = e.doc.lineAt(o), a = !t && o == s && W_(e, o); t && (o = s = (s <= l.to ? l : e.doc.lineAt(s)).to); let c = new Lu(e, { simulateBreak: o, simulateDoubleBreak: !!a }), u = lg(c, o); for (u == null && (u = ss(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < l.to && /\s/.test(l.text[s - l.from]);)s++; a ? { from: o, to: s } = a : o > l.from && o < l.from + 100 && !/\S/.test(l.text.slice(0, o)) && (o = l.from); let f = ["", xl(e, u)]; return a && f.push(xl(e, c.lineIndent(l.from, -1))), { changes: { from: o, to: s, insert: Be.of(f) }, range: z.cursor(o + 1 + f[1].length) } }); return n(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0 } } function hg(t, e) { let n = -1; return t.changeByRange(i => { let r = []; for (let s = i.from; s <= i.to;) { let l = t.doc.lineAt(s); l.number > n && (i.empty || i.to > l.from) && (e(l, r, i), n = l.number), s = l.to + 1 } let o = t.changes(r); return { changes: r, range: z.range(o.mapPos(i.anchor, 1), o.mapPos(i.head, 1)) } }) } const F_ = ({ state: t, dispatch: e }) => { if (t.readOnly) return !1; let n = Object.create(null), i = new Lu(t, { overrideIndentation: o => { let s = n[o]; return s ?? -1 } }), r = hg(t, (o, s, l) => { let a = lg(i, o.from); if (a == null) return; /\S/.test(o.text) || (a = 0); let c = /^\s*/.exec(o.text)[0], u = xl(t, a); (c != u || l.from < o.from + c.length) && (n[o.from] = a, s.push({ from: o.from, to: o.from + c.length, insert: u })) }); return r.changes.empty || e(t.update(r, { userEvent: "indent" })), !0 }, j_ = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(hg(t, (n, i) => { i.push({ from: n.from, insert: t.facet(Bu) }) }), { userEvent: "input.indent" })), !0), q_ = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(hg(t, (n, i) => { let r = /^\s*/.exec(n.text)[0]; if (!r) return; let o = ss(r, t.tabSize), s = 0, l = xl(t, Math.max(0, o - zc(t))); for (; s < r.length && s < l.length && r.charCodeAt(s) == l.charCodeAt(s);)s++; i.push({ from: n.from + s, to: n.from + r.length, insert: l.slice(s) }) }), { userEvent: "delete.dedent" })), !0), V_ = t => (t.setTabFocusMode(), !0), X_ = [{ key: "Ctrl-b", run: Ox, shift: Ax, preventDefault: !0 }, { key: "Ctrl-f", run: Sx, shift: Mx }, { key: "Ctrl-p", run: Cx, shift: Rx }, { key: "Ctrl-n", run: Tx, shift: Ix }, { key: "Ctrl-a", run: h_, shift: C_ }, { key: "Ctrl-e", run: d_, shift: T_ }, { key: "Ctrl-d", run: Lx }, { key: "Ctrl-h", run: Qd }, { key: "Ctrl-k", run: E_ }, { key: "Ctrl-Alt-h", run: Nx }, { key: "Ctrl-o", run: I_ }, { key: "Ctrl-t", run: D_ }, { key: "Ctrl-v", run: Ld }], U_ = [{ key: "ArrowLeft", run: Ox, shift: Ax, preventDefault: !0 }, { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: i_, shift: m_, preventDefault: !0 }, { mac: "Cmd-ArrowLeft", run: u_, shift: x_, preventDefault: !0 }, { key: "ArrowRight", run: Sx, shift: Mx, preventDefault: !0 }, { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: r_, shift: v_, preventDefault: !0 }, { mac: "Cmd-ArrowRight", run: f_, shift: w_, preventDefault: !0 }, { key: "ArrowUp", run: Cx, shift: Rx, preventDefault: !0 }, { mac: "Cmd-ArrowUp", run: hv, shift: pv }, { mac: "Ctrl-ArrowUp", run: cv, shift: uv }, { key: "ArrowDown", run: Tx, shift: Ix, preventDefault: !0 }, { mac: "Cmd-ArrowDown", run: dv, shift: gv }, { mac: "Ctrl-ArrowDown", run: Ld, shift: fv }, { key: "PageUp", run: cv, shift: uv }, { key: "PageDown", run: Ld, shift: fv }, { key: "Home", run: c_, shift: S_, preventDefault: !0 }, { key: "Mod-Home", run: hv, shift: pv }, { key: "End", run: a_, shift: O_, preventDefault: !0 }, { key: "Mod-End", run: dv, shift: gv }, { key: "Enter", run: mv, shift: mv }, { key: "Mod-a", run: $_ }, { key: "Backspace", run: Qd, shift: Qd }, { key: "Delete", run: Lx }, { key: "Mod-Backspace", mac: "Alt-Backspace", run: Nx }, { key: "Mod-Delete", mac: "Alt-Delete", run: M_ }, { mac: "Mod-Backspace", run: __ }, { mac: "Mod-Delete", run: R_ }].concat(X_.map(t => ({ mac: t.key, run: t.run, shift: t.shift }))), G_ = [{ key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: s_, shift: y_ }, { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: l_, shift: b_ }, { key: "Alt-ArrowUp", run: B_ }, { key: "Shift-Alt-ArrowUp", run: Q_ }, { key: "Alt-ArrowDown", run: L_ }, { key: "Shift-Alt-ArrowDown", run: N_ }, { key: "Escape", run: A_ }, { key: "Mod-Enter", run: H_ }, { key: "Alt-l", mac: "Ctrl-l", run: k_ }, { key: "Mod-i", run: P_, preventDefault: !0 }, { key: "Mod-[", run: q_ }, { key: "Mod-]", run: j_ }, { key: "Mod-Alt-\\", run: F_ }, { key: "Shift-Mod-k", run: z_ }, { key: "Shift-Mod-\\", run: g_ }, { key: "Mod-/", run: Q2 }, { key: "Alt-A", run: z2 }, { key: "Ctrl-m", mac: "Shift-Alt-m", run: V_ }].concat(U_); function Ve() { var t = arguments[0]; typeof t == "string" && (t = document.createElement(t)); var e = 1, n = arguments[1]; if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) { for (var i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { var r = n[i]; typeof r == "string" ? t.setAttribute(i, r) : r != null && (t[i] = r) } e++ } for (; e < arguments.length; e++)Fx(t, arguments[e]); return t } function Fx(t, e) { if (typeof e == "string") t.appendChild(document.createTextNode(e)); else if (e != null) if (e.nodeType != null) t.appendChild(e); else if (Array.isArray(e)) for (var n = 0; n < e.length; n++)Fx(t, e[n]); else throw new RangeError("Unsupported child node: " + e) } const vv = typeof String.prototype.normalize == "function" ? t => t.normalize("NFKD") : t => t; class Vo { constructor(e, n, i = 0, r = e.length, o, s) { this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, r), this.bufferStart = i, this.normalize = o ? l => o(vv(l)) : vv, this.query = this.normalize(n) } peek() { if (this.bufferPos == this.buffer.length) { if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done) return -1; this.bufferPos = 0, this.buffer = this.iter.value } return xt(this.buffer, this.bufferPos) } next() { for (; this.matches.length;)this.matches.pop(); return this.nextOverlapping() } nextOverlapping() { for (; ;) { let e = this.peek(); if (e < 0) return this.done = !0, this; let n = Hp(e), i = this.bufferStart + this.bufferPos; this.bufferPos += bn(e); let r = this.normalize(n); for (let o = 0, s = i; ; o++) { let l = r.charCodeAt(o), a = this.match(l, s, this.bufferPos + this.bufferStart); if (o == r.length - 1) { if (a) return this.value = a, this; break } s == i && o < n.length && n.charCodeAt(o) == l && s++ } } } match(e, n, i) { let r = null; for (let o = 0; o < this.matches.length; o += 2) { let s = this.matches[o], l = !1; this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? r = { from: this.matches[o + 1], to: i } : (this.matches[o]++, l = !0)), l || (this.matches.splice(o, 2), o -= 2) } return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: n, to: i } : this.matches.push(1, n)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r } } typeof Symbol < "u" && (Vo.prototype[Symbol.iterator] = function () { return this }); const jx = { from: -1, to: -1, match: /.*/.exec("") }, dg = "gm" + (/x/.unicode == null ? "" : "u"); class qx { constructor(e, n, i, r = 0, o = e.length) { if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = jx, /\\[sWDnr]|\n|\r|\[\^/.test(n)) return new Vx(e, n, i, r, o); this.re = new RegExp(n, dg + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter(); let s = e.lineAt(r); this.curLineStart = s.from, this.matchPos = jc(e, r), this.getLine(this.curLineStart) } getLine(e) { this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next()) } nextLine() { this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0) } next() { for (let e = this.matchPos - this.curLineStart; ;) { this.re.lastIndex = e; let n = this.matchPos <= this.to && this.re.exec(this.curLine); if (n) { let i = this.curLineStart + n.index, r = i + n[0].length; if (this.matchPos = jc(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, n))) return this.value = { from: i, to: r, match: n }, this; e = this.matchPos - this.curLineStart } else if (this.curLineStart + this.curLine.length < this.to) this.nextLine(), e = 0; else return this.done = !0, this } } } const Uf = new WeakMap; class _o { constructor(e, n) { this.from = e, this.text = n } get to() { return this.from + this.text.length } static get(e, n, i) { let r = Uf.get(e); if (!r || r.from >= i || r.to <= n) { let l = new _o(n, e.sliceString(n, i)); return Uf.set(e, l), l } if (r.from == n && r.to == i) return r; let { text: o, from: s } = r; return s > n && (o = e.sliceString(n, s) + o, s = n), r.to < i && (o += e.sliceString(r.to, i)), Uf.set(e, new _o(s, o)), new _o(n, o.slice(n - s, i - s)) } } class Vx { constructor(e, n, i, r, o) { this.text = e, this.to = o, this.done = !1, this.value = jx, this.matchPos = jc(e, r), this.re = new RegExp(n, dg + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = _o.get(e, r, this.chunkEnd(r + 5e3)) } chunkEnd(e) { return e >= this.to ? this.to : this.text.lineAt(e).to } next() { for (; ;) { let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text); if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) { let i = this.flat.from + n.index, r = i + n[0].length; if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, r, n))) return this.value = { from: i, to: r, match: n }, this.matchPos = jc(this.text, r + (i == r ? 1 : 0)), this } if (this.flat.to == this.to) return this.done = !0, this; this.flat = _o.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2)) } } } typeof Symbol < "u" && (qx.prototype[Symbol.iterator] = Vx.prototype[Symbol.iterator] = function () { return this }); function K_(t) { try { return new RegExp(t, dg), !0 } catch { return !1 } } function jc(t, e) { if (e >= t.length) return e; let n = t.lineAt(e), i; for (; e < n.to && (i = n.text.charCodeAt(e - n.from)) >= 56320 && i < 57344;)e++; return e } function Nd(t) { let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Ve("input", { class: "cm-textfield", name: "line", value: e }), i = Ve("form", { class: "cm-gotoLine", onkeydown: o => { o.keyCode == 27 ? (o.preventDefault(), t.dispatch({ effects: qc.of(!1) }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), r()) }, onsubmit: o => { o.preventDefault(), r() } }, Ve("label", t.state.phrase("Go to line"), ": ", n), " ", Ve("button", { class: "cm-button", type: "submit" }, t.state.phrase("go"))); function r() { let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value); if (!o) return; let { state: s } = t, l = s.doc.lineAt(s.selection.main.head), [, a, c, u, f] = o, h = u ? +u.slice(1) : 0, d = c ? +c : l.number; if (c && f) { let m = d / 100; a && (m = m * (a == "-" ? -1 : 1) + l.number / s.doc.lines), d = Math.round(s.doc.lines * m) } else c && a && (d = d * (a == "-" ? -1 : 1) + l.number); let p = s.doc.line(Math.max(1, Math.min(s.doc.lines, d))), g = z.cursor(p.from + Math.max(0, Math.min(h, p.length))); t.dispatch({ effects: [qc.of(!1), ie.scrollIntoView(g.from, { y: "center" })], selection: g }), t.focus() } return { dom: i } } const qc = Ce.define(), yv = bt.define({ create() { return !0 }, update(t, e) { for (let n of e.effects) n.is(qc) && (t = n.value); return t }, provide: t => Ol.from(t, e => e ? Nd : null) }), Y_ = t => { let e = bl(t, Nd); if (!e) { let n = [qc.of(!0)]; t.state.field(yv, !1) == null && n.push(Ce.appendConfig.of([yv, Z_])), t.dispatch({ effects: n }), e = bl(t, Nd) } return e && e.dom.querySelector("input").select(), !0 }, Z_ = ie.baseTheme({ ".cm-panel.cm-gotoLine": { padding: "2px 6px 4px", "& label": { fontSize: "80%" } } }), J_ = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 }, Xx = se.define({ combine(t) { return fi(t, J_, { highlightWordAroundCursor: (e, n) => e || n, minSelectionLength: Math.min, maxMatches: Math.min }) } }); function eR(t) { let e = [oR, rR]; return t && e.push(Xx.of(t)), e } const tR = de.mark({ class: "cm-selectionMatch" }), nR = de.mark({ class: "cm-selectionMatch cm-selectionMatch-main" }); function bv(t, e, n, i) { return (n == 0 || t(e.sliceDoc(n - 1, n)) != Ze.Word) && (i == e.doc.length || t(e.sliceDoc(i, i + 1)) != Ze.Word) } function iR(t, e, n, i) { return t(e.sliceDoc(n, n + 1)) == Ze.Word && t(e.sliceDoc(i - 1, i)) == Ze.Word } const rR = ct.fromClass(class { constructor(t) { this.decorations = this.getDeco(t) } update(t) { (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view)) } getDeco(t) { let e = t.state.facet(Xx), { state: n } = t, i = n.selection; if (i.ranges.length > 1) return de.none; let r = i.main, o, s = null; if (r.empty) { if (!e.highlightWordAroundCursor) return de.none; let a = n.wordAt(r.head); if (!a) return de.none; s = n.charCategorizer(r.head), o = n.sliceDoc(a.from, a.to) } else { let a = r.to - r.from; if (a < e.minSelectionLength || a > 200) return de.none; if (e.wholeWords) { if (o = n.sliceDoc(r.from, r.to), s = n.charCategorizer(r.head), !(bv(s, n, r.from, r.to) && iR(s, n, r.from, r.to))) return de.none } else if (o = n.sliceDoc(r.from, r.to), !o) return de.none } let l = []; for (let a of t.visibleRanges) { let c = new Vo(n.doc, o, a.from, a.to); for (; !c.next().done;) { let { from: u, to: f } = c.value; if ((!s || bv(s, n, u, f)) && (r.empty && u <= r.from && f >= r.to ? l.push(nR.range(u, f)) : (u >= r.to || f <= r.from) && l.push(tR.range(u, f)), l.length > e.maxMatches)) return de.none } } return de.set(l) } }, { decorations: t => t.decorations }), oR = ie.baseTheme({ ".cm-selectionMatch": { backgroundColor: "#99ff7780" }, ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" } }), sR = ({ state: t, dispatch: e }) => { let { selection: n } = t, i = z.create(n.ranges.map(r => t.wordAt(r.head) || z.cursor(r.head)), n.mainIndex); return i.eq(n) ? !1 : (e(t.update({ selection: i })), !0) }; function lR(t, e) { let { main: n, ranges: i } = t.selection, r = t.wordAt(n.head), o = r && r.from == n.from && r.to == n.to; for (let s = !1, l = new Vo(t.doc, e, i[i.length - 1].to); ;)if (l.next(), l.done) { if (s) return null; l = new Vo(t.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), s = !0 } else { if (s && i.some(a => a.from == l.value.from)) continue; if (o) { let a = t.wordAt(l.value.from); if (!a || a.from != l.value.from || a.to != l.value.to) continue } return l.value } } const aR = ({ state: t, dispatch: e }) => { let { ranges: n } = t.selection; if (n.some(o => o.from === o.to)) return sR({ state: t, dispatch: e }); let i = t.sliceDoc(n[0].from, n[0].to); if (t.selection.ranges.some(o => t.sliceDoc(o.from, o.to) != i)) return !1; let r = lR(t, i); return r ? (e(t.update({ selection: t.selection.addRange(z.range(r.from, r.to), !1), effects: ie.scrollIntoView(r.to) })), !0) : !1 }, as = se.define({ combine(t) { return fi(t, { top: !1, caseSensitive: !1, literal: !1, regexp: !1, wholeWord: !1, createPanel: e => new OR(e), scrollToMatch: e => ie.scrollIntoView(e) }) } }); class Ux {
        constructor(e) { this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || K_(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord } unquote(e) {
            return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, i) => i == "n" ? `
`: i == "r" ? "\r" : i == "t" ? "	" : "\\")
        } eq(e) { return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord } create() { return this.regexp ? new hR(this) : new uR(this) } getCursor(e, n = 0, i) { let r = e.doc ? e : _e.create({ doc: e }); return i == null && (i = r.doc.length), this.regexp ? mo(this, r, n, i) : go(this, r, n, i) }
    } class Gx { constructor(e) { this.spec = e } } function go(t, e, n, i) { return new Vo(e.doc, t.unquoted, n, i, t.caseSensitive ? void 0 : r => r.toLowerCase(), t.wholeWord ? cR(e.doc, e.charCategorizer(e.selection.main.head)) : void 0) } function cR(t, e) { return (n, i, r, o) => ((o > n || o + r.length < i) && (o = Math.max(0, n - 2), r = t.sliceString(o, Math.min(t.length, i + 2))), (e(Vc(r, n - o)) != Ze.Word || e(Xc(r, n - o)) != Ze.Word) && (e(Xc(r, i - o)) != Ze.Word || e(Vc(r, i - o)) != Ze.Word)) } class uR extends Gx { constructor(e) { super(e) } nextMatch(e, n, i) { let r = go(this.spec, e, i, e.doc.length).nextOverlapping(); return r.done && (r = go(this.spec, e, 0, n).nextOverlapping()), r.done ? null : r.value } prevMatchInRange(e, n, i) { for (let r = i; ;) { let o = Math.max(n, r - 1e4 - this.spec.unquoted.length), s = go(this.spec, e, o, r), l = null; for (; !s.nextOverlapping().done;)l = s.value; if (l) return l; if (o == n) return null; r -= 1e4 } } prevMatch(e, n, i) { return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, i, e.doc.length) } getReplacement(e) { return this.spec.unquote(this.spec.replace) } matchAll(e, n) { let i = go(this.spec, e, 0, e.doc.length), r = []; for (; !i.next().done;) { if (r.length >= n) return null; r.push(i.value) } return r } highlight(e, n, i, r) { let o = go(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length)); for (; !o.next().done;)r(o.value.from, o.value.to) } } function mo(t, e, n, i) { return new qx(e.doc, t.search, { ignoreCase: !t.caseSensitive, test: t.wholeWord ? fR(e.charCategorizer(e.selection.main.head)) : void 0 }, n, i) } function Vc(t, e) { return t.slice(kt(t, e, !1), e) } function Xc(t, e) { return t.slice(e, kt(t, e)) } function fR(t) { return (e, n, i) => !i[0].length || (t(Vc(i.input, i.index)) != Ze.Word || t(Xc(i.input, i.index)) != Ze.Word) && (t(Xc(i.input, i.index + i[0].length)) != Ze.Word || t(Vc(i.input, i.index + i[0].length)) != Ze.Word) } class hR extends Gx { nextMatch(e, n, i) { let r = mo(this.spec, e, i, e.doc.length).next(); return r.done && (r = mo(this.spec, e, 0, n).next()), r.done ? null : r.value } prevMatchInRange(e, n, i) { for (let r = 1; ; r++) { let o = Math.max(n, i - r * 1e4), s = mo(this.spec, e, o, i), l = null; for (; !s.next().done;)l = s.value; if (l && (o == n || l.from > o + 10)) return l; if (o == n) return null } } prevMatch(e, n, i) { return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, i, e.doc.length) } getReplacement(e) { return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : n) } matchAll(e, n) { let i = mo(this.spec, e, 0, e.doc.length), r = []; for (; !i.next().done;) { if (r.length >= n) return null; r.push(i.value) } return r } highlight(e, n, i, r) { let o = mo(this.spec, e, Math.max(0, n - 250), Math.min(i + 250, e.doc.length)); for (; !o.next().done;)r(o.value.from, o.value.to) } } const wl = Ce.define(), pg = Ce.define(), ir = bt.define({ create(t) { return new Gf(zd(t).create(), null) }, update(t, e) { for (let n of e.effects) n.is(wl) ? t = new Gf(n.value.create(), t.panel) : n.is(pg) && (t = new Gf(t.query, n.value ? gg : null)); return t }, provide: t => Ol.from(t, e => e.panel) }); class Gf { constructor(e, n) { this.query = e, this.panel = n } } const dR = de.mark({ class: "cm-searchMatch" }), pR = de.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), gR = ct.fromClass(class { constructor(t) { this.view = t, this.decorations = this.highlight(t.state.field(ir)) } update(t) { let e = t.state.field(ir); (e != t.startState.field(ir) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e)) } highlight({ query: t, panel: e }) { if (!e || !t.spec.valid) return de.none; let { view: n } = this, i = new ar; for (let r = 0, o = n.visibleRanges, s = o.length; r < s; r++) { let { from: l, to: a } = o[r]; for (; r < s - 1 && a > o[r + 1].from - 2 * 250;)a = o[++r].to; t.highlight(n.state, l, a, (c, u) => { let f = n.state.selection.ranges.some(h => h.from == c && h.to == u); i.add(c, u, f ? pR : dR) }) } return i.finish() } }, { decorations: t => t.decorations }); function Ul(t) { return e => { let n = e.state.field(ir, !1); return n && n.query.spec.valid ? t(e, n) : Zx(e) } } const Uc = Ul((t, { query: e }) => { let { to: n } = t.state.selection.main, i = e.nextMatch(t.state, n, n); if (!i) return !1; let r = z.single(i.from, i.to), o = t.state.facet(as); return t.dispatch({ selection: r, effects: [mg(t, i), o.scrollToMatch(r.main, t)], userEvent: "select.search" }), Yx(t), !0 }), Gc = Ul((t, { query: e }) => { let { state: n } = t, { from: i } = n.selection.main, r = e.prevMatch(n, i, i); if (!r) return !1; let o = z.single(r.from, r.to), s = t.state.facet(as); return t.dispatch({ selection: o, effects: [mg(t, r), s.scrollToMatch(o.main, t)], userEvent: "select.search" }), Yx(t), !0 }), mR = Ul((t, { query: e }) => { let n = e.matchAll(t.state, 1e3); return !n || !n.length ? !1 : (t.dispatch({ selection: z.create(n.map(i => z.range(i.from, i.to))), userEvent: "select.search.matches" }), !0) }), vR = ({ state: t, dispatch: e }) => { let n = t.selection; if (n.ranges.length > 1 || n.main.empty) return !1; let { from: i, to: r } = n.main, o = [], s = 0; for (let l = new Vo(t.doc, t.sliceDoc(i, r)); !l.next().done;) { if (o.length > 1e3) return !1; l.value.from == i && (s = o.length), o.push(z.range(l.value.from, l.value.to)) } return e(t.update({ selection: z.create(o, s), userEvent: "select.search.matches" })), !0 }, Ov = Ul((t, { query: e }) => { let { state: n } = t, { from: i, to: r } = n.selection.main; if (n.readOnly) return !1; let o = e.nextMatch(n, i, i); if (!o) return !1; let s = [], l, a, c = []; if (o.from == i && o.to == r && (a = n.toText(e.getReplacement(o)), s.push({ from: o.from, to: o.to, insert: a }), o = e.nextMatch(n, o.from, o.to), c.push(ie.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(i).number) + "."))), o) { let u = s.length == 0 || s[0].from >= o.to ? 0 : o.to - o.from - a.length; l = z.single(o.from - u, o.to - u), c.push(mg(t, o)), c.push(n.facet(as).scrollToMatch(l.main, t)) } return t.dispatch({ changes: s, selection: l, effects: c, userEvent: "input.replace" }), !0 }), yR = Ul((t, { query: e }) => { if (t.state.readOnly) return !1; let n = e.matchAll(t.state, 1e9).map(r => { let { from: o, to: s } = r; return { from: o, to: s, insert: e.getReplacement(r) } }); if (!n.length) return !1; let i = t.state.phrase("replaced $ matches", n.length) + "."; return t.dispatch({ changes: n, effects: ie.announce.of(i), userEvent: "input.replace.all" }), !0 }); function gg(t) { return t.state.facet(as).createPanel(t) } function zd(t, e) { var n, i, r, o, s; let l = t.selection.main, a = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to); if (e && !a) return e; let c = t.facet(as); return new Ux({ search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? a : a.replace(/\n/g, "\\n"), caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive, literal: (r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal, regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : c.regexp, wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord }) } function Kx(t) { let e = bl(t, gg); return e && e.dom.querySelector("[main-field]") } function Yx(t) { let e = Kx(t); e && e == t.root.activeElement && e.select() } const Zx = t => { let e = t.state.field(ir, !1); if (e && e.panel) { let n = Kx(t); if (n && n != t.root.activeElement) { let i = zd(t.state, e.query.spec); i.valid && t.dispatch({ effects: wl.of(i) }), n.focus(), n.select() } } else t.dispatch({ effects: [pg.of(!0), e ? wl.of(zd(t.state, e.query.spec)) : Ce.appendConfig.of(xR)] }); return !0 }, Jx = t => { let e = t.state.field(ir, !1); if (!e || !e.panel) return !1; let n = bl(t, gg); return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: pg.of(!1) }), !0 }, bR = [{ key: "Mod-f", run: Zx, scope: "editor search-panel" }, { key: "F3", run: Uc, shift: Gc, scope: "editor search-panel", preventDefault: !0 }, { key: "Mod-g", run: Uc, shift: Gc, scope: "editor search-panel", preventDefault: !0 }, { key: "Escape", run: Jx, scope: "editor search-panel" }, { key: "Mod-Shift-l", run: vR }, { key: "Mod-Alt-g", run: Y_ }, { key: "Mod-d", run: aR, preventDefault: !0 }]; class OR { constructor(e) { this.view = e; let n = this.query = e.state.field(ir).query.spec; this.commit = this.commit.bind(this), this.searchField = Ve("input", { value: n.search, placeholder: nn(e, "Find"), "aria-label": nn(e, "Find"), class: "cm-textfield", name: "search", form: "", "main-field": "true", onchange: this.commit, onkeyup: this.commit }), this.replaceField = Ve("input", { value: n.replace, placeholder: nn(e, "Replace"), "aria-label": nn(e, "Replace"), class: "cm-textfield", name: "replace", form: "", onchange: this.commit, onkeyup: this.commit }), this.caseField = Ve("input", { type: "checkbox", name: "case", form: "", checked: n.caseSensitive, onchange: this.commit }), this.reField = Ve("input", { type: "checkbox", name: "re", form: "", checked: n.regexp, onchange: this.commit }), this.wordField = Ve("input", { type: "checkbox", name: "word", form: "", checked: n.wholeWord, onchange: this.commit }); function i(r, o, s) { return Ve("button", { class: "cm-button", name: r, onclick: o, type: "button" }, s) } this.dom = Ve("div", { onkeydown: r => this.keydown(r), class: "cm-search" }, [this.searchField, i("next", () => Uc(e), [nn(e, "next")]), i("prev", () => Gc(e), [nn(e, "previous")]), i("select", () => mR(e), [nn(e, "all")]), Ve("label", null, [this.caseField, nn(e, "match case")]), Ve("label", null, [this.reField, nn(e, "regexp")]), Ve("label", null, [this.wordField, nn(e, "by word")]), ...e.state.readOnly ? [] : [Ve("br"), this.replaceField, i("replace", () => Ov(e), [nn(e, "replace")]), i("replaceAll", () => yR(e), [nn(e, "replace all")])], Ve("button", { name: "close", onclick: () => Jx(e), "aria-label": nn(e, "close"), type: "button" }, ["×"])]) } commit() { let e = new Ux({ search: this.searchField.value, caseSensitive: this.caseField.checked, regexp: this.reField.checked, wholeWord: this.wordField.checked, replace: this.replaceField.value }); e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: wl.of(e) })) } keydown(e) { MM(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Gc : Uc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Ov(this.view)) } update(e) { for (let n of e.transactions) for (let i of n.effects) i.is(wl) && !i.value.eq(this.query) && this.setQuery(i.value) } setQuery(e) { this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord } mount() { this.searchField.select() } get pos() { return 80 } get top() { return this.view.state.facet(as).top } } function nn(t, e) { return t.state.phrase(e) } const ka = 30, Pa = /[\s\.,:;?!]/; function mg(t, { from: e, to: n }) { let i = t.state.doc.lineAt(e), r = t.state.doc.lineAt(n).to, o = Math.max(i.from, e - ka), s = Math.min(r, n + ka), l = t.state.sliceDoc(o, s); if (o != i.from) { for (let a = 0; a < ka; a++)if (!Pa.test(l[a + 1]) && Pa.test(l[a])) { l = l.slice(a); break } } if (s != r) { for (let a = l.length - 1; a > l.length - ka; a--)if (!Pa.test(l[a - 1]) && Pa.test(l[a])) { l = l.slice(0, a); break } } return ie.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${i.number}.`) } const SR = ie.baseTheme({ ".cm-panel.cm-search": { padding: "2px 6px 4px", position: "relative", "& [name=close]": { position: "absolute", top: "0", right: "4px", backgroundColor: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 }, "& input, & button, & label": { margin: ".2em .6em .2em 0" }, "& input[type=checkbox]": { marginRight: ".2em" }, "& label": { fontSize: "80%", whiteSpace: "pre" } }, "&light .cm-searchMatch": { backgroundColor: "#ffff0054" }, "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" }, "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" }, "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" } }), xR = [ir, yr.low(gR), SR]; class ew { constructor(e, n, i, r) { this.state = e, this.pos = n, this.explicit = i, this.view = r, this.abortListeners = [], this.abortOnDocChange = !1 } tokenBefore(e) { let n = yt(this.state).resolveInner(this.pos, -1); for (; n && e.indexOf(n.name) < 0;)n = n.parent; return n ? { from: n.from, to: this.pos, text: this.state.sliceDoc(n.from, this.pos), type: n.type } : null } matchBefore(e) { let n = this.state.doc.lineAt(this.pos), i = Math.max(n.from, this.pos - 250), r = n.text.slice(i - n.from, this.pos - n.from), o = r.search(nw(e, !1)); return o < 0 ? null : { from: i + o, to: this.pos, text: r.slice(o) } } get aborted() { return this.abortListeners == null } addEventListener(e, n, i) { e == "abort" && this.abortListeners && (this.abortListeners.push(n), i && i.onDocChange && (this.abortOnDocChange = !0)) } } function Sv(t) { let e = Object.keys(t).join(""), n = /\w/.test(e); return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]` } function wR(t) { let e = Object.create(null), n = Object.create(null); for (let { label: r } of t) { e[r[0]] = !0; for (let o = 1; o < r.length; o++)n[r[o]] = !0 } let i = Sv(e) + Sv(n) + "*$"; return [new RegExp("^" + i), new RegExp(i)] } function tw(t) { let e = t.map(r => typeof r == "string" ? { label: r } : r), [n, i] = e.every(r => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : wR(e); return r => { let o = r.matchBefore(i); return o || r.explicit ? { from: o ? o.from : r.pos, options: e, validFor: n } : null } } function CR(t, e) { return n => { for (let i = yt(n.state).resolveInner(n.pos, -1); i; i = i.parent) { if (t.indexOf(i.name) > -1) return null; if (i.type.isTop) break } return e(n) } } class xv { constructor(e, n, i, r) { this.completion = e, this.source = n, this.match = i, this.score = r } } function rr(t) { return t.selection.main.from } function nw(t, e) { var n; let { source: i } = t, r = e && i[0] != "^", o = i[i.length - 1] != "$"; return !r && !o ? t : new RegExp(`${r ? "^" : ""}(?:${i})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "") } const vg = Ri.define(); function TR(t, e, n, i) { let { main: r } = t.selection, o = n - r.from, s = i - r.from; return Object.assign(Object.assign({}, t.changeByRange(l => { if (l != r && n != i && t.sliceDoc(l.from + o, l.from + s) != t.sliceDoc(n, i)) return { range: l }; let a = t.toText(e); return { changes: { from: l.from + o, to: i == r.from ? l.to : l.from + s, insert: a }, range: z.cursor(l.from + o + a.length) } })), { scrollIntoView: !0, userEvent: "input.complete" }) } const wv = new WeakMap; function $R(t) { if (!Array.isArray(t)) return t; let e = wv.get(t); return e || wv.set(t, e = tw(t)), e } const Kc = Ce.define(), Cl = Ce.define(); class kR { constructor(e) { this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = []; for (let n = 0; n < e.length;) { let i = xt(e, n), r = bn(i); this.chars.push(i); let o = e.slice(n, n + r), s = o.toUpperCase(); this.folded.push(xt(s == o ? o.toLowerCase() : s, 0)), n += r } this.astral = e.length != this.chars.length } ret(e, n) { return this.score = e, this.matched = n, this } match(e) { if (this.pattern.length == 0) return this.ret(-100, []); if (e.length < this.pattern.length) return null; let { chars: n, folded: i, any: r, precise: o, byWord: s } = this; if (n.length == 1) { let b = xt(e, 0), x = bn(b), w = x == e.length ? 0 : -100; if (b != n[0]) if (b == i[0]) w += -200; else return null; return this.ret(w, [0, x]) } let l = e.indexOf(this.pattern); if (l == 0) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]); let a = n.length, c = 0; if (l < 0) { for (let b = 0, x = Math.min(e.length, 200); b < x && c < a;) { let w = xt(e, b); (w == n[c] || w == i[c]) && (r[c++] = b), b += bn(w) } if (c < a) return null } let u = 0, f = 0, h = !1, d = 0, p = -1, g = -1, m = /[a-z]/.test(e), v = !0; for (let b = 0, x = Math.min(e.length, 200), w = 0; b < x && f < a;) { let y = xt(e, b); l < 0 && (u < a && y == n[u] && (o[u++] = b), d < a && (y == n[d] || y == i[d] ? (d == 0 && (p = b), g = b + 1, d++) : d = 0)); let C, O = y < 255 ? y >= 48 && y <= 57 || y >= 97 && y <= 122 ? 2 : y >= 65 && y <= 90 ? 1 : 0 : (C = Hp(y)) != C.toLowerCase() ? 1 : C != C.toUpperCase() ? 2 : 0; (!b || O == 1 && m || w == 0 && O != 0) && (n[f] == y || i[f] == y && (h = !0) ? s[f++] = b : s.length && (v = !1)), w = O, b += bn(y) } return f == a && s[0] == 0 && v ? this.result(-100 + (h ? -200 : 0), s, e) : d == a && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-200 + -700 - e.length, [p, g]) : f == a ? this.result(-100 + (h ? -200 : 0) + -700 + (v ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e) } result(e, n, i) { let r = [], o = 0; for (let s of n) { let l = s + (this.astral ? bn(xt(i, s)) : 1); o && r[o - 1] == s ? r[o - 1] = l : (r[o++] = s, r[o++] = l) } return this.ret(e - i.length, r) } } class PR { constructor(e) { this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase() } match(e) { if (e.length < this.pattern.length) return null; let n = e.slice(0, this.pattern.length), i = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null; return i == null ? null : (this.matched = [0, n.length], this.score = i + (e.length == this.pattern.length ? 0 : -100), this) } } const $t = se.define({ combine(t) { return fi(t, { activateOnTyping: !0, activateOnCompletion: () => !1, activateOnTypingDelay: 100, selectOnOpen: !0, override: null, closeOnBlur: !0, maxRenderedOptions: 100, defaultKeymap: !0, tooltipClass: () => "", optionClass: () => "", aboveCursor: !1, icons: !0, addToOptions: [], positionInfo: AR, filterStrict: !1, compareCompletions: (e, n) => e.label.localeCompare(n.label), interactionDelay: 75, updateSyncTime: 100 }, { defaultKeymap: (e, n) => e && n, closeOnBlur: (e, n) => e && n, icons: (e, n) => e && n, tooltipClass: (e, n) => i => Cv(e(i), n(i)), optionClass: (e, n) => i => Cv(e(i), n(i)), addToOptions: (e, n) => e.concat(n), filterStrict: (e, n) => e || n }) } }); function Cv(t, e) { return t ? e ? t + " " + e : t : e } function AR(t, e, n, i, r, o) { let s = t.textDirection == Ge.RTL, l = s, a = !1, c = "top", u, f, h = e.left - r.left, d = r.right - e.right, p = i.right - i.left, g = i.bottom - i.top; if (l && h < Math.min(p, d) ? l = !1 : !l && d < Math.min(p, h) && (l = !0), p <= (l ? h : d)) u = Math.max(r.top, Math.min(n.top, r.bottom - g)) - e.top, f = Math.min(400, l ? h : d); else { a = !0, f = Math.min(400, (s ? e.right : r.right - e.left) - 30); let b = r.bottom - e.bottom; b >= g || b > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top) } let m = (e.bottom - e.top) / o.offsetHeight, v = (e.right - e.left) / o.offsetWidth; return { style: `${c}: ${u / m}px; max-width: ${f / v}px`, class: "cm-completionInfo-" + (a ? s ? "left-narrow" : "right-narrow" : l ? "left" : "right") } } function MR(t) { let e = t.addToOptions.slice(); return t.icons && e.push({ render(n) { let i = document.createElement("div"); return i.classList.add("cm-completionIcon"), n.type && i.classList.add(...n.type.split(/\s+/g).map(r => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i }, position: 20 }), e.push({ render(n, i, r, o) { let s = document.createElement("span"); s.className = "cm-completionLabel"; let l = n.displayLabel || n.label, a = 0; for (let c = 0; c < o.length;) { let u = o[c++], f = o[c++]; u > a && s.appendChild(document.createTextNode(l.slice(a, u))); let h = s.appendChild(document.createElement("span")); h.appendChild(document.createTextNode(l.slice(u, f))), h.className = "cm-completionMatchedText", a = f } return a < l.length && s.appendChild(document.createTextNode(l.slice(a))), s }, position: 50 }, { render(n) { if (!n.detail) return null; let i = document.createElement("span"); return i.className = "cm-completionDetail", i.textContent = n.detail, i }, position: 80 }), e.sort((n, i) => n.position - i.position).map(n => n.render) } function Kf(t, e, n) { if (t <= n) return { from: 0, to: t }; if (e < 0 && (e = 0), e <= t >> 1) { let r = Math.floor(e / n); return { from: r * n, to: (r + 1) * n } } let i = Math.floor((t - e) / n); return { from: t - (i + 1) * n, to: t - i * n } } class ER { constructor(e, n, i) { this.view = e, this.stateField = n, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = { read: () => this.measureInfo(), write: a => this.placeInfo(a), key: this }, this.space = null, this.currentClass = ""; let r = e.state.field(n), { options: o, selected: s } = r.open, l = e.state.facet($t); this.optionContent = MR(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = Kf(o.length, s, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", a => { let { options: c } = e.state.field(n).open; for (let u = a.target, f; u && u != this.dom; u = u.parentNode)if (u.nodeName == "LI" && (f = /-(\d+)$/.exec(u.id)) && +f[1] < c.length) { this.applyCompletion(e, c[+f[1]]), a.preventDefault(); return } }), this.dom.addEventListener("focusout", a => { let c = e.state.field(this.stateField, !1); c && c.tooltip && e.state.facet($t).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: Cl.of(null) }) }), this.showOptions(o, r.id) } mount() { this.updateSel() } showOptions(e, n) { this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => { this.info && this.view.requestMeasure(this.placeInfoReq) }) } update(e) { var n; let i = e.state.field(this.stateField), r = e.startState.field(this.stateField); if (this.updateTooltipClass(e.state), i != r) { let { options: o, selected: s, disabled: l } = i.open; (!r.open || r.open.options != o) && (this.range = Kf(o.length, s, e.state.facet($t).maxRenderedOptions), this.showOptions(o, i.id)), this.updateSel(), l != ((n = r.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l) } } updateTooltipClass(e) { let n = this.tooltipClass(e); if (n != this.currentClass) { for (let i of this.currentClass.split(" ")) i && this.dom.classList.remove(i); for (let i of n.split(" ")) i && this.dom.classList.add(i); this.currentClass = n } } positioned(e) { this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq) } updateSel() { let e = this.view.state.field(this.stateField), n = e.open; if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Kf(n.options.length, n.selected, this.view.state.facet($t).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) { this.destroyInfo(); let { completion: i } = n.options[n.selected], { info: r } = i; if (!r) return; let o = typeof r == "string" ? document.createTextNode(r) : r(i); if (!o) return; "then" in o ? o.then(s => { s && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(s, i) }).catch(s => Kt(this.view.state, s, "completion info")) : this.addInfoPane(o, i) } } addInfoPane(e, n) { this.destroyInfo(); let i = this.info = document.createElement("div"); if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null) i.appendChild(e), this.infoDestroy = null; else { let { dom: r, destroy: o } = e; i.appendChild(r), this.infoDestroy = o || null } this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq) } updateSelectedOption(e) { let n = null; for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)i.nodeName != "LI" || !i.id ? r-- : r == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), n = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected"); return n && RR(this.list, n), n } measureInfo() { let e = this.dom.querySelector("[aria-selected]"); if (!e || !this.info) return null; let n = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), o = this.space; if (!o) { let s = this.dom.ownerDocument.defaultView || window; o = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight } } return r.top > Math.min(o.bottom, n.bottom) - 10 || r.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet($t).positionInfo(this.view, n, r, i, o, this.dom) } placeInfo(e) { this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px") } createListBox(e, n, i) { const r = document.createElement("ul"); r.id = n, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions")); let o = null; for (let s = i.from; s < i.to; s++) { let { completion: l, match: a } = e[s], { section: c } = l; if (c) { let h = typeof c == "string" ? c : c.name; if (h != o && (s > i.from || i.from == 0)) if (o = h, typeof c != "string" && c.header) r.appendChild(c.header(c)); else { let d = r.appendChild(document.createElement("completion-section")); d.textContent = h } } const u = r.appendChild(document.createElement("li")); u.id = n + "-" + s, u.setAttribute("role", "option"); let f = this.optionClass(l); f && (u.className = f); for (let h of this.optionContent) { let d = h(l, this.view.state, this.view, a); d && u.appendChild(d) } } return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r } destroyInfo() { this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null) } destroy() { this.destroyInfo() } } function _R(t, e) { return n => new ER(n, t, e) } function RR(t, e) { let n = t.getBoundingClientRect(), i = e.getBoundingClientRect(), r = n.height / t.offsetHeight; i.top < n.top ? t.scrollTop -= (n.top - i.top) / r : i.bottom > n.bottom && (t.scrollTop += (i.bottom - n.bottom) / r) } function Tv(t) { return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0) } function IR(t, e) { let n = [], i = null, r = c => { n.push(c); let { section: u } = c.completion; if (u) { i || (i = []); let f = typeof u == "string" ? u : u.name; i.some(h => h.name == f) || i.push(typeof u == "string" ? { name: f } : u) } }, o = e.facet($t); for (let c of t) if (c.hasResult()) { let u = c.result.getMatch; if (c.result.filter === !1) for (let f of c.result.options) r(new xv(f, c.source, u ? u(f) : [], 1e9 - n.length)); else { let f = e.sliceDoc(c.from, c.to), h, d = o.filterStrict ? new PR(f) : new kR(f); for (let p of c.result.options) if (h = d.match(p.label)) { let g = p.displayLabel ? u ? u(p, h.matched) : [] : h.matched; r(new xv(p, c.source, g, h.score + (p.boost || 0))) } } } if (i) { let c = Object.create(null), u = 0, f = (h, d) => { var p, g; return ((p = h.rank) !== null && p !== void 0 ? p : 1e9) - ((g = d.rank) !== null && g !== void 0 ? g : 1e9) || (h.name < d.name ? -1 : 1) }; for (let h of i.sort(f)) u -= 1e5, c[h.name] = u; for (let h of n) { let { section: d } = h.completion; d && (h.score += c[typeof d == "string" ? d : d.name]) } } let s = [], l = null, a = o.compareCompletions; for (let c of n.sort((u, f) => f.score - u.score || a(u.completion, f.completion))) { let u = c.completion; !l || l.label != u.label || l.detail != u.detail || l.type != null && u.type != null && l.type != u.type || l.apply != u.apply || l.boost != u.boost ? s.push(c) : Tv(c.completion) > Tv(l) && (s[s.length - 1] = c), l = c.completion } return s } class Oo { constructor(e, n, i, r, o, s) { this.options = e, this.attrs = n, this.tooltip = i, this.timestamp = r, this.selected = o, this.disabled = s } setSelected(e, n) { return e == this.selected || e >= this.options.length ? this : new Oo(this.options, $v(n, e), this.tooltip, this.timestamp, e, this.disabled) } static build(e, n, i, r, o) { let s = IR(e, n); if (!s.length) return r && e.some(a => a.state == 1) ? new Oo(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null; let l = n.facet($t).selectOnOpen ? 0 : -1; if (r && r.selected != l && r.selected != -1) { let a = r.options[r.selected].completion; for (let c = 0; c < s.length; c++)if (s[c].completion == a) { l = c; break } } return new Oo(s, $v(i, l), { pos: e.reduce((a, c) => c.hasResult() ? Math.min(a, c.from) : a, 1e8), create: zR, above: o.aboveCursor }, r ? r.timestamp : Date.now(), l, !1) } map(e) { return new Oo(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled) } } class Yc { constructor(e, n, i) { this.active = e, this.id = n, this.open = i } static start() { return new Yc(QR, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null) } update(e) { let { state: n } = e, i = n.facet($t), o = (i.override || n.languageDataAt("autocomplete", rr(n)).map($R)).map(l => (this.active.find(c => c.source == l) || new cn(l, this.active.some(c => c.state != 0) ? 1 : 0)).update(e, i)); o.length == this.active.length && o.every((l, a) => l == this.active[a]) && (o = this.active); let s = this.open; s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some(l => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !DR(o, this.active) ? s = Oo.build(o, n, this.id, s, i) : s && s.disabled && !o.some(l => l.state == 1) && (s = null), !s && o.every(l => l.state != 1) && o.some(l => l.hasResult()) && (o = o.map(l => l.hasResult() ? new cn(l.source, 0) : l)); for (let l of e.effects) l.is(ow) && (s = s && s.setSelected(l.value, this.id)); return o == this.active && s == this.open ? this : new Yc(o, this.id, s) } get tooltip() { return this.open ? this.open.tooltip : null } get attrs() { return this.open ? this.open.attrs : this.active.length ? BR : LR } } function DR(t, e) { if (t == e) return !0; for (let n = 0, i = 0; ;) { for (; n < t.length && !t[n].hasResult;)n++; for (; i < e.length && !e[i].hasResult;)i++; let r = n == t.length, o = i == e.length; if (r || o) return r == o; if (t[n++].result != e[i++].result) return !1 } } const BR = { "aria-autocomplete": "list" }, LR = {}; function $v(t, e) { let n = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": t }; return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n } const QR = []; function iw(t, e) { if (t.isUserEvent("input.complete")) { let i = t.annotation(vg); if (i && e.activateOnCompletion(i)) return 12 } let n = t.isUserEvent("input.type"); return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0 } class cn { constructor(e, n, i = -1) { this.source = e, this.state = n, this.explicitPos = i } hasResult() { return !1 } update(e, n) { let i = iw(e, n), r = this; (i & 8 || i & 16 && this.touches(e)) && (r = new cn(r.source, 0)), i & 4 && r.state == 0 && (r = new cn(this.source, 1)), r = r.updateFor(e, i); for (let o of e.effects) if (o.is(Kc)) r = new cn(r.source, 1, o.value ? rr(e.state) : -1); else if (o.is(Cl)) r = new cn(r.source, 0); else if (o.is(rw)) for (let s of o.value) s.source == r.source && (r = s); return r } updateFor(e, n) { return this.map(e.changes) } map(e) { return e.empty || this.explicitPos < 0 ? this : new cn(this.source, this.state, e.mapPos(this.explicitPos)) } touches(e) { return e.changes.touchesRange(rr(e.state)) } } class Ro extends cn { constructor(e, n, i, r, o) { super(e, 2, n), this.result = i, this.from = r, this.to = o } hasResult() { return !0 } updateFor(e, n) { var i; if (!(n & 3)) return this.map(e.changes); let r = this.result; r.map && !e.changes.empty && (r = r.map(r, e.changes)); let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), l = rr(e.state); if ((this.explicitPos < 0 ? l <= o : l < this.from) || l > s || !r || n & 2 && rr(e.startState) == this.from) return new cn(this.source, n & 4 ? 1 : 0); let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos); return NR(r.validFor, e.state, o, s) ? new Ro(this.source, a, r, o, s) : r.update && (r = r.update(r, o, s, new ew(e.state, l, a >= 0))) ? new Ro(this.source, a, r, r.from, (i = r.to) !== null && i !== void 0 ? i : rr(e.state)) : new cn(this.source, 1, a) } map(e) { return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Ro(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new cn(this.source, 0) } touches(e) { return e.changes.touchesRange(this.from, this.to) } } function NR(t, e, n, i) { if (!t) return !1; let r = e.sliceDoc(n, i); return typeof t == "function" ? t(r, n, i, e) : nw(t, !0).test(r) } const rw = Ce.define({ map(t, e) { return t.map(n => n.map(e)) } }), ow = Ce.define(), Xt = bt.define({ create() { return Yc.start() }, update(t, e) { return t.update(e) }, provide: t => [ng.from(t, e => e.tooltip), ie.contentAttributes.from(t, e => e.attrs)] }); function yg(t, e) { const n = e.completion.apply || e.completion.label; let i = t.state.field(Xt).active.find(r => r.source == e.source); return i instanceof Ro ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, TR(t.state, n, i.from, i.to)), { annotations: vg.of(e.completion) })) : n(t, e.completion, i.from, i.to), !0) : !1 } const zR = _R(Xt, yg); function Aa(t, e = "option") { return n => { let i = n.state.field(Xt, !1); if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < n.state.facet($t).interactionDelay) return !1; let r = 1, o; e == "page" && (o = NS(n, i.open.tooltip)) && (r = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1)); let { length: s } = i.open.options, l = i.open.selected > -1 ? i.open.selected + r * (t ? 1 : -1) : t ? 0 : s - 1; return l < 0 ? l = e == "page" ? 0 : s - 1 : l >= s && (l = e == "page" ? s - 1 : 0), n.dispatch({ effects: ow.of(l) }), !0 } } const WR = t => { let e = t.state.field(Xt, !1); return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet($t).interactionDelay ? !1 : yg(t, e.open.options[e.open.selected]) }, kv = t => t.state.field(Xt, !1) ? (t.dispatch({ effects: Kc.of(!0) }), !0) : !1, HR = t => { let e = t.state.field(Xt, !1); return !e || !e.active.some(n => n.state != 0) ? !1 : (t.dispatch({ effects: Cl.of(null) }), !0) }; class FR { constructor(e, n) { this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0 } } const jR = 50, qR = 1e3, VR = ct.fromClass(class { constructor(t) { this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0; for (let e of t.state.field(Xt).active) e.state == 1 && this.startQuery(e) } update(t) { let e = t.state.field(Xt), n = t.state.facet($t); if (!t.selectionSet && !t.docChanged && t.startState.field(Xt) == e) return; let i = t.transactions.some(o => { let s = iw(o, n); return s & 8 || (o.selection || o.docChanged) && !(s & 3) }); for (let o = 0; o < this.running.length; o++) { let s = this.running[o]; if (i || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > jR && Date.now() - s.time > qR) { for (let l of s.context.abortListeners) try { l() } catch (a) { Kt(this.view.state, a) } s.context.abortListeners = null, this.running.splice(o--, 1) } else s.updates.push(...t.transactions) } this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some(o => o.effects.some(s => s.is(Kc))) && (this.pendingStart = !0); let r = this.pendingStart ? 50 : n.activateOnTypingDelay; if (this.debounceUpdate = e.active.some(o => o.state == 1 && !this.running.some(s => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0) for (let o of t.transactions) o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3) } startUpdate() { this.debounceUpdate = -1, this.pendingStart = !1; let { state: t } = this.view, e = t.field(Xt); for (let n of e.active) n.state == 1 && !this.running.some(i => i.active.source == n.source) && this.startQuery(n) } startQuery(t) { let { state: e } = this.view, n = rr(e), i = new ew(e, n, t.explicitPos == n, this.view), r = new FR(t, i); this.running.push(r), Promise.resolve(t.source(i)).then(o => { r.context.aborted || (r.done = o || null, this.scheduleAccept()) }, o => { this.view.dispatch({ effects: Cl.of(null) }), Kt(this.view.state, o) }) } scheduleAccept() { this.running.every(t => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet($t).updateSyncTime)) } accept() { var t; this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1; let e = [], n = this.view.state.facet($t); for (let i = 0; i < this.running.length; i++) { let r = this.running[i]; if (r.done === void 0) continue; if (this.running.splice(i--, 1), r.done) { let s = new Ro(r.active.source, r.active.explicitPos, r.done, r.done.from, (t = r.done.to) !== null && t !== void 0 ? t : rr(r.updates.length ? r.updates[0].startState : this.view.state)); for (let l of r.updates) s = s.update(l, n); if (s.hasResult()) { e.push(s); continue } } let o = this.view.state.field(Xt).active.find(s => s.source == r.active.source); if (o && o.state == 1) if (r.done == null) { let s = new cn(r.active.source, 0); for (let l of r.updates) s = s.update(l, n); s.state != 1 && e.push(s) } else this.startQuery(o) } e.length && this.view.dispatch({ effects: rw.of(e) }) } }, { eventHandlers: { blur(t) { let e = this.view.state.field(Xt, !1); if (e && e.tooltip && this.view.state.facet($t).closeOnBlur) { let n = e.open && NS(this.view, e.open.tooltip); (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Cl.of(null) }), 10) } }, compositionstart() { this.composing = 1 }, compositionend() { this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Kc.of(!1) }), 20), this.composing = 0 } } }), XR = typeof navigator == "object" && /Win/.test(navigator.platform), UR = yr.highest(ie.domEventHandlers({ keydown(t, e) { let n = e.state.field(Xt, !1); if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(XR && t.altKey) || t.metaKey) return !1; let i = n.open.options[n.open.selected], r = n.active.find(s => s.source == i.source), o = i.completion.commitCharacters || r.result.commitCharacters; return o && o.indexOf(t.key) > -1 && yg(e, i), !1 } })), sw = ie.baseTheme({ ".cm-tooltip.cm-tooltip-autocomplete": { "& > ul": { fontFamily: "monospace", whiteSpace: "nowrap", overflow: "hidden auto", maxWidth_fallback: "700px", maxWidth: "min(700px, 95vw)", minWidth: "250px", maxHeight: "10em", height: "100%", listStyle: "none", margin: 0, padding: 0, "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 }, "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" }, "& > completion-section": { display: "list-item", borderBottom: "1px solid silver", paddingLeft: "0.5em", opacity: .7 } } }, "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" }, "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" }, "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" }, "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" }, ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": { content: '"···"', opacity: .5, display: "block", textAlign: "center" }, ".cm-tooltip.cm-completionInfo": { position: "absolute", padding: "3px 9px", width: "max-content", maxWidth: "400px", boxSizing: "border-box", whiteSpace: "pre-line" }, ".cm-completionInfo.cm-completionInfo-left": { right: "100%" }, ".cm-completionInfo.cm-completionInfo-right": { left: "100%" }, ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" }, ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" }, "&light .cm-snippetField": { backgroundColor: "#00000022" }, "&dark .cm-snippetField": { backgroundColor: "#ffffff22" }, ".cm-snippetFieldPosition": { verticalAlign: "text-top", width: 0, height: "1.15em", display: "inline-block", margin: "0 -0.7px -.7em", borderLeft: "1.4px dotted #888" }, ".cm-completionMatchedText": { textDecoration: "underline" }, ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" }, ".cm-completionIcon": { fontSize: "90%", width: ".8em", display: "inline-block", textAlign: "center", paddingRight: ".6em", opacity: "0.6", boxSizing: "content-box" }, ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'ƒ'" } }, ".cm-completionIcon-class": { "&:after": { content: "'○'" } }, ".cm-completionIcon-interface": { "&:after": { content: "'◌'" } }, ".cm-completionIcon-variable": { "&:after": { content: "'𝑥'" } }, ".cm-completionIcon-constant": { "&:after": { content: "'𝐶'" } }, ".cm-completionIcon-type": { "&:after": { content: "'𝑡'" } }, ".cm-completionIcon-enum": { "&:after": { content: "'∪'" } }, ".cm-completionIcon-property": { "&:after": { content: "'□'" } }, ".cm-completionIcon-keyword": { "&:after": { content: "'🔑︎'" } }, ".cm-completionIcon-namespace": { "&:after": { content: "'▢'" } }, ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } } }); class GR { constructor(e, n, i, r) { this.field = e, this.line = n, this.from = i, this.to = r } } class bg { constructor(e, n, i) { this.field = e, this.from = n, this.to = i } map(e) { let n = e.mapPos(this.from, -1, Tt.TrackDel), i = e.mapPos(this.to, 1, Tt.TrackDel); return n == null || i == null ? null : new bg(this.field, n, i) } } class Og { constructor(e, n) { this.lines = e, this.fieldPositions = n } instantiate(e, n) { let i = [], r = [n], o = e.doc.lineAt(n), s = /^\s*/.exec(o.text)[0]; for (let a of this.lines) { if (i.length) { let c = s, u = /^\t*/.exec(a)[0].length; for (let f = 0; f < u; f++)c += e.facet(Bu); r.push(n + c.length - u), a = c + a.slice(u) } i.push(a), n += a.length + 1 } let l = this.fieldPositions.map(a => new bg(a.field, r[a.line] + a.from, r[a.line] + a.to)); return { text: i, ranges: l } } static parse(e) { let n = [], i = [], r = [], o; for (let s of e.split(/\r\n?|\n/)) { for (; o = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(s);) { let l = o[1] ? +o[1] : null, a = o[2] || o[3] || "", c = -1, u = a.replace(/\\[{}]/g, f => f[1]); for (let f = 0; f < n.length; f++)(l != null ? n[f].seq == l : u && n[f].name == u) && (c = f); if (c < 0) { let f = 0; for (; f < n.length && (l == null || n[f].seq != null && n[f].seq < l);)f++; n.splice(f, 0, { seq: l, name: u }), c = f; for (let h of r) h.field >= c && h.field++ } r.push(new GR(c, i.length, o.index, o.index + u.length)), s = s.slice(0, o.index) + a + s.slice(o.index + o[0].length) } s = s.replace(/\\([{}])/g, (l, a, c) => { for (let u of r) u.line == i.length && u.from > c && (u.from--, u.to--); return a }), i.push(s) } return new Og(i, r) } } let KR = de.widget({ widget: new class extends Ii { toDOM() { let t = document.createElement("span"); return t.className = "cm-snippetFieldPosition", t } ignoreEvent() { return !1 } } }), YR = de.mark({ class: "cm-snippetField" }); class cs { constructor(e, n) { this.ranges = e, this.active = n, this.deco = de.set(e.map(i => (i.from == i.to ? KR : YR).range(i.from, i.to))) } map(e) { let n = []; for (let i of this.ranges) { let r = i.map(e); if (!r) return null; n.push(r) } return new cs(n, this.active) } selectionInsideField(e) { return e.ranges.every(n => this.ranges.some(i => i.field == this.active && i.from <= n.from && i.to >= n.to)) } } const Gl = Ce.define({ map(t, e) { return t && t.map(e) } }), ZR = Ce.define(), Tl = bt.define({ create() { return null }, update(t, e) { for (let n of e.effects) { if (n.is(Gl)) return n.value; if (n.is(ZR) && t) return new cs(t.ranges, n.value) } return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t }, provide: t => ie.decorations.from(t, e => e ? e.deco : de.none) }); function Sg(t, e) { return z.create(t.filter(n => n.field == e).map(n => z.range(n.from, n.to))) } function JR(t) { let e = Og.parse(t); return (n, i, r, o) => { let { text: s, ranges: l } = e.instantiate(n.state, r), a = { changes: { from: r, to: o, insert: Be.of(s) }, scrollIntoView: !0, annotations: i ? [vg.of(i), lt.userEvent.of("input.complete")] : void 0 }; if (l.length && (a.selection = Sg(l, 0)), l.some(c => c.field > 0)) { let c = new cs(l, 0), u = a.effects = [Gl.of(c)]; n.state.field(Tl, !1) === void 0 && u.push(Ce.appendConfig.of([Tl, rI, oI, sw])) } n.dispatch(n.state.update(a)) } } function lw(t) { return ({ state: e, dispatch: n }) => { let i = e.field(Tl, !1); if (!i || t < 0 && i.active == 0) return !1; let r = i.active + t, o = t > 0 && !i.ranges.some(s => s.field == r + t); return n(e.update({ selection: Sg(i.ranges, r), effects: Gl.of(o ? null : new cs(i.ranges, r)), scrollIntoView: !0 })), !0 } } const eI = ({ state: t, dispatch: e }) => t.field(Tl, !1) ? (e(t.update({ effects: Gl.of(null) })), !0) : !1, tI = lw(1), nI = lw(-1), iI = [{ key: "Tab", run: tI, shift: nI }, { key: "Escape", run: eI }], Pv = se.define({ combine(t) { return t.length ? t[0] : iI } }), rI = yr.highest(Iu.compute([Pv], t => t.facet(Pv))); function pi(t, e) { return Object.assign(Object.assign({}, e), { apply: JR(t) }) } const oI = ie.domEventHandlers({ mousedown(t, e) { let n = e.state.field(Tl, !1), i; if (!n || (i = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null) return !1; let r = n.ranges.find(o => o.from <= i && o.to >= i); return !r || r.field == n.active ? !1 : (e.dispatch({ selection: Sg(n.ranges, r.field), effects: Gl.of(n.ranges.some(o => o.field > r.field) ? new cs(n.ranges, r.field) : null), scrollIntoView: !0 }), !0) } }), $l = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] }, Dr = Ce.define({ map(t, e) { let n = e.mapPos(t, -1, Tt.TrackAfter); return n ?? void 0 } }), xg = new class extends jr { }; xg.startSide = 1; xg.endSide = -1; const aw = bt.define({ create() { return De.empty }, update(t, e) { if (t = t.map(e.changes), e.selection) { let n = e.state.doc.lineAt(e.selection.main.head); t = t.update({ filter: i => i >= n.from && i <= n.to }) } for (let n of e.effects) n.is(Dr) && (t = t.update({ add: [xg.range(n.value, n.value + 1)] })); return t } }); function sI() { return [aI, aw] } const Yf = "()[]{}<>"; function cw(t) { for (let e = 0; e < Yf.length; e += 2)if (Yf.charCodeAt(e) == t) return Yf.charAt(e + 1); return Hp(t < 128 ? t : t + 1) } function uw(t, e) { return t.languageDataAt("closeBrackets", e)[0] || $l } const lI = typeof navigator == "object" && /Android\b/.test(navigator.userAgent), aI = ie.inputHandler.of((t, e, n, i) => { if ((lI ? t.composing : t.compositionStarted) || t.state.readOnly) return !1; let r = t.state.selection.main; if (i.length > 2 || i.length == 2 && bn(xt(i, 0)) == 1 || e != r.from || n != r.to) return !1; let o = fI(t.state, i); return o ? (t.dispatch(o), !0) : !1 }), cI = ({ state: t, dispatch: e }) => { if (t.readOnly) return !1; let i = uw(t, t.selection.main.head).brackets || $l.brackets, r = null, o = t.changeByRange(s => { if (s.empty) { let l = hI(t.doc, s.head); for (let a of i) if (a == l && ju(t.doc, s.head) == cw(xt(a, 0))) return { changes: { from: s.head - a.length, to: s.head + a.length }, range: z.cursor(s.head - a.length) } } return { range: r = s } }); return r || e(t.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !r }, uI = [{ key: "Backspace", run: cI }]; function fI(t, e) { let n = uw(t, t.selection.main.head), i = n.brackets || $l.brackets; for (let r of i) { let o = cw(xt(r, 0)); if (e == r) return o == r ? gI(t, r, i.indexOf(r + r + r) > -1, n) : dI(t, r, o, n.before || $l.before); if (e == o && fw(t, t.selection.main.from)) return pI(t, r, o) } return null } function fw(t, e) { let n = !1; return t.field(aw).between(0, t.doc.length, i => { i == e && (n = !0) }), n } function ju(t, e) { let n = t.sliceString(e, e + 2); return n.slice(0, bn(xt(n, 0))) } function hI(t, e) { let n = t.sliceString(e - 2, e); return bn(xt(n, 0)) == n.length ? n : n.slice(1) } function dI(t, e, n, i) { let r = null, o = t.changeByRange(s => { if (!s.empty) return { changes: [{ insert: e, from: s.from }, { insert: n, from: s.to }], effects: Dr.of(s.to + e.length), range: z.range(s.anchor + e.length, s.head + e.length) }; let l = ju(t.doc, s.head); return !l || /\s/.test(l) || i.indexOf(l) > -1 ? { changes: { insert: e + n, from: s.head }, effects: Dr.of(s.head + e.length), range: z.cursor(s.head + e.length) } : { range: r = s } }); return r ? null : t.update(o, { scrollIntoView: !0, userEvent: "input.type" }) } function pI(t, e, n) { let i = null, r = t.changeByRange(o => o.empty && ju(t.doc, o.head) == n ? { changes: { from: o.head, to: o.head + n.length, insert: n }, range: z.cursor(o.head + n.length) } : i = { range: o }); return i ? null : t.update(r, { scrollIntoView: !0, userEvent: "input.type" }) } function gI(t, e, n, i) { let r = i.stringPrefixes || $l.stringPrefixes, o = null, s = t.changeByRange(l => { if (!l.empty) return { changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }], effects: Dr.of(l.to + e.length), range: z.range(l.anchor + e.length, l.head + e.length) }; let a = l.head, c = ju(t.doc, a), u; if (c == e) { if (Av(t, a)) return { changes: { insert: e + e, from: a }, effects: Dr.of(a + e.length), range: z.cursor(a + e.length) }; if (fw(t, a)) { let h = n && t.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e; return { changes: { from: a, to: a + h.length, insert: h }, range: z.cursor(a + h.length) } } } else { if (n && t.sliceDoc(a - 2 * e.length, a) == e + e && (u = Mv(t, a - 2 * e.length, r)) > -1 && Av(t, u)) return { changes: { insert: e + e + e + e, from: a }, effects: Dr.of(a + e.length), range: z.cursor(a + e.length) }; if (t.charCategorizer(a)(c) != Ze.Word && Mv(t, a, r) > -1 && !mI(t, a, e, r)) return { changes: { insert: e + e, from: a }, effects: Dr.of(a + e.length), range: z.cursor(a + e.length) } } return { range: o = l } }); return o ? null : t.update(s, { scrollIntoView: !0, userEvent: "input.type" }) } function Av(t, e) { let n = yt(t).resolveInner(e + 1); return n.parent && n.from == e } function mI(t, e, n, i) { let r = yt(t).resolveInner(e, -1), o = i.reduce((s, l) => Math.max(s, l.length), 0); for (let s = 0; s < 5; s++) { let l = t.sliceDoc(r.from, Math.min(r.to, r.from + n.length + o)), a = l.indexOf(n); if (!a || a > -1 && i.indexOf(l.slice(0, a)) > -1) { let u = r.firstChild; for (; u && u.from == r.from && u.to - u.from > n.length + a;) { if (t.sliceDoc(u.to - n.length, u.to) == n) return !1; u = u.firstChild } return !0 } let c = r.to == e && r.parent; if (!c) break; r = c } return !1 } function Mv(t, e, n) { let i = t.charCategorizer(e); if (i(t.sliceDoc(e - 1, e)) != Ze.Word) return e; for (let r of n) { let o = e - r.length; if (t.sliceDoc(o, e) == r && i(t.sliceDoc(o - 1, o)) != Ze.Word) return o } return -1 } function hw(t = {}) { return [UR, Xt, $t.of(t), VR, vI, sw] } const dw = [{ key: "Ctrl-Space", run: kv }, { mac: "Alt-`", run: kv }, { key: "Escape", run: HR }, { key: "ArrowDown", run: Aa(!0) }, { key: "ArrowUp", run: Aa(!1) }, { key: "PageDown", run: Aa(!0, "page") }, { key: "PageUp", run: Aa(!1, "page") }, { key: "Enter", run: WR }], vI = yr.highest(Iu.computeN([$t], t => t.facet($t).defaultKeymap ? [dw] : [])); class yI { constructor(e, n, i) { this.from = e, this.to = n, this.diagnostic = i } } class Er { constructor(e, n, i) { this.diagnostics = e, this.panel = n, this.selected = i } static init(e, n, i) { let r = e, o = i.facet(kl).markerFilter; o && (r = o(r, i)); let s = de.set(r.map(l => l.from == l.to || l.from == l.to - 1 && i.doc.lineAt(l.from).to == l.from ? de.widget({ widget: new kI(l), diagnostic: l }).range(l.from) : de.mark({ attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") }, diagnostic: l }).range(l.from, l.to)), !0); return new Er(s, n, Xo(s)) } } function Xo(t, e = null, n = 0) { let i = null; return t.between(n, 1e9, (r, o, { spec: s }) => { if (!(e && s.diagnostic != e)) return i = new yI(r, o, s.diagnostic), !1 }), i } function bI(t, e) { let n = e.pos, i = e.end || n, r = t.state.facet(kl).hideOn(t, n, i); if (r != null) return r; let o = t.startState.doc.lineAt(e.pos); return !!(t.effects.some(s => s.is(pw)) || t.changes.touchesRange(o.from, Math.max(o.to, i))) } function OI(t, e) { return t.field(fn, !1) ? e : e.concat(Ce.appendConfig.of(MI)) } const pw = Ce.define(), wg = Ce.define(), gw = Ce.define(), fn = bt.define({ create() { return new Er(de.none, null, null) }, update(t, e) { if (e.docChanged && t.diagnostics.size) { let n = t.diagnostics.map(e.changes), i = null, r = t.panel; if (t.selected) { let o = e.changes.mapPos(t.selected.from, 1); i = Xo(n, t.selected.diagnostic, o) || Xo(n, null, o) } !n.size && r && e.state.facet(kl).autoPanel && (r = null), t = new Er(n, r, i) } for (let n of e.effects) if (n.is(pw)) { let i = e.state.facet(kl).autoPanel ? n.value.length ? Pl.open : null : t.panel; t = Er.init(n.value, i, e.state) } else n.is(wg) ? t = new Er(t.diagnostics, n.value ? Pl.open : null, t.selected) : n.is(gw) && (t = new Er(t.diagnostics, t.panel, n.value)); return t }, provide: t => [Ol.from(t, e => e.panel), ie.decorations.from(t, e => e.diagnostics)] }), SI = de.mark({ class: "cm-lintRange cm-lintRange-active" }); function xI(t, e, n) { let { diagnostics: i } = t.state.field(fn), r = [], o = 2e8, s = 0; i.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (a, c, { spec: u }) => { e >= a && e <= c && (a == c || (e > a || n > 0) && (e < c || n < 0)) && (r.push(u.diagnostic), o = Math.min(a, o), s = Math.max(c, s)) }); let l = t.state.facet(kl).tooltipFilter; return l && (r = l(r, t.state)), r.length ? { pos: o, end: s, above: t.state.doc.lineAt(o).to < s, create() { return { dom: wI(t, r) } } } : null } function wI(t, e) { return Ve("ul", { class: "cm-tooltip-lint" }, e.map(n => vw(t, n, !1))) } const CI = t => { let e = t.state.field(fn, !1); (!e || !e.panel) && t.dispatch({ effects: OI(t.state, [wg.of(!0)]) }); let n = bl(t, Pl.open); return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0 }, Ev = t => { let e = t.state.field(fn, !1); return !e || !e.panel ? !1 : (t.dispatch({ effects: wg.of(!1) }), !0) }, TI = t => { let e = t.state.field(fn, !1); if (!e) return !1; let n = t.state.selection.main, i = e.diagnostics.iter(n.to + 1); return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == n.from && i.to == n.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0) }, $I = [{ key: "Mod-Shift-m", run: CI, preventDefault: !0 }, { key: "F8", run: TI }], kl = se.define({ combine(t) { return Object.assign({ sources: t.map(e => e.source).filter(e => e != null) }, fi(t.map(e => e.config), { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null, hideOn: () => null }, { needsRefresh: (e, n) => e ? n ? i => e(i) || n(i) : e : n })) } }); function mw(t) { let e = []; if (t) e: for (let { name: n } of t) { for (let i = 0; i < n.length; i++) { let r = n[i]; if (/[a-zA-Z]/.test(r) && !e.some(o => o.toLowerCase() == r.toLowerCase())) { e.push(r); continue e } } e.push("") } return e } function vw(t, e, n) { var i; let r = n ? mw(e.actions) : []; return Ve("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ve("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((o, s) => { let l = !1, a = h => { if (h.preventDefault(), l) return; l = !0; let d = Xo(t.state.field(fn).diagnostics, e); d && o.apply(t, d.from, d.to) }, { name: c } = o, u = r[s] ? c.indexOf(r[s]) : -1, f = u < 0 ? c : [c.slice(0, u), Ve("u", c.slice(u, u + 1)), c.slice(u + 1)]; return Ve("button", { type: "button", class: "cm-diagnosticAction", onclick: a, onmousedown: a, "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${r[s]})"`}.` }, f) }), e.source && Ve("div", { class: "cm-diagnosticSource" }, e.source)) } class kI extends Ii { constructor(e) { super(), this.diagnostic = e } eq(e) { return e.diagnostic == this.diagnostic } toDOM() { return Ve("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity }) } } class _v { constructor(e, n) { this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = vw(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option") } } class Pl { constructor(e) { this.view = e, this.items = []; let n = r => { if (r.keyCode == 27) Ev(this.view), this.view.focus(); else if (r.keyCode == 38 || r.keyCode == 33) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length); else if (r.keyCode == 40 || r.keyCode == 34) this.moveSelection((this.selectedIndex + 1) % this.items.length); else if (r.keyCode == 36) this.moveSelection(0); else if (r.keyCode == 35) this.moveSelection(this.items.length - 1); else if (r.keyCode == 13) this.view.focus(); else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) { let { diagnostic: o } = this.items[this.selectedIndex], s = mw(o.actions); for (let l = 0; l < s.length; l++)if (s[l].toUpperCase().charCodeAt(0) == r.keyCode) { let a = Xo(this.view.state.field(fn).diagnostics, o); a && o.actions[l].apply(e, a.from, a.to) } } else return; r.preventDefault() }, i = r => { for (let o = 0; o < this.items.length; o++)this.items[o].dom.contains(r.target) && this.moveSelection(o) }; this.list = Ve("ul", { tabIndex: 0, role: "listbox", "aria-label": this.view.state.phrase("Diagnostics"), onkeydown: n, onclick: i }), this.dom = Ve("div", { class: "cm-panel-lint" }, this.list, Ve("button", { type: "button", name: "close", "aria-label": this.view.state.phrase("close"), onclick: () => Ev(this.view) }, "×")), this.update() } get selectedIndex() { let e = this.view.state.field(fn).selected; if (!e) return -1; for (let n = 0; n < this.items.length; n++)if (this.items[n].diagnostic == e.diagnostic) return n; return -1 } update() { let { diagnostics: e, selected: n } = this.view.state.field(fn), i = 0, r = !1, o = null; for (e.between(0, this.view.state.doc.length, (s, l, { spec: a }) => { let c = -1, u; for (let f = i; f < this.items.length; f++)if (this.items[f].diagnostic == a.diagnostic) { c = f; break } c < 0 ? (u = new _v(this.view, a.diagnostic), this.items.splice(i, 0, u), r = !0) : (u = this.items[c], c > i && (this.items.splice(i, c - i), r = !0)), n && u.diagnostic == n.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), o = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), i++ }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0);)r = !0, this.items.pop(); this.items.length == 0 && (this.items.push(new _v(this.view, { from: -1, to: -1, severity: "info", message: this.view.state.phrase("No diagnostics") })), r = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({ key: this, read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }), write: ({ sel: s, panel: l }) => { let a = l.height / this.list.offsetHeight; s.top < l.top ? this.list.scrollTop -= (l.top - s.top) / a : s.bottom > l.bottom && (this.list.scrollTop += (s.bottom - l.bottom) / a) } })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync() } sync() { let e = this.list.firstChild; function n() { let i = e; e = i.nextSibling, i.remove() } for (let i of this.items) if (i.dom.parentNode == this.list) { for (; e != i.dom;)n(); e = i.dom.nextSibling } else this.list.insertBefore(i.dom, e); for (; e;)n() } moveSelection(e) { if (this.selectedIndex < 0) return; let n = this.view.state.field(fn), i = Xo(n.diagnostics, this.items[e].diagnostic); i && this.view.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0, effects: gw.of(i) }) } static open(e) { return new Pl(e) } } function PI(t, e = 'viewBox="0 0 40 40"') { return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')` } function Ma(t) { return PI(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"') } const AI = ie.baseTheme({ ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" }, ".cm-diagnostic-error": { borderLeft: "5px solid #d11" }, ".cm-diagnostic-warning": { borderLeft: "5px solid orange" }, ".cm-diagnostic-info": { borderLeft: "5px solid #999" }, ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" }, ".cm-diagnosticAction": { font: "inherit", border: "none", padding: "2px 4px", backgroundColor: "#444", color: "white", borderRadius: "3px", marginLeft: "8px", cursor: "pointer" }, ".cm-diagnosticSource": { fontSize: "70%", opacity: .7 }, ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" }, ".cm-lintRange-error": { backgroundImage: Ma("#d11") }, ".cm-lintRange-warning": { backgroundImage: Ma("orange") }, ".cm-lintRange-info": { backgroundImage: Ma("#999") }, ".cm-lintRange-hint": { backgroundImage: Ma("#66d") }, ".cm-lintRange-active": { backgroundColor: "#ffdd9980" }, ".cm-tooltip-lint": { padding: 0, margin: 0 }, ".cm-lintPoint": { position: "relative", "&:after": { content: '""', position: "absolute", bottom: 0, left: "-2px", borderLeft: "3px solid transparent", borderRight: "3px solid transparent", borderBottom: "4px solid #d11" } }, ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } }, ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } }, ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } }, ".cm-panel.cm-panel-lint": { position: "relative", "& ul": { maxHeight: "100px", overflowY: "auto", "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } }, "&:focus [aria-selected]": { background_fallback: "#bdf", backgroundColor: "Highlight", color_fallback: "white", color: "HighlightText" }, "& u": { textDecoration: "none" }, padding: 0, margin: 0 }, "& [name=close]": { position: "absolute", top: "0", right: "2px", background: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 } } }), MI = [fn, ie.decorations.compute([fn], t => { let { selected: e, panel: n } = t.field(fn); return !e || !n || e.from == e.to ? de.none : de.set([SI.range(e.from, e.to)]) }), mE(xI, { hideOn: bI }), AI], Zf = (() => [FS(), AE(), XM(), X2(), b2(), BM(), WM(), _e.allowMultipleSelections.of(!0), o2(), S2(C2, { fallback: !0 }), E2(), sI(), hw(), oE(), aE(), JM(), eR(), Iu.of([...uI, ...G_, ...bR, ...n_, ...g2, ...dw, ...$I])])(); let EI = class Wd { constructor(e, n, i, r, o, s, l, a, c, u = 0, f) { this.p = e, this.stack = n, this.state = i, this.reducePos = r, this.pos = o, this.score = s, this.buffer = l, this.bufferBase = a, this.curContext = c, this.lookAhead = u, this.parent = f } toString() { return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}` } static start(e, n, i = 0) { let r = e.parser.context; return new Wd(e, [], n, i, i, 0, [], 0, r ? new Rv(r, r.start) : null, 0, null) } get context() { return this.curContext ? this.curContext.context : null } pushState(e, n) { this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e } reduce(e) { var n; let i = e >> 19, r = e & 65535, { parser: o } = this.p, s = this.reducePos < this.pos - 25; s && this.setLookAhead(this.pos); let l = o.dynamicPrecedence(r); if (l && (this.score += l), i == 0) { this.pushState(o.getGoto(this.state, r, !0), this.reducePos), r < o.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, s ? 8 : 4, !0), this.reduceContext(r, this.reducePos); return } let a = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), c = a ? this.stack[a - 2] : this.p.ranges[0].from, u = this.reducePos - c; u >= 2e3 && !(!((n = this.p.parser.nodeSet.types[r]) === null || n === void 0) && n.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = u)); let f = a ? this.stack[a - 1] : 0, h = this.bufferBase + this.buffer.length - f; if (r < o.minRepeatTerm || e & 131072) { let d = o.stateFlag(this.state, 1) ? this.pos : this.reducePos; this.storeNode(r, c, d, h + 4, !0) } if (e & 262144) this.state = this.stack[a]; else { let d = this.stack[a - 3]; this.state = o.getGoto(d, r, !0) } for (; this.stack.length > a;)this.stack.pop(); this.reduceContext(r, c) } storeNode(e, n, i, r = 4, o = !1) { if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) { let s = this, l = this.buffer.length; if (l == 0 && s.parent && (l = s.bufferBase - s.parent.bufferBase, s = s.parent), l > 0 && s.buffer[l - 4] == 0 && s.buffer[l - 1] > -1) { if (n == i) return; if (s.buffer[l - 2] >= n) { s.buffer[l - 2] = i; return } } } if (!o || this.pos == i) this.buffer.push(e, n, i, r); else { let s = this.buffer.length; if (s > 0 && this.buffer[s - 4] != 0) { let l = !1; for (let a = s; a > 0 && this.buffer[a - 2] > i; a -= 4)if (this.buffer[a - 1] >= 0) { l = !0; break } if (l) for (; s > 0 && this.buffer[s - 2] > i;)this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, r > 4 && (r -= 4) } this.buffer[s] = e, this.buffer[s + 1] = n, this.buffer[s + 2] = i, this.buffer[s + 3] = r } } shift(e, n, i, r) { if (e & 131072) this.pushState(e & 65535, this.pos); else if (e & 262144) this.pos = r, this.shiftContext(n, i), n <= this.p.parser.maxNode && this.buffer.push(n, i, r, 4); else { let o = e, { parser: s } = this.p; (r > this.pos || n <= s.maxNode) && (this.pos = r, s.stateFlag(o, 1) || (this.reducePos = r)), this.pushState(o, i), this.shiftContext(n, i), n <= s.maxNode && this.buffer.push(n, i, r, 4) } } apply(e, n, i, r) { e & 65536 ? this.reduce(e) : this.shift(e, n, i, r) } useNode(e, n) { let i = this.p.reused.length - 1; (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++); let r = this.pos; this.reducePos = this.pos = r + e.length, this.pushState(n, r), this.buffer.push(i, r, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length))) } split() { let e = this, n = e.buffer.length; for (; n > 0 && e.buffer[n - 2] > e.reducePos;)n -= 4; let i = e.buffer.slice(n), r = e.bufferBase + n; for (; e && r == e.bufferBase;)e = e.parent; return new Wd(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, e) } recoverByDelete(e, n) { let i = e <= this.p.parser.maxNode; i && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, i ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190 } canShift(e) { for (let n = new _I(this); ;) { let i = this.p.parser.stateSlot(n.state, 4) || this.p.parser.hasAction(n.state, e); if (i == 0) return !1; if (!(i & 65536)) return !0; n.reduce(i) } } recoverByInsert(e) { if (this.stack.length >= 300) return []; let n = this.p.parser.nextStates(this.state); if (n.length > 8 || this.stack.length >= 120) { let r = []; for (let o = 0, s; o < n.length; o += 2)(s = n[o + 1]) != this.state && this.p.parser.hasAction(s, e) && r.push(n[o], s); if (this.stack.length < 120) for (let o = 0; r.length < 8 && o < n.length; o += 2) { let s = n[o + 1]; r.some((l, a) => a & 1 && l == s) || r.push(n[o], s) } n = r } let i = []; for (let r = 0; r < n.length && i.length < 4; r += 2) { let o = n[r + 1]; if (o == this.state) continue; let s = this.split(); s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(n[r], this.pos), s.reducePos = this.pos, s.score -= 200, i.push(s) } return i } forceReduce() { let { parser: e } = this.p, n = e.stateSlot(this.state, 5); if (!(n & 65536)) return !1; if (!e.validAction(this.state, n)) { let i = n >> 19, r = n & 65535, o = this.stack.length - i * 3; if (o < 0 || e.getGoto(this.stack[o], r, !1) < 0) { let s = this.findForcedReduction(); if (s == null) return !1; n = s } this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100 } return this.reducePos = this.pos, this.reduce(n), !0 } findForcedReduction() { let { parser: e } = this.p, n = [], i = (r, o) => { if (!n.includes(r)) return n.push(r), e.allActions(r, s => { if (!(s & 393216)) if (s & 65536) { let l = (s >> 19) - o; if (l > 1) { let a = s & 65535, c = this.stack.length - l * 3; if (c >= 0 && e.getGoto(this.stack[c], a, !1) >= 0) return l << 19 | 65536 | a } } else { let l = i(s, o + 1); if (l != null) return l } }) }; return i(this.state, 0) } forceAll() { for (; !this.p.parser.stateFlag(this.state, 2);)if (!this.forceReduce()) { this.storeNode(0, this.pos, this.pos, 4, !0); break } return this } get deadEnd() { if (this.stack.length != 3) return !1; let { parser: e } = this.p; return e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4) } restart() { this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0 } sameState(e) { if (this.state != e.state || this.stack.length != e.stack.length) return !1; for (let n = 0; n < this.stack.length; n += 3)if (this.stack[n] != e.stack[n]) return !1; return !0 } get parser() { return this.p.parser } dialectEnabled(e) { return this.p.parser.dialect.flags[e] } shiftContext(e, n) { this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n))) } reduceContext(e, n) { this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n))) } emitContext() { let e = this.buffer.length - 1; (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3) } emitLookAhead() { let e = this.buffer.length - 1; (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4) } updateContext(e) { if (e != this.curContext.context) { let n = new Rv(this.curContext.tracker, e); n.hash != this.curContext.hash && this.emitContext(), this.curContext = n } } setLookAhead(e) { e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e) } close() { this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead() } }; class Rv { constructor(e, n) { this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0 } } class _I { constructor(e) { this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length } reduce(e) { let n = e & 65535, i = e >> 19; i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3; let r = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0); this.state = r } } class Zc { constructor(e, n, i) { this.stack = e, this.pos = n, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext() } static create(e, n = e.bufferBase + e.buffer.length) { return new Zc(e, n, n - e.bufferBase) } maybeNext() { let e = this.stack.parent; e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer) } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } next() { this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext() } fork() { return new Zc(this.stack, this.pos, this.index) } } function Ea(t, e = Uint16Array) { if (typeof t != "string") return t; let n = null; for (let i = 0, r = 0; i < t.length;) { let o = 0; for (; ;) { let s = t.charCodeAt(i++), l = !1; if (s == 126) { o = 65535; break } s >= 92 && s--, s >= 34 && s--; let a = s - 32; if (a >= 46 && (a -= 46, l = !0), o += a, l) break; o *= 46 } n ? n[r++] = o : n = new e(o) } return n } class ac { constructor() { this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0 } } const Iv = new ac; class RI { constructor(e, n) { this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Iv, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext() } resolveOffset(e, n) { let i = this.range, r = this.rangeIndex, o = this.pos + e; for (; o < i.from;) { if (!r) return null; let s = this.ranges[--r]; o -= i.from - s.to, i = s } for (; n < 0 ? o > i.to : o >= i.to;) { if (r == this.ranges.length - 1) return null; let s = this.ranges[++r]; o += s.from - i.to, i = s } return o } clipPos(e) { if (e >= this.range.from && e < this.range.to) return e; for (let n of this.ranges) if (n.to > e) return Math.max(e, n.from); return this.end } peek(e) { let n = this.chunkOff + e, i, r; if (n >= 0 && n < this.chunk.length) i = this.pos + e, r = this.chunk.charCodeAt(n); else { let o = this.resolveOffset(e, 1); if (o == null) return -1; if (i = o, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length) r = this.chunk2.charCodeAt(i - this.chunk2Pos); else { let s = this.rangeIndex, l = this.range; for (; l.to <= i;)l = this.ranges[++s]; this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - i)), r = this.chunk2.charCodeAt(0) } } return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r } acceptToken(e, n = 0) { let i = n ? this.resolveOffset(n, -1) : this.pos; if (i == null || i < this.token.start) throw new RangeError("Token end out of bounds"); this.token.value = e, this.token.end = i } acceptTokenTo(e, n) { this.token.value = e, this.token.end = n } getChunk() { if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) { let { chunk: e, chunkPos: n } = this; this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos } else { this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos; let e = this.input.chunk(this.pos), n = this.pos + e.length; this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0 } } readNext() { return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff) } advance(e = 1) { for (this.chunkOff += e; this.pos + e >= this.range.to;) { if (this.rangeIndex == this.ranges.length - 1) return this.setDone(); e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from } return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext() } setDone() { return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1 } reset(e, n) { if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = Iv, this.pos != e) { if (this.pos = e, e == this.end) return this.setDone(), this; for (; e < this.range.from;)this.range = this.ranges[--this.rangeIndex]; for (; e >= this.range.to;)this.range = this.ranges[++this.rangeIndex]; e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext() } return this } read(e, n) { if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length) return this.chunk.slice(e - this.chunkPos, n - this.chunkPos); if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos); if (e >= this.range.from && n <= this.range.to) return this.input.read(e, n); let i = ""; for (let r of this.ranges) { if (r.from >= n) break; r.to > e && (i += this.input.read(Math.max(r.from, e), Math.min(r.to, n))) } return i } } class Io { constructor(e, n) { this.data = e, this.id = n } token(e, n) { let { parser: i } = n.p; II(this.data, e, n, this.id, i.data, i.tokenPrecTable) } } Io.prototype.contextual = Io.prototype.fallback = Io.prototype.extend = !1; Io.prototype.fallback = Io.prototype.extend = !1; class qu { constructor(e, n = {}) { this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend } } function II(t, e, n, i, r, o) { let s = 0, l = 1 << i, { dialect: a } = n.p.parser; e: for (; l & t[s];) { let c = t[s + 1]; for (let d = s + 3; d < c; d += 2)if ((t[d + 1] & l) > 0) { let p = t[d]; if (a.allows(p) && (e.token.value == -1 || e.token.value == p || DI(p, e.token.value, r, o))) { e.acceptToken(p); break } } let u = e.next, f = 0, h = t[s + 2]; if (e.next < 0 && h > f && t[c + h * 3 - 3] == 65535) { s = t[c + h * 3 - 1]; continue e } for (; f < h;) { let d = f + h >> 1, p = c + d + (d << 1), g = t[p], m = t[p + 1] || 65536; if (u < g) h = d; else if (u >= m) f = d + 1; else { s = t[p + 2], e.advance(); continue e } } break } } function Dv(t, e, n) { for (let i = e, r; (r = t[i]) != 65535; i++)if (r == n) return i - e; return -1 } function DI(t, e, n, i) { let r = Dv(n, i, e); return r < 0 || Dv(n, i, t) < r } const rn = typeof process < "u" && process.env && /\bparse\b/.test({}.LOG); let Jf = null; function Bv(t, e, n) { let i = t.cursor(ft.IncludeAnonymous); for (i.moveTo(e); ;)if (!(n < 0 ? i.childBefore(e) : i.childAfter(e))) for (; ;) { if ((n < 0 ? i.to < e : i.from > e) && !i.type.isError) return n < 0 ? Math.max(0, Math.min(i.to - 1, e - 25)) : Math.min(t.length, Math.max(i.from + 1, e + 25)); if (n < 0 ? i.prevSibling() : i.nextSibling()) break; if (!i.parent()) return n < 0 ? 0 : t.length } } class BI { constructor(e, n) { this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment() } nextFragment() { let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]; if (e) { for (this.safeFrom = e.openStart ? Bv(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Bv(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length;)this.trees.pop(), this.start.pop(), this.index.pop(); this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom } else this.nextStart = 1e9 } nodeAt(e) { if (e < this.nextStart) return null; for (; this.fragment && this.safeTo <= e;)this.nextFragment(); if (!this.fragment) return null; for (; ;) { let n = this.trees.length - 1; if (n < 0) return this.nextFragment(), null; let i = this.trees[n], r = this.index[n]; if (r == i.children.length) { this.trees.pop(), this.start.pop(), this.index.pop(); continue } let o = i.children[r], s = this.start[n] + i.positions[r]; if (s > e) return this.nextStart = s, null; if (o instanceof at) { if (s == e) { if (s < this.safeFrom) return null; let l = s + o.length; if (l <= this.safeTo) { let a = o.prop($e.lookAhead); if (!a || l + a < this.fragment.to) return o } } this.index[n]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0)) } else this.index[n]++, this.nextStart = s + o.length } } } class LI { constructor(e, n) { this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map(i => new ac) } getActions(e) { let n = 0, i = null, { parser: r } = e.p, { tokenizers: o } = r, s = r.stateSlot(e.state, 3), l = e.curContext ? e.curContext.hash : 0, a = 0; for (let c = 0; c < o.length; c++) { if (!(1 << c & s)) continue; let u = o[c], f = this.tokens[c]; if (!(i && !u.fallback) && ((u.contextual || f.start != e.pos || f.mask != s || f.context != l) && (this.updateCachedToken(f, u, e), f.mask = s, f.context = l), f.lookAhead > f.end + 25 && (a = Math.max(f.lookAhead, a)), f.value != 0)) { let h = n; if (f.extended > -1 && (n = this.addActions(e, f.extended, f.end, n)), n = this.addActions(e, f.value, f.end, n), !u.extend && (i = f, n > h)) break } } for (; this.actions.length > n;)this.actions.pop(); return a && e.setLookAhead(a), !i && e.pos == this.stream.end && (i = new ac, i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, n = this.addActions(e, i.value, i.end, n)), this.mainToken = i, this.actions } getMainToken(e) { if (this.mainToken) return this.mainToken; let n = new ac, { pos: i, p: r } = e; return n.start = i, n.end = Math.min(i + 1, r.stream.end), n.value = i == r.stream.end ? r.parser.eofTerm : 0, n } updateCachedToken(e, n, i) { let r = this.stream.clipPos(i.pos); if (n.token(this.stream.reset(r, e), i), e.value > -1) { let { parser: o } = i.p; for (let s = 0; s < o.specialized.length; s++)if (o.specialized[s] == e.value) { let l = o.specializers[s](this.stream.read(e.start, e.end), i); if (l >= 0 && i.p.parser.dialect.allows(l >> 1)) { l & 1 ? e.extended = l >> 1 : e.value = l >> 1; break } } } else e.value = 0, e.end = this.stream.clipPos(r + 1) } putAction(e, n, i, r) { for (let o = 0; o < r; o += 3)if (this.actions[o] == e) return r; return this.actions[r++] = e, this.actions[r++] = n, this.actions[r++] = i, r } addActions(e, n, i, r) { let { state: o } = e, { parser: s } = e.p, { data: l } = s; for (let a = 0; a < 2; a++)for (let c = s.stateSlot(o, a ? 2 : 1); ; c += 3) { if (l[c] == 65535) if (l[c + 1] == 1) c = xi(l, c + 2); else { r == 0 && l[c + 1] == 2 && (r = this.putAction(xi(l, c + 2), n, i, r)); break } l[c] == n && (r = this.putAction(xi(l, c + 1), n, i, r)) } return r } } class QI { constructor(e, n, i, r) { this.parser = e, this.input = n, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new RI(n, r), this.tokens = new LI(e, this.stream), this.topTerm = e.top[1]; let { from: o } = r[0]; this.stacks = [EI.start(this, e.top[0], o)], this.fragments = i.length && this.stream.end - o > e.bufferLength * 4 ? new BI(i, e.nodeSet) : null } get parsedPos() { return this.minStackPos } advance() { let e = this.stacks, n = this.minStackPos, i = this.stacks = [], r, o; if (this.bigReductionCount > 300 && e.length == 1) { let [s] = e; for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart;); this.bigReductionCount = this.lastBigReductionSize = 0 } for (let s = 0; s < e.length; s++) { let l = e[s]; for (; ;) { if (this.tokens.mainToken = null, l.pos > n) i.push(l); else { if (this.advanceStack(l, i, e)) continue; { r || (r = [], o = []), r.push(l); let a = this.tokens.getMainToken(l); o.push(a.value, a.end) } } break } } if (!i.length) { let s = r && WI(r); if (s) return rn && console.log("Finish with " + this.stackID(s)), this.stackToTree(s); if (this.parser.strict) throw rn && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n); this.recovering || (this.recovering = 5) } if (this.recovering && r) { let s = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, o, i); if (s) return rn && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll()) } if (this.recovering) { let s = this.recovering == 1 ? 1 : this.recovering * 3; if (i.length > s) for (i.sort((l, a) => a.score - l.score); i.length > s;)i.pop(); i.some(l => l.reducePos > n) && this.recovering-- } else if (i.length > 1) { e: for (let s = 0; s < i.length - 1; s++) { let l = i[s]; for (let a = s + 1; a < i.length; a++) { let c = i[a]; if (l.sameState(c) || l.buffer.length > 500 && c.buffer.length > 500) if ((l.score - c.score || l.buffer.length - c.buffer.length) > 0) i.splice(a--, 1); else { i.splice(s--, 1); continue e } } } i.length > 12 && i.splice(12, i.length - 12) } this.minStackPos = i[0].pos; for (let s = 1; s < i.length; s++)i[s].pos < this.minStackPos && (this.minStackPos = i[s].pos); return null } stopAt(e) { if (this.stoppedAt != null && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward"); this.stoppedAt = e } advanceStack(e, n, i) { let r = e.pos, { parser: o } = this, s = rn ? this.stackID(e) + " -> " : ""; if (this.stoppedAt != null && r > this.stoppedAt) return e.forceReduce() ? e : null; if (this.fragments) { let c = e.curContext && e.curContext.tracker.strict, u = c ? e.curContext.hash : 0; for (let f = this.fragments.nodeAt(r); f;) { let h = this.parser.nodeSet.types[f.type.id] == f.type ? o.getGoto(e.state, f.type.id) : -1; if (h > -1 && f.length && (!c || (f.prop($e.contextHash) || 0) == u)) return e.useNode(f, h), rn && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(f.type.id)})`), !0; if (!(f instanceof at) || f.children.length == 0 || f.positions[0] > 0) break; let d = f.children[0]; if (d instanceof at && f.positions[0] == 0) f = d; else break } } let l = o.stateSlot(e.state, 4); if (l > 0) return e.reduce(l), rn && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(l & 65535)})`), !0; if (e.stack.length >= 8400) for (; e.stack.length > 6e3 && e.forceReduce();); let a = this.tokens.getActions(e); for (let c = 0; c < a.length;) { let u = a[c++], f = a[c++], h = a[c++], d = c == a.length || !i, p = d ? e : e.split(), g = this.tokens.mainToken; if (p.apply(u, f, g ? g.start : p.pos, h), rn && console.log(s + this.stackID(p) + ` (via ${u & 65536 ? `reduce of ${o.getName(u & 65535)}` : "shift"} for ${o.getName(f)} @ ${r}${p == e ? "" : ", split"})`), d) return !0; p.pos > r ? n.push(p) : i.push(p) } return !1 } advanceFully(e, n) { let i = e.pos; for (; ;) { if (!this.advanceStack(e, null, null)) return !1; if (e.pos > i) return Lv(e, n), !0 } } runRecovery(e, n, i) { let r = null, o = !1; for (let s = 0; s < e.length; s++) { let l = e[s], a = n[s << 1], c = n[(s << 1) + 1], u = rn ? this.stackID(l) + " -> " : ""; if (l.deadEnd && (o || (o = !0, l.restart(), rn && console.log(u + this.stackID(l) + " (restarted)"), this.advanceFully(l, i)))) continue; let f = l.split(), h = u; for (let d = 0; f.forceReduce() && d < 10 && (rn && console.log(h + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, i)); d++)rn && (h = this.stackID(f) + " -> "); for (let d of l.recoverByInsert(a)) rn && console.log(u + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, i); this.stream.end > l.pos ? (c == l.pos && (c++, a = 0), l.recoverByDelete(a, c), rn && console.log(u + this.stackID(l) + ` (via recover-delete ${this.parser.getName(a)})`), Lv(l, i)) : (!r || r.score < l.score) && (r = l) } return r } stackToTree(e) { return e.close(), at.build({ buffer: Zc.create(e), nodeSet: this.parser.nodeSet, topID: this.topTerm, maxBufferLength: this.parser.bufferLength, reused: this.reused, start: this.ranges[0].from, length: e.pos - this.ranges[0].from, minRepeatType: this.parser.minRepeatTerm }) } stackID(e) { let n = (Jf || (Jf = new WeakMap)).get(e); return n || Jf.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e } } function Lv(t, e) { for (let n = 0; n < e.length; n++) { let i = e[n]; if (i.pos == t.pos && i.sameState(t)) { e[n].score < t.score && (e[n] = t); return } } e.push(t) } class NI { constructor(e, n, i) { this.source = e, this.flags = n, this.disabled = i } allows(e) { return !this.disabled || this.disabled[e] == 0 } } const eh = t => t; class zI { constructor(e) { this.start = e.start, this.shift = e.shift || eh, this.reduce = e.reduce || eh, this.reuse = e.reuse || eh, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1 } } class Jc extends US { constructor(e) { if (super(), this.wrappers = [], e.version != 14) throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`); let n = e.nodeNames.split(" "); this.minRepeatTerm = n.length; for (let l = 0; l < e.repeatNodeCount; l++)n.push(""); let i = Object.keys(e.topRules).map(l => e.topRules[l][1]), r = []; for (let l = 0; l < n.length; l++)r.push([]); function o(l, a, c) { r[l].push([a, a.deserialize(String(c))]) } if (e.nodeProps) for (let l of e.nodeProps) { let a = l[0]; typeof a == "string" && (a = $e[a]); for (let c = 1; c < l.length;) { let u = l[c++]; if (u >= 0) o(u, a, l[c++]); else { let f = l[c + -u]; for (let h = -u; h > 0; h--)o(l[c++], a, f); c++ } } } this.nodeSet = new ig(n.map((l, a) => Jt.define({ name: a >= this.minRepeatTerm ? void 0 : l, id: a, props: r[a], top: i.indexOf(a) > -1, error: a == 0, skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1 }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = jS; let s = Ea(e.tokenData); this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length); for (let l = 0; l < this.specializerSpecs.length; l++)this.specialized[l] = this.specializerSpecs[l].term; this.specializers = this.specializerSpecs.map(Qv), this.states = Ea(e.states, Uint32Array), this.data = Ea(e.stateData), this.goto = Ea(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map(l => typeof l == "number" ? new Io(s, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]] } createParse(e, n, i) { let r = new QI(this, e, n, i); for (let o of this.wrappers) r = o(r, e, n, i); return r } getGoto(e, n, i = !1) { let r = this.goto; if (n >= r[0]) return -1; for (let o = r[n + 1]; ;) { let s = r[o++], l = s & 1, a = r[o++]; if (l && i) return a; for (let c = o + (s >> 1); o < c; o++)if (r[o] == e) return a; if (l) return -1 } } hasAction(e, n) { let i = this.data; for (let r = 0; r < 2; r++)for (let o = this.stateSlot(e, r ? 2 : 1), s; ; o += 3) { if ((s = i[o]) == 65535) if (i[o + 1] == 1) s = i[o = xi(i, o + 2)]; else { if (i[o + 1] == 2) return xi(i, o + 2); break } if (s == n || s == 0) return xi(i, o + 1) } return 0 } stateSlot(e, n) { return this.states[e * 6 + n] } stateFlag(e, n) { return (this.stateSlot(e, 0) & n) > 0 } validAction(e, n) { return !!this.allActions(e, i => i == n ? !0 : null) } allActions(e, n) { let i = this.stateSlot(e, 4), r = i ? n(i) : void 0; for (let o = this.stateSlot(e, 1); r == null; o += 3) { if (this.data[o] == 65535) if (this.data[o + 1] == 1) o = xi(this.data, o + 2); else break; r = n(xi(this.data, o + 1)) } return r } nextStates(e) { let n = []; for (let i = this.stateSlot(e, 1); ; i += 3) { if (this.data[i] == 65535) if (this.data[i + 1] == 1) i = xi(this.data, i + 2); else break; if (!(this.data[i + 2] & 1)) { let r = this.data[i + 1]; n.some((o, s) => s & 1 && o == r) || n.push(this.data[i], r) } } return n } configure(e) { let n = Object.assign(Object.create(Jc.prototype), this); if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) { let i = this.topRules[e.top]; if (!i) throw new RangeError(`Invalid top rule name ${e.top}`); n.top = i } return e.tokenizers && (n.tokenizers = this.tokenizers.map(i => { let r = e.tokenizers.find(o => o.from == i); return r ? r.to : i })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((i, r) => { let o = e.specializers.find(l => l.from == i.external); if (!o) return i; let s = Object.assign(Object.assign({}, i), { external: o.to }); return n.specializers[r] = Qv(s), s })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n } hasWrappers() { return this.wrappers.length > 0 } getName(e) { return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e) } get eofTerm() { return this.maxNode + 1 } get topNode() { return this.nodeSet.types[this.top[1]] } dynamicPrecedence(e) { let n = this.dynamicPrecedences; return n == null ? 0 : n[e] || 0 } parseDialect(e) { let n = Object.keys(this.dialects), i = n.map(() => !1); if (e) for (let o of e.split(" ")) { let s = n.indexOf(o); s >= 0 && (i[s] = !0) } let r = null; for (let o = 0; o < n.length; o++)if (!i[o]) for (let s = this.dialects[n[o]], l; (l = this.data[s++]) != 65535;)(r || (r = new Uint8Array(this.maxTerm + 1)))[l] = 1; return new NI(e, i, r) } static deserialize(e) { return new Jc(e) } } function xi(t, e) { return t[e] | t[e + 1] << 16 } function WI(t) { let e = null; for (let n of t) { let i = n.p.stoppedAt; (n.pos == n.p.stream.end || i != null && n.pos > i) && n.p.parser.stateFlag(n.state, 2) && (!e || e.score < n.score) && (e = n) } return e } function Qv(t) { if (t.external) { let e = t.extend ? 1 : 0; return (n, i) => t.external(n, i) << 1 | e } return t.get } const HI = 1, yw = 194, bw = 195, FI = 196, Nv = 197, jI = 198, qI = 199, VI = 200, XI = 2, Ow = 3, zv = 201, UI = 24, GI = 25, KI = 49, YI = 50, ZI = 55, JI = 56, eD = 57, tD = 59, nD = 60, iD = 61, rD = 62, oD = 63, sD = 65, lD = 238, aD = 71, cD = 241, uD = 242, fD = 243, hD = 244, dD = 245, pD = 246, gD = 247, mD = 248, Sw = 72, vD = 249, yD = 250, bD = 251, OD = 252, SD = 253, xD = 254, wD = 255, CD = 256, TD = 73, $D = 77, kD = 263, PD = 112, AD = 130, MD = 151, ED = 152, _D = 155, Gr = 10, Al = 13, Cg = 32, Vu = 9, Tg = 35, RD = 40, ID = 46, Hd = 123, Wv = 125, xw = 39, ww = 34, DD = 92, BD = 111, LD = 120, QD = 78, ND = 117, zD = 85, WD = new Set([GI, KI, YI, kD, sD, AD, JI, eD, lD, rD, oD, Sw, TD, $D, nD, iD, MD, ED, _D, PD]); function th(t) { return t == Gr || t == Al } function nh(t) { return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 } const HD = new qu((t, e) => { let n; if (t.next < 0) t.acceptToken(qI); else if (e.context.flags & cc) th(t.next) && t.acceptToken(jI, 1); else if (((n = t.peek(-1)) < 0 || th(n)) && e.canShift(Nv)) { let i = 0; for (; t.next == Cg || t.next == Vu;)t.advance(), i++; (t.next == Gr || t.next == Al || t.next == Tg) && t.acceptToken(Nv, -i) } else th(t.next) && t.acceptToken(FI, 1) }, { contextual: !0 }), FD = new qu((t, e) => { let n = e.context; if (n.flags) return; let i = t.peek(-1); if (i == Gr || i == Al) { let r = 0, o = 0; for (; ;) { if (t.next == Cg) r++; else if (t.next == Vu) r += 8 - r % 8; else break; t.advance(), o++ } r != n.indent && t.next != Gr && t.next != Al && t.next != Tg && (r < n.indent ? t.acceptToken(bw, -o) : t.acceptToken(yw)) } }), cc = 1, Cw = 2, vi = 4, yi = 8, bi = 16, Oi = 32; function uc(t, e, n) { this.parent = t, this.indent = e, this.flags = n, this.hash = (t ? t.hash + t.hash << 8 : 0) + e + (e << 4) + n + (n << 6) } const jD = new uc(null, 0, 0); function qD(t) { let e = 0; for (let n = 0; n < t.length; n++)e += t.charCodeAt(n) == Vu ? 8 - e % 8 : 1; return e } const Hv = new Map([[cD, 0], [uD, vi], [fD, yi], [hD, yi | vi], [dD, bi], [pD, bi | vi], [gD, bi | yi], [mD, bi | yi | vi], [vD, Oi], [yD, Oi | vi], [bD, Oi | yi], [OD, Oi | yi | vi], [SD, Oi | bi], [xD, Oi | bi | vi], [wD, Oi | bi | yi], [CD, Oi | bi | yi | vi]].map(([t, e]) => [t, e | Cw])), VD = new zI({ start: jD, reduce(t, e, n, i) { return t.flags & cc && WD.has(e) || (e == aD || e == Sw) && t.flags & Cw ? t.parent : t }, shift(t, e, n, i) { return e == yw ? new uc(t, qD(i.read(i.pos, n.pos)), 0) : e == bw ? t.parent : e == UI || e == ZI || e == tD || e == Ow ? new uc(t, 0, cc) : Hv.has(e) ? new uc(t, 0, Hv.get(e) | t.flags & cc) : t }, hash(t) { return t.hash } }), XD = new qu(t => { for (let e = 0; e < 5; e++) { if (t.next != "print".charCodeAt(e)) return; t.advance() } if (!/\w/.test(String.fromCharCode(t.next))) for (let e = 0; ; e++) { let n = t.peek(e); if (!(n == Cg || n == Vu)) { n != RD && n != ID && n != Gr && n != Al && n != Tg && t.acceptToken(HI); return } } }), UD = new qu((t, e) => { let { flags: n } = e.context, i = n & vi ? ww : xw, r = (n & yi) > 0, o = !(n & bi), s = (n & Oi) > 0, l = t.pos; for (; !(t.next < 0);)if (s && t.next == Hd) if (t.peek(1) == Hd) t.advance(2); else { if (t.pos == l) { t.acceptToken(Ow, 1); return } break } else if (o && t.next == DD) { if (t.pos == l) { t.advance(); let a = t.next; a >= 0 && (t.advance(), GD(t, a)), t.acceptToken(XI); return } break } else if (t.next == i && (!r || t.peek(1) == i && t.peek(2) == i)) { if (t.pos == l) { t.acceptToken(zv, r ? 3 : 1); return } break } else if (t.next == Gr) { if (r) t.advance(); else if (t.pos == l) { t.acceptToken(zv); return } break } else t.advance(); t.pos > l && t.acceptToken(VI) }); function GD(t, e) { if (e == BD) for (let n = 0; n < 2 && t.next >= 48 && t.next <= 55; n++)t.advance(); else if (e == LD) for (let n = 0; n < 2 && nh(t.next); n++)t.advance(); else if (e == ND) for (let n = 0; n < 4 && nh(t.next); n++)t.advance(); else if (e == zD) for (let n = 0; n < 8 && nh(t.next); n++)t.advance(); else if (e == QD && t.next == Hd) { for (t.advance(); t.next >= 0 && t.next != Wv && t.next != xw && t.next != ww && t.next != Gr;)t.advance(); t.next == Wv && t.advance() } } const KD = GS({ 'async "*" "**" FormatConversion FormatSpec': F.modifier, "for while if elif else try except finally return raise break continue with pass assert await yield match case": F.controlKeyword, "in not and or is del": F.operatorKeyword, "from def class global nonlocal lambda": F.definitionKeyword, import: F.moduleKeyword, "with as print": F.keyword, Boolean: F.bool, None: F.null, VariableName: F.variableName, "CallExpression/VariableName": F.function(F.variableName), "FunctionDefinition/VariableName": F.function(F.definition(F.variableName)), "ClassDefinition/VariableName": F.definition(F.className), PropertyName: F.propertyName, "CallExpression/MemberExpression/PropertyName": F.function(F.propertyName), Comment: F.lineComment, Number: F.number, String: F.string, FormatString: F.special(F.string), Escape: F.escape, UpdateOp: F.updateOperator, "ArithOp!": F.arithmeticOperator, BitOp: F.bitwiseOperator, CompareOp: F.compareOperator, AssignOp: F.definitionOperator, Ellipsis: F.punctuation, At: F.meta, "( )": F.paren, "[ ]": F.squareBracket, "{ }": F.brace, ".": F.derefOperator, ", ;": F.separator }), YD = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 }, ZD = Jc.deserialize({ version: 14, states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5QQdO'#DoOOQS,5:Y,5:YO5eQdO'#HdOOQS,5:],5:]O5rQ!fO,5:]O5wQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8gQdO,59bO8lQdO,59bO8sQdO,59jO8zQdO'#HTO:QQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:iQdO,59aO'vQdO,59aO:wQdO,59aOOQS,59y,59yO:|QdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;[QdO,5:QO;aQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;rQdO,5:UO;wQdO,5:WOOOW'#Fy'#FyO;|OWO,5:aOOQS,5:a,5:aO<XQdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<iOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<wQtO,5:iO?iQtO,5=`O@SQ#xO,5=`O@sQtO,5=`OOQS,5:},5:}OA[QeO'#GWOBnQdO,5;^OOQV,5=^,5=^OByQtO'#IPOChQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCpQtO,59]OEwQtO,59iOFbQdO'#HVOFmQdO'#HVO1XQdO'#HVOFxQdO'#DTOGQQdO,59mOGVQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGtQdO'#GPOHUQdO,58|OHUQdO,58|O*xQdO,5:oOHdQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHwQdO,5;OOIYQdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOInQtO,5;QOI|QdO,5;QOJRQdO'#IQOOQS,5;T,5;TOJaQdO'#H|OOQS,5;W,5;WOJrQdO,5;YO4iQdO,5;`O4iQdO,5;cOJzQtO'#ITO'vQdO'#ITOKUQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOKZQeO'#EuOLgQgO,5;fO!!hQdO'#IUO4iQdO,5;jO!!sQdO,5;lO!!{QdO,5;qO!#WQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#_OSO,5=[P!#dOdO,5=[O!&XQtO1G.jO!&`QtO1G.jO!)PQtO1G.jO!)ZQtO1G.jO!+tQtO1G.jO!,XQtO1G.jO!,lQdO'#HcO!,zQtO'#GuO0rQdO'#HcO!-UQdO'#HbOOQS,5:Z,5:ZO!-^QdO,5:ZO!-cQdO'#HeO!-nQdO'#HeO!.RQdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/RQtO1G.|O!/YQtO1G.|O1lQdO1G.|O!/uQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!/|QdO1G/eO!0^QdO1G/eO!0fQdO1G/fO'vQdO'#H[O!0kQdO'#H[O!0pQtO1G.{O!1QQdO,59iO!2WQdO,5=zO!2hQdO,5=zO!2pQdO1G/mO!2uQtO1G/mOOQS1G/l1G/lO!3VQdO,5=uO!3|QdO,5=uO0rQdO1G/qO!4kQdO1G/sO!4pQtO1G/sO!5QQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5bQdO'#HxO0rQdO'#HxO!5sQdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6RQ#xO1G2zO!6rQtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7ZQtO,5>kOOQS1G1`1G1`O!7xQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!7}QdO'#FrO!8YQdO,59oO!8bQdO1G/XO!8lQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9]QdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9nQdO1G.hOOQS1G0Z1G0ZO!9|QdO,5=wO!:^QdO,5=wO0rQdO1G0jO0rQdO1G0jO!:oQdO,5>jO!;QQdO,5>jO1XQdO,5>jO!;cQdO,5>iOOQS-E:R-E:RO!;hQdO1G0lO!;sQdO1G0lO!;xQdO,5>lO!<WQdO,5>lO!<fQdO,5>hO!<|QdO,5>hO!=_QdO'#EpO0rQdO1G0tO!=jQdO1G0tO!=oQgO1G0zO!AmQgO1G0}O!EhQdO,5>oO!ErQdO,5>oO!EzQtO,5>oO0rQdO1G1PO!FUQdO1G1PO4iQdO1G1UO!!sQdO1G1WOOQV,5;a,5;aO!FZQfO,5;aO!F`QgO1G1QO!JaQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JqQdO,5>pO!KOQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KWQdO'#FSO!KiQ!fO1G1WO!KqQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!KvQdO1G1]O!LOQdO'#F^OOQV1G1b1G1bO!#WQtO1G1bPOOO1G2v1G2vP!LTOSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LYQdO,5=|O!LmQdO,5=|OOQS1G/u1G/uO!LuQdO,5>PO!MVQdO,5>PO!M_QdO,5>PO!MrQdO,5>PO!NSQdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8bQdO7+$pO# uQdO1G.|O# |QdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!TQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!eQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!jQdO7+%PO#!rQdO7+%QO#!wQdO1G3fOOQS7+%X7+%XO##XQdO1G3fO##aQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##fQdO1G3aOOQS-E9q-E9qO#$]QdO7+%]OOQS7+%_7+%_O#$kQdO1G3aO#%YQdO7+%_O#%_QdO1G3gO#%oQdO1G3gO#%wQdO7+%]O#%|QdO,5>dO#&gQdO,5>dO#&gQdO,5>dOOQS'#Dx'#DxO#&xO&jO'#DzO#'TO`O'#HyOOOW1G3}1G3}O#'YQdO1G3}O#'bQdO1G3}O#'mQ#xO7+(fO#(^QtO1G2UP#(wQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)UQdO,5=`O#)oQdO,5=`O#*QQtO,5<aO#*eQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#*uQdO7+&UO#+TQdO,5<nO#+iQdO1G4UOOQS-E:Q-E:QO#+zQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,]QdO7+&WOOQS,5<p,5<pO#,hQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#,vQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-^QdO'#EqO#-iQdO'#IRO#-qQdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#-vQgO7+&fO!JdQdO'#GXO4iQdO7+&fO4iQdO7+&iO#1tQtO,5<tO'vQdO,5<tO#2OQdO1G4ZOOQS-E:W-E:WO#2YQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KiQ!fO7+&rO!KqQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2bQdO,5<uO!JdQdO,5<uOOQV7+&l7+&lO#2mQgO7+&lO#6hQdO,5<vO#6sQdO1G4[OOQS-E:Y-E:YO#7QQdO1G4[O#7YQdO'#IWO#7hQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#7sQdO'#IVOOQS,5;n,5;nO#7{QdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8QQfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8VQdO1G3iOOQS,5<c,5<cO#8eQdO1G3hOOQS-E9u-E9uO#8xQdO,5<dO#9TQdO,5<dO#9hQdO1G3kOOQS-E9v-E9vO#9xQdO1G3kO#:QQdO1G3kO#:bQdO1G3kO#9xQdO1G3kOOQS<<H[<<H[O#:mQtO1G1zOOQS<<Hk<<HkP#:zQdO'#FtO8sQdO1G3bO#;XQdO1G3bO#;^QdO<<HkOOQS<<Hl<<HlO#;nQdO7+)QOOQS<<Hs<<HsO#<OQtO1G1yP#<oQdO'#FsO#<|QdO7+)RO#=^QdO7+)RO#=fQdO<<HwO#=kQdO7+({OOQS<<Hy<<HyO#>bQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>gQdO1G4OOOQS-E9y-E9yO#?QQdO1G4OO<XQdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?cO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?nQdO7+)iO#?vQdO1G2zO#@aQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#@rQdO7+)pO#ATQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#AfQdO,5>mO#AtQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#A|QtO1G2`P#BWQdO'#GYO#B_QdO7+)uO#BiQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KiQ!fO<<J^O#FdQgO7+&gOOQV<<JW<<JWO#FnQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JiQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#JtQdO7+)vO#KRQdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KZQdO,5>rOOQS,5>r,5>rO#KfQdO,5>qO#KwQdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LPQdO1G1dOOQS7+)T7+)TP#LUQdO'#FwO#LfQdO1G2OO#LyQdO1G2OO#MZQdO1G2OP#MfQdO'#FxO#MsQdO7+)VO#NTQdO7+)VO#NTQdO7+)VO#N]QdO7+)VO#NmQdO7+(|O8sQdO7+(|OOQSAN>VAN>VO$ WQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$ hQtO1G1|P$ rQdO'#FvOOQS1G2R1G2RP$!PQdO'#F{O$!^QdO7+)jO$!wQdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#VQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$#pQdO<<M[OOQS,5<q,5<qO$$RQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$aQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$([QdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$(iQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$(zQfO7+'OO$)VQdO'#F_O$*^QdO7+'jO$*nQdO7+'jOOQS7+'j7+'jO$*yQdO<<LqO$+ZQdO<<LqO$+ZQdO<<LqO$+cQdO'#H^OOQS<<Lh<<LhO$+mQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,WQdO1G4RO$,`QdO1G4RP!=_QdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$,kQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-_QtO'#FaOOQS'#Fc'#FcO$-oQdO'#FbO$.aQdO'#FbOOQS'#Fb'#FbO$.fQdO'#IYO$)VQdO'#FiO$)VQdO'#FiO$.}QdO'#FjO$)VQdO'#FkO$/UQdO'#IZOOQS'#IZ'#IZO$/sQdO,5;yOOQS<<KU<<KUO$/{QdO<<KUO$0]QdOANB]O$0mQdOANB]O$0uQdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1`QdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$1wQdO7+)mOOQVLD*wLD*wOOQVANARANARO5rQ!fO'#GaO$2PQtO,5<SO$)VQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$2qQdO,5;|O$2vQdO,5;|OOQS'#Fg'#FgO$)VQdO'#G`O$3hQdO,5<QO$4SQdO,5>tO$4dQdO,5>tO1XQdO,5<PO$4uQdO,5<TO$4zQdO,5<TO$)VQdO'#I[O$5PQdO'#I[O$5UQdO,5<UOOQS,5<V,5<VO'vQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5ZQdOG27wO$5kQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$5pQtO'#FaO$5wQdO'#I]O$6VQdO'#I]O$6_QdO,5<XOOQS1G1h1G1hO$6dQdO1G1hO$6iQdO,5<zOOQS-E:^-E:^O$7TQdO,5=OO$7lQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$7|QdO,5>vO$)VQdO,5>vOOQS1G1p1G1pO$8[QtO,5<[OOQU7+'P7+'PO$+cQdO1G/iO$)VQdO,5<YO$8cQdO,5>wO$8jQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)VQdO'#GdO$8rQdO1G4bO$8|QdO1G4bO$9UQdO1G4bOOQS7+%T7+%TO$9dQdO1G1tO$9rQtO'#FaO$9yQdO,5<}OOQS,5<},5<}O$:XQdO1G4cOOQS-E:a-E:aO$)VQdO,5<|O$:`QdO,5<|O$:eQdO7+)|OOQS-E:`-E:`O$:oQdO7+)|O$)VQdO,5<ZP$)VQdO'#GcO$:wQdO1G2hO$)VQdO1G2hP$;VQdO'#GbO$;^QdO<<MhO$;hQdO1G1uO$;vQdO7+(SO8sQdO'#C}O8sQdO,59bO8sQdO,59bO8sQdO,59bO$<UQtO,5=`O8sQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<iQdO'#GOO'vQdO'#GtO$<vQdO,59bO$<{QdO,59bO$=SQdO,59mO$=XQdO1G/UO1sQdO'#DRO8sQdO,59j", stateData: "$=r~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PE`O%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO~OS'iO%['hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#lO%kWi~P!#lOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&gO%mWi%nWi~P!&gOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)eOVWi_Wi%qWi%rWi%sWi~P!)eO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.WOlji~P!.WOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/aOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PE`OV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!N_Olji~P!N_OV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/aOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/aO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$,yO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)cOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/aOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)VOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$,yOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)VOz/zO#[/OO%j.yO!['Oa~O{$da~P%SOg'Pa~P$)VOz0SOg'Pa~Oa0UO!['Oi~P$)cOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$,yO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)VO{0^O~Oa0UO!['Oq~P$)cOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)cOa0UO!['Oy~P$)cO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/aO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~", goto: "!=l'QPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=xPP={>m>pPP'Z'ZPP?PPP'Z'ZPP'Z'Z'Z'Z'Z?T?}'ZP@QP@WD_G{HPPHSH^Hb'ZPPPHeHn'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHtIQIYPIaIgPIaPIaIaPPPIaPKuPLOLYL`KuPIaLiPIaPLpLvPLzM`M}NhLzLzNnN{LzLzLzLz! a! g! j! o! r! |!!S!!`!!r!!x!#S!#Y!#v!#|!$S!$^!$d!$j!$|!%W!%^!%d!%n!%t!%z!&Q!&W!&^!&h!&n!&x!'O!'X!'_!'n!'v!(Q!(XPPPPPPPPPPP!(_!(b!(h!(q!({!)WPPPPPPPPPPPP!-z!/`!3`!6pPP!6x!7X!7b!8Z!8Q!8d!8j!8m!8p!8s!8{!9lPPPPPPPPPPPPPPPPP!9o!9s!9yP!:_!:c!:o!:x!;U!;l!;o!;r!;x!<O!<U!<XP!<a!<j!=f!=i]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r}!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!P!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!R!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!T!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!V!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!X!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!]!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&cVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/Z/s0c0d0e0f0h0i0j0k0n0r%mXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s![!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aR,^*RX#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&bQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QQ/q/VR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uR.S-fhUOn#d#g$j%|&_'w(p(r)t,P%S!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!]!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t", nodeNames: "⚠ print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard", maxTerm: 277, context: VD, nodeProps: [["isolate", -5, 4, 71, 72, 73, 77, ""], ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"], ["openedBy", 23, "(", 54, "[", 58, "{"], ["closedBy", 24, ")", 55, "]", 59, "}"]], propSources: [KD], skippedNodes: [0, 4], repeatNodeCount: 34, tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T", tokenizers: [XD, FD, HD, UD, 0, 1, 2, 3, 4], topRules: { Script: [0, 5] }, specialized: [{ term: 221, get: t => YD[t] || -1 }], tokenPrec: 7652 }), Fv = new BE, Tw = new Set(["Script", "Body", "FunctionDefinition", "ClassDefinition", "LambdaExpression", "ForStatement", "MatchClause"]); function _a(t) { return (e, n, i) => { if (i) return !1; let r = e.node.getChild("VariableName"); return r && n(r, t), !0 } } const JD = { FunctionDefinition: _a("function"), ClassDefinition: _a("class"), ForStatement(t, e, n) { if (n) { for (let i = t.node.firstChild; i; i = i.nextSibling)if (i.name == "VariableName") e(i, "variable"); else if (i.name == "in") break } }, ImportStatement(t, e) { var n, i; let { node: r } = t, o = ((n = r.firstChild) === null || n === void 0 ? void 0 : n.name) == "from"; for (let s = r.getChild("import"); s; s = s.nextSibling)s.name == "VariableName" && ((i = s.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && e(s, o ? "variable" : "namespace") }, AssignStatement(t, e) { for (let n = t.node.firstChild; n; n = n.nextSibling)if (n.name == "VariableName") e(n, "variable"); else if (n.name == ":" || n.name == "AssignOp") break }, ParamList(t, e) { for (let n = null, i = t.node.firstChild; i; i = i.nextSibling)i.name == "VariableName" && (!n || !/\*|AssignOp/.test(n.name)) && e(i, "variable"), n = i }, CapturePattern: _a("variable"), AsPattern: _a("variable"), __proto__: null }; function $w(t, e) { let n = Fv.get(e); if (n) return n; let i = [], r = !0; function o(s, l) { let a = t.sliceString(s.from, s.to); i.push({ label: a, type: l }) } return e.cursor(ft.IncludeAnonymous).iterate(s => { if (s.name) { let l = JD[s.name]; if (l && l(s, o, r) || !r && Tw.has(s.name)) return !1; r = !1 } else if (s.to - s.from > 8192) { for (let l of $w(t, s.node)) i.push(l); return !1 } }), Fv.set(e, i), i } const jv = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, kw = ["String", "FormatString", "Comment", "PropertyName"]; function eB(t) { let e = yt(t.state).resolveInner(t.pos, -1); if (kw.indexOf(e.name) > -1) return null; let n = e.name == "VariableName" || e.to - e.from < 20 && jv.test(t.state.sliceDoc(e.from, e.to)); if (!n && !t.explicit) return null; let i = []; for (let r = e; r; r = r.parent)Tw.has(r.name) && (i = i.concat($w(t.state.doc, r))); return { options: i, from: n ? e.from : t.pos, validFor: jv } } const tB = ["__annotations__", "__builtins__", "__debug__", "__doc__", "__import__", "__name__", "__loader__", "__package__", "__spec__", "False", "None", "True"].map(t => ({ label: t, type: "constant" })).concat(["ArithmeticError", "AssertionError", "AttributeError", "BaseException", "BlockingIOError", "BrokenPipeError", "BufferError", "BytesWarning", "ChildProcessError", "ConnectionAbortedError", "ConnectionError", "ConnectionRefusedError", "ConnectionResetError", "DeprecationWarning", "EOFError", "Ellipsis", "EncodingWarning", "EnvironmentError", "Exception", "FileExistsError", "FileNotFoundError", "FloatingPointError", "FutureWarning", "GeneratorExit", "IOError", "ImportError", "ImportWarning", "IndentationError", "IndexError", "InterruptedError", "IsADirectoryError", "KeyError", "KeyboardInterrupt", "LookupError", "MemoryError", "ModuleNotFoundError", "NameError", "NotADirectoryError", "NotImplemented", "NotImplementedError", "OSError", "OverflowError", "PendingDeprecationWarning", "PermissionError", "ProcessLookupError", "RecursionError", "ReferenceError", "ResourceWarning", "RuntimeError", "RuntimeWarning", "StopAsyncIteration", "StopIteration", "SyntaxError", "SyntaxWarning", "SystemError", "SystemExit", "TabError", "TimeoutError", "TypeError", "UnboundLocalError", "UnicodeDecodeError", "UnicodeEncodeError", "UnicodeError", "UnicodeTranslateError", "UnicodeWarning", "UserWarning", "ValueError", "Warning", "ZeroDivisionError"].map(t => ({ label: t, type: "type" }))).concat(["bool", "bytearray", "bytes", "classmethod", "complex", "float", "frozenset", "int", "list", "map", "memoryview", "object", "range", "set", "staticmethod", "str", "super", "tuple", "type"].map(t => ({ label: t, type: "class" }))).concat(["abs", "aiter", "all", "anext", "any", "ascii", "bin", "breakpoint", "callable", "chr", "compile", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "exit", "filter", "format", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "isinstance", "issubclass", "iter", "len", "license", "locals", "max", "min", "next", "oct", "open", "ord", "pow", "print", "property", "quit", "repr", "reversed", "round", "setattr", "slice", "sorted", "sum", "vars", "zip"].map(t => ({ label: t, type: "function" }))), nB = [pi("def ${name}(${params}):\n	${}", { label: "def", detail: "function", type: "keyword" }), pi("for ${name} in ${collection}:\n	${}", { label: "for", detail: "loop", type: "keyword" }), pi("while ${}:\n	${}", { label: "while", detail: "loop", type: "keyword" }), pi("try:\n	${}\nexcept ${error}:\n	${}", { label: "try", detail: "/ except block", type: "keyword" }), pi(`if \${}:
	
`, { label: "if", detail: "block", type: "keyword" }), pi("if ${}:\n	${}\nelse:\n	${}", { label: "if", detail: "/ else block", type: "keyword" }), pi("class ${name}:\n	def __init__(self, ${params}):\n			${}", { label: "class", detail: "definition", type: "keyword" }), pi("import ${module}", { label: "import", detail: "statement", type: "keyword" }), pi("from ${module} import ${names}", { label: "from", detail: "import", type: "keyword" })], iB = CR(kw, tw(tB.concat(nB))); function qv(t) { let { node: e, pos: n } = t, i = t.lineIndent(n, -1), r = null; for (; ;) { let o = e.childBefore(n); if (o) if (o.name == "Comment") n = o.from; else if (o.name == "Body") t.baseIndentFor(o) + t.unit <= i && (r = o), e = o; else if (o.type.is("Statement")) e = o; else break; else break } return r } function Vv(t, e) { let n = t.baseIndentFor(e), i = t.lineAt(t.pos, -1), r = i.from + i.text.length; return /^\s*($|#)/.test(i.text) && t.node.to < r + 100 && !/\S/.test(t.state.sliceDoc(r, t.node.to)) && t.lineIndent(t.pos, -1) <= n || /^\s*(else:|elif |except |finally:)/.test(t.textAfter) && t.lineIndent(t.pos, -1) > n ? null : n + t.unit } const ih = Qc.define({ name: "python", parser: ZD.configure({ props: [JS.add({ Body: t => { var e; let n = qv(t); return (e = Vv(t, n || t.node)) !== null && e !== void 0 ? e : t.continue() }, IfStatement: t => /^\s*(else:|elif )/.test(t.textAfter) ? t.baseIndent : t.continue(), "ForStatement WhileStatement": t => /^\s*else:/.test(t.textAfter) ? t.baseIndent : t.continue(), TryStatement: t => /^\s*(except |finally:|else:)/.test(t.textAfter) ? t.baseIndent : t.continue(), "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": Ff({ closing: ")" }), "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": Ff({ closing: "}" }), "ArrayExpression ArrayComprehensionExpression": Ff({ closing: "]" }), "String FormatString": () => null, Script: t => { var e; let n = qv(t); return (e = n && Vv(t, n)) !== null && e !== void 0 ? e : t.continue() } }), nx.add({ "ArrayExpression DictionaryExpression SetExpression TupleExpression": l2, Body: (t, e) => ({ from: t.from + 1, to: t.to - (t.to == e.doc.length ? 0 : 1) }) })] }), languageData: { closeBrackets: { brackets: ["(", "[", "{", "'", '"', "'''", '"""'], stringPrefixes: ["f", "fr", "rf", "r", "u", "b", "br", "rb", "F", "FR", "RF", "R", "U", "B", "BR", "RB"] }, commentTokens: { line: "#" }, indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/ } }); function rB() { return new KE(ih, [ih.data.of({ autocomplete: eB }), ih.data.of({ autocomplete: iB })]) } function Ml(t) { "@babel/helpers - typeof"; return Ml = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Ml(t) } function oB(t, e) { if (Ml(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var i = n.call(t, e || "default"); if (Ml(i) != "object") return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function sB(t) { var e = oB(t, "string"); return Ml(e) == "symbol" ? e : e + "" } function lB(t, e, n) { return (e = sB(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Xv(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(t, r).enumerable })), n.push.apply(n, i) } return n } function ee(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? Xv(Object(n), !0).forEach(function (i) { lB(t, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Xv(Object(n)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i)) }) } return t } function S() { return S = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) ({}).hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, S.apply(null, arguments) } const aB = t => typeof t == "function", cB = Array.isArray, uB = t => typeof t == "string", fB = t => t !== null && typeof t == "object", hB = /^on[^a-z]/, dB = t => hB.test(t), Pw = t => { const e = Object.create(null); return n => e[n] || (e[n] = t(n)) }, pB = /-(\w)/g, Xu = Pw(t => t.replace(pB, (e, n) => n ? n.toUpperCase() : "")), gB = /\B([A-Z])/g, mB = Pw(t => t.replace(gB, "-$1").toLowerCase()), vB = Object.prototype.hasOwnProperty, Uv = (t, e) => vB.call(t, e); function yB(t, e, n, i) { const r = t[n]; if (r != null) { const o = Uv(r, "default"); if (o && i === void 0) { const s = r.default; i = r.type !== Function && aB(s) ? s() : s } r.type === Boolean && (!Uv(e, n) && !o ? i = !1 : i === "" && (i = !0)) } return i } function Ts(t) { return typeof t == "number" ? `${t}px` : t } function ke() { const t = []; for (let e = 0; e < arguments.length; e++) { const n = e < 0 || arguments.length <= e ? void 0 : arguments[e]; if (n) { if (uB(n)) t.push(n); else if (cB(n)) for (let i = 0; i < n.length; i++) { const r = ke(n[i]); r && t.push(r) } else if (fB(n)) for (const i in n) n[i] && t.push(i) } } return t.join(" ") } var Aw = function () { if (typeof Map < "u") return Map; function t(e, n) { var i = -1; return e.some(function (r, o) { return r[0] === n ? (i = o, !0) : !1 }), i } return function () { function e() { this.__entries__ = [] } return Object.defineProperty(e.prototype, "size", { get: function () { return this.__entries__.length }, enumerable: !0, configurable: !0 }), e.prototype.get = function (n) { var i = t(this.__entries__, n), r = this.__entries__[i]; return r && r[1] }, e.prototype.set = function (n, i) { var r = t(this.__entries__, n); ~r ? this.__entries__[r][1] = i : this.__entries__.push([n, i]) }, e.prototype.delete = function (n) { var i = this.__entries__, r = t(i, n); ~r && i.splice(r, 1) }, e.prototype.has = function (n) { return !!~t(this.__entries__, n) }, e.prototype.clear = function () { this.__entries__.splice(0) }, e.prototype.forEach = function (n, i) { i === void 0 && (i = null); for (var r = 0, o = this.__entries__; r < o.length; r++) { var s = o[r]; n.call(i, s[1], s[0]) } }, e }() }(), Fd = typeof window < "u" && typeof document < "u" && window.document === document, eu = function () { return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")() }(), bB = function () { return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(eu) : function (t) { return setTimeout(function () { return t(Date.now()) }, 1e3 / 60) } }(), OB = 2; function SB(t, e) { var n = !1, i = !1, r = 0; function o() { n && (n = !1, t()), i && l() } function s() { bB(o) } function l() { var a = Date.now(); if (n) { if (a - r < OB) return; i = !0 } else n = !0, i = !1, setTimeout(s, e); r = a } return l } var xB = 20, wB = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], CB = typeof MutationObserver < "u", TB = function () { function t() { this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = SB(this.refresh.bind(this), xB) } return t.prototype.addObserver = function (e) { ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_() }, t.prototype.removeObserver = function (e) { var n = this.observers_, i = n.indexOf(e); ~i && n.splice(i, 1), !n.length && this.connected_ && this.disconnect_() }, t.prototype.refresh = function () { var e = this.updateObservers_(); e && this.refresh() }, t.prototype.updateObservers_ = function () { var e = this.observers_.filter(function (n) { return n.gatherActive(), n.hasActive() }); return e.forEach(function (n) { return n.broadcastActive() }), e.length > 0 }, t.prototype.connect_ = function () { !Fd || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), CB ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0) }, t.prototype.disconnect_ = function () { !Fd || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1) }, t.prototype.onTransitionEnd_ = function (e) { var n = e.propertyName, i = n === void 0 ? "" : n, r = wB.some(function (o) { return !!~i.indexOf(o) }); r && this.refresh() }, t.getInstance = function () { return this.instance_ || (this.instance_ = new t), this.instance_ }, t.instance_ = null, t }(), Mw = function (t, e) { for (var n = 0, i = Object.keys(e); n < i.length; n++) { var r = i[n]; Object.defineProperty(t, r, { value: e[r], enumerable: !1, writable: !1, configurable: !0 }) } return t }, Uo = function (t) { var e = t && t.ownerDocument && t.ownerDocument.defaultView; return e || eu }, Ew = Uu(0, 0, 0, 0); function tu(t) { return parseFloat(t) || 0 } function Gv(t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; return e.reduce(function (i, r) { var o = t["border-" + r + "-width"]; return i + tu(o) }, 0) } function $B(t) { for (var e = ["top", "right", "bottom", "left"], n = {}, i = 0, r = e; i < r.length; i++) { var o = r[i], s = t["padding-" + o]; n[o] = tu(s) } return n } function kB(t) { var e = t.getBBox(); return Uu(0, 0, e.width, e.height) } function PB(t) { var e = t.clientWidth, n = t.clientHeight; if (!e && !n) return Ew; var i = Uo(t).getComputedStyle(t), r = $B(i), o = r.left + r.right, s = r.top + r.bottom, l = tu(i.width), a = tu(i.height); if (i.boxSizing === "border-box" && (Math.round(l + o) !== e && (l -= Gv(i, "left", "right") + o), Math.round(a + s) !== n && (a -= Gv(i, "top", "bottom") + s)), !MB(t)) { var c = Math.round(l + o) - e, u = Math.round(a + s) - n; Math.abs(c) !== 1 && (l -= c), Math.abs(u) !== 1 && (a -= u) } return Uu(r.left, r.top, l, a) } var AB = function () { return typeof SVGGraphicsElement < "u" ? function (t) { return t instanceof Uo(t).SVGGraphicsElement } : function (t) { return t instanceof Uo(t).SVGElement && typeof t.getBBox == "function" } }(); function MB(t) { return t === Uo(t).document.documentElement } function EB(t) { return Fd ? AB(t) ? kB(t) : PB(t) : Ew } function _B(t) { var e = t.x, n = t.y, i = t.width, r = t.height, o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, s = Object.create(o.prototype); return Mw(s, { x: e, y: n, width: i, height: r, top: n, right: e + i, bottom: r + n, left: e }), s } function Uu(t, e, n, i) { return { x: t, y: e, width: n, height: i } } var RB = function () { function t(e) { this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = Uu(0, 0, 0, 0), this.target = e } return t.prototype.isActive = function () { var e = EB(this.target); return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight }, t.prototype.broadcastRect = function () { var e = this.contentRect_; return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e }, t }(), IB = function () { function t(e, n) { var i = _B(n); Mw(this, { target: e, contentRect: i }) } return t }(), DB = function () { function t(e, n, i) { if (this.activeObservations_ = [], this.observations_ = new Aw, typeof e != "function") throw new TypeError("The callback provided as parameter 1 is not a function."); this.callback_ = e, this.controller_ = n, this.callbackCtx_ = i } return t.prototype.observe = function (e) { if (!arguments.length) throw new TypeError("1 argument required, but only 0 present."); if (!(typeof Element > "u" || !(Element instanceof Object))) { if (!(e instanceof Uo(e).Element)) throw new TypeError('parameter 1 is not of type "Element".'); var n = this.observations_; n.has(e) || (n.set(e, new RB(e)), this.controller_.addObserver(this), this.controller_.refresh()) } }, t.prototype.unobserve = function (e) { if (!arguments.length) throw new TypeError("1 argument required, but only 0 present."); if (!(typeof Element > "u" || !(Element instanceof Object))) { if (!(e instanceof Uo(e).Element)) throw new TypeError('parameter 1 is not of type "Element".'); var n = this.observations_; n.has(e) && (n.delete(e), n.size || this.controller_.removeObserver(this)) } }, t.prototype.disconnect = function () { this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this) }, t.prototype.gatherActive = function () { var e = this; this.clearActive(), this.observations_.forEach(function (n) { n.isActive() && e.activeObservations_.push(n) }) }, t.prototype.broadcastActive = function () { if (this.hasActive()) { var e = this.callbackCtx_, n = this.activeObservations_.map(function (i) { return new IB(i.target, i.broadcastRect()) }); this.callback_.call(e, n, e), this.clearActive() } }, t.prototype.clearActive = function () { this.activeObservations_.splice(0) }, t.prototype.hasActive = function () { return this.activeObservations_.length > 0 }, t }(), _w = typeof WeakMap < "u" ? new WeakMap : new Aw, Rw = function () { function t(e) { if (!(this instanceof t)) throw new TypeError("Cannot call a class as a function."); if (!arguments.length) throw new TypeError("1 argument required, but only 0 present."); var n = TB.getInstance(), i = new DB(e, n, this); _w.set(this, i) } return t }();["observe", "unobserve", "disconnect"].forEach(function (t) { Rw.prototype[t] = function () { var e; return (e = _w.get(this))[t].apply(e, arguments) } }); var Iw = function () { return typeof eu.ResizeObserver < "u" ? eu.ResizeObserver : Rw }(); const BB = t => t != null && t !== "", jd = BB, LB = (t, e) => { const n = S({}, t); return Object.keys(e).forEach(i => { const r = n[i]; if (r) r.type || r.default ? r.default = e[i] : r.def ? r.def(e[i]) : n[i] = { type: r, default: e[i] }; else throw new Error(`not have ${i} prop`) }), n }, to = LB, QB = t => { const e = Object.keys(t), n = {}, i = {}, r = {}; for (let o = 0, s = e.length; o < s; o++) { const l = e[o]; dB(l) ? (n[l[2].toLowerCase() + l.slice(3)] = t[l], i[l] = t[l]) : r[l] = t[l] } return { onEvents: i, events: n, extraAttrs: r } }, NB = function () { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; const n = {}, i = /;(?![^(]*\))/g, r = /:(.+)/; return typeof t == "object" ? t : (t.split(i).forEach(function (o) { if (o) { const s = o.split(r); if (s.length > 1) { const l = e ? Xu(s[0].trim()) : s[0].trim(); n[l] = s[1].trim() } } }), n) }, zB = (t, e) => t[e] !== void 0, Dw = Symbol("skipFlatten"), Ft = function () { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; const n = Array.isArray(t) ? t : [t], i = []; return n.forEach(r => { Array.isArray(r) ? i.push(...Ft(r, e)) : r && r.type === et ? r.key === Dw ? i.push(r) : i.push(...Ft(r.children, e)) : r && wn(r) ? e && !$g(r) ? i.push(r) : e || i.push(r) : jd(r) && i.push(r) }), i }, WB = function (t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; if (wn(t)) return t.type === et ? e === "default" ? Ft(t.children) : [] : t.children && t.children[e] ? Ft(t.children[e](n)) : []; { const i = t.$slots[e] && t.$slots[e](n); return Ft(i) } }, Ji = t => { var e; let n = ((e = t == null ? void 0 : t.vnode) === null || e === void 0 ? void 0 : e.el) || t && (t.$el || t); for (; n && !n.tagName;)n = n.nextSibling; return n }, HB = t => { const e = {}; if (t.$ && t.$.vnode) { const n = t.$.vnode.props || {}; Object.keys(t.$props).forEach(i => { const r = t.$props[i], o = mB(i); (r !== void 0 || o in n) && (e[i] = r) }) } else if (wn(t) && typeof t.type == "object") { const n = t.props || {}, i = {}; Object.keys(n).forEach(o => { i[Xu(o)] = n[o] }); const r = t.type.props || {}; Object.keys(r).forEach(o => { const s = yB(r, i, o, i[o]); (s !== void 0 || o in i) && (e[o] = s) }) } return e }, FB = function (t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, r; if (t.$) { const o = t[e]; if (o !== void 0) return typeof o == "function" && i ? o(n) : o; r = t.$slots[e], r = i && r ? r(n) : r } else if (wn(t)) { const o = t.props && t.props[e]; if (o !== void 0 && t.props !== null) return typeof o == "function" && i ? o(n) : o; t.type === et ? r = t.children : t.children && t.children[e] && (r = t.children[e], r = i && r ? r(n) : r) } return Array.isArray(r) && (r = Ft(r), r = r.length === 1 ? r[0] : r, r = r.length === 0 ? void 0 : r), r }; function Kv() { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = {}; return t.$ ? n = S(S({}, n), t.$attrs) : n = S(S({}, n), t.props), QB(n)[e ? "onEvents" : "events"] } function jB(t, e) { let i = ((wn(t) ? t.props : t.$attrs) || {}).style || {}; if (typeof i == "string") i = NB(i, e); else if (e && i) { const r = {}; return Object.keys(i).forEach(o => r[Xu(o)] = i[o]), r } return i } function qB(t) { return t.length === 1 && t[0].type === et } function $g(t) { return t && (t.type === Ut || t.type === et && t.children.length === 0 || t.type === rs && t.children.trim() === "") } function us() { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; const e = []; return t.forEach(n => { Array.isArray(n) ? e.push(...n) : (n == null ? void 0 : n.type) === et ? e.push(...us(n.children)) : e.push(n) }), e.filter(n => !$g(n)) } function $s(t) { if (t) { const e = us(t); return e.length ? e : void 0 } else return t } function Gu(t) { return Array.isArray(t) && t.length === 1 && (t = t[0]), t && t.__v_isVNode && typeof t.type != "symbol" } function Do(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default"; var i, r; return (i = e[n]) !== null && i !== void 0 ? i : (r = t[n]) === null || r === void 0 ? void 0 : r.call(t) } const nu = ue({ compatConfig: { MODE: 3 }, name: "ResizeObserver", props: { disabled: Boolean, onResize: Function }, emits: ["resize"], setup(t, e) { let { slots: n } = e; const i = eo({ width: 0, height: 0, offsetHeight: 0, offsetWidth: 0 }); let r = null, o = null; const s = () => { o && (o.disconnect(), o = null) }, l = u => { const { onResize: f } = t, h = u[0].target, { width: d, height: p } = h.getBoundingClientRect(), { offsetWidth: g, offsetHeight: m } = h, v = Math.floor(d), b = Math.floor(p); if (i.width !== v || i.height !== b || i.offsetWidth !== g || i.offsetHeight !== m) { const x = { width: v, height: b, offsetWidth: g, offsetHeight: m }; S(i, x), f && Promise.resolve().then(() => { f(S(S({}, x), { offsetWidth: g, offsetHeight: m }), h) }) } }, a = vr(), c = () => { const { disabled: u } = t; if (u) { s(); return } const f = Ji(a); f !== r && (s(), r = f), !o && f && (o = new Iw(l), o.observe(f)) }; return vt(() => { c() }), is(() => { c() }), Wl(() => { s() }), Te(() => t.disabled, () => { c() }, { flush: "post" }), () => { var u; return (u = n.default) === null || u === void 0 ? void 0 : u.call(n)[0] } } }); let Bw = t => setTimeout(t, 16), Lw = t => clearTimeout(t); typeof window < "u" && "requestAnimationFrame" in window && (Bw = t => window.requestAnimationFrame(t), Lw = t => window.cancelAnimationFrame(t)); let Yv = 0; const kg = new Map; function Qw(t) { kg.delete(t) } function nt(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1; Yv += 1; const n = Yv; function i(r) { if (r === 0) Qw(n), t(); else { const o = Bw(() => { i(r - 1) }); kg.set(n, o) } } return i(e), n } nt.cancel = t => { const e = kg.get(t); return Qw(e), Lw(e) }; const iu = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return e }, Kl = t => { const e = t; return e.install = function (n) { n.component(e.displayName || e.name, t) }, t }; function Zv() { return { type: [Function, Array] } } function zt(t) { return { type: Object, default: t } } function Nr(t) { return { type: Boolean, default: t } } function An(t) { return { type: Function, default: t } } function qd(t, e) { const n = { validator: () => !0, default: t }; return n } function rh() { return { validator: () => !0 } } function Vd(t) { return { type: Array, default: t } } function So(t) { return { type: String, default: t } } function el(t, e) { return t ? { type: t, default: e } : qd(e) } let Nw = !1; try { const t = Object.defineProperty({}, "passive", { get() { Nw = !0 } }); window.addEventListener("testPassive", null, t), window.removeEventListener("testPassive", null, t) } catch { } const xo = Nw; function Qs(t, e, n, i) { if (t && t.addEventListener) { let r = i; r === void 0 && xo && (e === "touchstart" || e === "touchmove" || e === "wheel") && (r = { passive: !1 }), t.addEventListener(e, n, r) } return { remove: () => { t && t.removeEventListener && t.removeEventListener(e, n) } } } const VB = "anticon", zw = Symbol("configProvider"), Ww = { getPrefixCls: (t, e) => e || (t ? `ant-${t}` : "ant"), iconPrefixCls: E(() => VB), getPopupContainer: E(() => () => document.body), direction: E(() => "ltr") }, XB = () => Ke(zw, Ww), UB = Symbol("DisabledContextKey"), Hw = () => Ke(UB, he(void 0)), GB = { items_per_page: "/ page", jump_to: "Go to", jump_to_confirm: "confirm", page: "", prev_page: "Previous Page", next_page: "Next Page", prev_5: "Previous 5 Pages", next_5: "Next 5 Pages", prev_3: "Previous 3 Pages", next_3: "Next 3 Pages" }, KB = { locale: "en_US", today: "Today", now: "Now", backToToday: "Back to today", ok: "Ok", clear: "Clear", month: "Month", year: "Year", timeSelect: "select time", dateSelect: "select date", weekSelect: "Choose a week", monthSelect: "Choose a month", yearSelect: "Choose a year", decadeSelect: "Choose a decade", yearFormat: "YYYY", dateFormat: "M/D/YYYY", dayFormat: "D", dateTimeFormat: "M/D/YYYY HH:mm:ss", monthBeforeYear: !0, previousMonth: "Previous month (PageUp)", nextMonth: "Next month (PageDown)", previousYear: "Last year (Control + left)", nextYear: "Next year (Control + right)", previousDecade: "Last decade", nextDecade: "Next decade", previousCentury: "Last century", nextCentury: "Next century" }, YB = KB, ZB = { placeholder: "Select time", rangePlaceholder: ["Start time", "End time"] }, Fw = ZB, JB = { lang: S({ placeholder: "Select date", yearPlaceholder: "Select year", quarterPlaceholder: "Select quarter", monthPlaceholder: "Select month", weekPlaceholder: "Select week", rangePlaceholder: ["Start date", "End date"], rangeYearPlaceholder: ["Start year", "End year"], rangeQuarterPlaceholder: ["Start quarter", "End quarter"], rangeMonthPlaceholder: ["Start month", "End month"], rangeWeekPlaceholder: ["Start week", "End week"] }, YB), timePickerLocale: S({}, Fw) }, Jv = JB, on = "${label} is not a valid ${type}", e5 = { locale: "en", Pagination: GB, DatePicker: Jv, TimePicker: Fw, Calendar: Jv, global: { placeholder: "Please select" }, Table: { filterTitle: "Filter menu", filterConfirm: "OK", filterReset: "Reset", filterEmptyText: "No filters", filterCheckall: "Select all items", filterSearchPlaceholder: "Search in filters", emptyText: "No data", selectAll: "Select current page", selectInvert: "Invert current page", selectNone: "Clear all data", selectionAll: "Select all data", sortTitle: "Sort", expand: "Expand row", collapse: "Collapse row", triggerDesc: "Click to sort descending", triggerAsc: "Click to sort ascending", cancelSort: "Click to cancel sorting" }, Tour: { Next: "Next", Previous: "Previous", Finish: "Finish" }, Modal: { okText: "OK", cancelText: "Cancel", justOkText: "OK" }, Popconfirm: { okText: "OK", cancelText: "Cancel" }, Transfer: { titles: ["", ""], searchPlaceholder: "Search here", itemUnit: "item", itemsUnit: "items", remove: "Remove", selectCurrent: "Select current page", removeCurrent: "Remove current page", selectAll: "Select all data", removeAll: "Remove all data", selectInvert: "Invert current page" }, Upload: { uploading: "Uploading...", removeFile: "Remove file", uploadError: "Upload error", previewFile: "Preview file", downloadFile: "Download file" }, Empty: { description: "No data" }, Icon: { icon: "icon" }, Text: { edit: "Edit", copy: "Copy", copied: "Copied", expand: "Expand" }, PageHeader: { back: "Back" }, Form: { optional: "(optional)", defaultValidateMessages: { default: "Field validation error for ${label}", required: "Please enter ${label}", enum: "${label} must be one of [${enum}]", whitespace: "${label} cannot be a blank character", date: { format: "${label} date format is invalid", parse: "${label} cannot be converted to a date", invalid: "${label} is an invalid date" }, types: { string: on, method: on, array: on, object: on, number: on, date: on, boolean: on, integer: on, float: on, regexp: on, email: on, url: on, hex: on }, string: { len: "${label} must be ${len} characters", min: "${label} must be at least ${min} characters", max: "${label} must be up to ${max} characters", range: "${label} must be between ${min}-${max} characters" }, number: { len: "${label} must be equal to ${len}", min: "${label} must be minimum ${min}", max: "${label} must be maximum ${max}", range: "${label} must be between ${min}-${max}" }, array: { len: "Must be ${len} ${label}", min: "At least ${min} ${label}", max: "At most ${max} ${label}", range: "The amount of ${label} must be between ${min}-${max}" }, pattern: { mismatch: "${label} does not match the pattern ${pattern}" } } }, Image: { preview: "Preview" }, QRCode: { expired: "QR code expired", refresh: "Refresh", scanned: "Scanned" } }, ey = e5, t5 = ue({ compatConfig: { MODE: 3 }, name: "LocaleReceiver", props: { componentName: String, defaultLocale: { type: [Object, Function] }, children: { type: Function } }, setup(t, e) { let { slots: n } = e; const i = Ke("localeData", {}), r = E(() => { const { componentName: s = "global", defaultLocale: l } = t, a = l || ey[s || "global"], { antLocale: c } = i, u = s && c ? c[s] : {}; return S(S({}, typeof a == "function" ? a() : a), u || {}) }), o = E(() => { const { antLocale: s } = i, l = s && s.locale; return s && s.exist && !l ? ey.locale : l }); return () => { const s = t.children || n.default, { antLocale: l } = i; return s == null ? void 0 : s(r.value, o.value, l) } } }); function Pg(t) { for (var e = 0, n, i = 0, r = t.length; r >= 4; ++i, r -= 4)n = t.charCodeAt(i) & 255 | (t.charCodeAt(++i) & 255) << 8 | (t.charCodeAt(++i) & 255) << 16 | (t.charCodeAt(++i) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16); switch (r) { case 3: e ^= (t.charCodeAt(i + 2) & 255) << 16; case 2: e ^= (t.charCodeAt(i + 1) & 255) << 8; case 1: e ^= t.charCodeAt(i) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16) }return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36) } const ty = "%"; class n5 { constructor(e) { this.cache = new Map, this.instanceId = e } get(e) { return this.cache.get(Array.isArray(e) ? e.join(ty) : e) || null } update(e, n) { const i = Array.isArray(e) ? e.join(ty) : e, r = this.cache.get(i), o = n(r); o === null ? this.cache.delete(i) : this.cache.set(i, o) } } const i5 = n5, jw = "data-token-hash", zr = "data-css-hash", wo = "__cssinjs_instance__"; function El() { const t = Math.random().toString(12).slice(2); if (typeof document < "u" && document.head && document.body) { const e = document.body.querySelectorAll(`style[${zr}]`) || [], { firstChild: n } = document.head; Array.from(e).forEach(r => { r[wo] = r[wo] || t, r[wo] === t && document.head.insertBefore(r, n) }); const i = {}; Array.from(document.querySelectorAll(`style[${zr}]`)).forEach(r => { var o; const s = r.getAttribute(zr); i[s] ? r[wo] === t && ((o = r.parentNode) === null || o === void 0 || o.removeChild(r)) : i[s] = !0 }) } return new i5(t) } const qw = Symbol("StyleContextKey"), r5 = () => { var t, e, n; const i = vr(); let r; if (i && i.appContext) { const o = (n = (e = (t = i.appContext) === null || t === void 0 ? void 0 : t.config) === null || e === void 0 ? void 0 : e.globalProperties) === null || n === void 0 ? void 0 : n.__ANTDV_CSSINJS_CACHE__; o ? r = o : (r = El(), i.appContext.config.globalProperties && (i.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = r)) } else r = El(); return r }, Vw = { cache: El(), defaultCache: !0, hashPriority: "low" }, Ku = () => { const t = r5(); return Ke(qw, oe(S(S({}, Vw), { cache: t }))) }, o5 = t => { const e = Ku(), n = oe(S(S({}, Vw), { cache: El() })); return Te([() => gt(t), e], () => { const i = S({}, e.value), r = gt(t); Object.keys(r).forEach(s => { const l = r[s]; r[s] !== void 0 && (i[s] = l) }); const { cache: o } = r; i.cache = i.cache || El(), i.defaultCache = !o && e.value.defaultCache, n.value = i }, { immediate: !0 }), en(qw, n), n }, s5 = () => ({ autoClear: Nr(), mock: So(), cache: zt(), defaultCache: Nr(), hashPriority: So(), container: el(), ssrInline: Nr(), transformers: Vd(), linters: Vd() }); Kl(ue({ name: "AStyleProvider", inheritAttrs: !1, props: s5(), setup(t, e) { let { slots: n } = e; return o5(t), () => { var i; return (i = n.default) === null || i === void 0 ? void 0 : i.call(n) } } })); function Xw(t, e, n, i) { const r = Ku(), o = oe(""), s = oe(); hn(() => { o.value = [t, ...e.value].join("%") }); const l = a => { r.value.cache.update(a, c => { const [u = 0, f] = c || []; return u - 1 === 0 ? (i == null || i(f, !1), null) : [u - 1, f] }) }; return Te(o, (a, c) => { c && l(c), r.value.cache.update(a, u => { const [f = 0, h] = u || [], p = h || n(); return [f + 1, p] }), s.value = r.value.cache.get(o.value)[1] }, { immediate: !0 }), At(() => { l(o.value) }), s } function si() { return !!(typeof window < "u" && window.document && window.document.createElement) } function _r(t, e) { return t && t.contains ? t.contains(e) : !1 } const ny = "data-vc-order", l5 = "vc-util-key", Xd = new Map; function Uw() { let { mark: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return t ? t.startsWith("data-") ? t : `data-${t}` : l5 } function Yu(t) { return t.attachTo ? t.attachTo : document.querySelector("head") || document.body } function a5(t) { return t === "queue" ? "prependQueue" : t ? "prepend" : "append" } function Gw(t) { return Array.from((Xd.get(t) || t).children).filter(e => e.tagName === "STYLE") } function Kw(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (!si()) return null; const { csp: n, prepend: i } = e, r = document.createElement("style"); r.setAttribute(ny, a5(i)), n != null && n.nonce && (r.nonce = n == null ? void 0 : n.nonce), r.innerHTML = t; const o = Yu(e), { firstChild: s } = o; if (i) { if (i === "queue") { const l = Gw(o).filter(a => ["prepend", "prependQueue"].includes(a.getAttribute(ny))); if (l.length) return o.insertBefore(r, l[l.length - 1].nextSibling), r } o.insertBefore(r, s) } else o.appendChild(r); return r } function Yw(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const n = Yu(e); return Gw(n).find(i => i.getAttribute(Uw(e)) === t) } function ru(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const n = Yw(t, e); n && Yu(e).removeChild(n) } function c5(t, e) { const n = Xd.get(t); if (!n || !_r(document, n)) { const i = Kw("", e), { parentNode: r } = i; Xd.set(t, r), t.removeChild(i) } } function ou(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; var i, r, o; const s = Yu(n); c5(s, n); const l = Yw(e, n); if (l) return !((i = n.csp) === null || i === void 0) && i.nonce && l.nonce !== ((r = n.csp) === null || r === void 0 ? void 0 : r.nonce) && (l.nonce = (o = n.csp) === null || o === void 0 ? void 0 : o.nonce), l.innerHTML !== t && (l.innerHTML = t), l; const a = Kw(t, n); return a.setAttribute(Uw(n), e), a } function u5(t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1; return !0 } class Go { constructor() { this.cache = new Map, this.keys = [], this.cacheCallTimes = 0 } size() { return this.keys.length } internalGet(e) { let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = { map: this.cache }; return e.forEach(r => { var o; i ? i = (o = i == null ? void 0 : i.map) === null || o === void 0 ? void 0 : o.get(r) : i = void 0 }), i != null && i.value && n && (i.value[1] = this.cacheCallTimes++), i == null ? void 0 : i.value } get(e) { var n; return (n = this.internalGet(e, !0)) === null || n === void 0 ? void 0 : n[0] } has(e) { return !!this.internalGet(e) } set(e, n) { if (!this.has(e)) { if (this.size() + 1 > Go.MAX_CACHE_SIZE + Go.MAX_CACHE_OFFSET) { const [r] = this.keys.reduce((o, s) => { const [, l] = o; return this.internalGet(s)[1] < l ? [s, this.internalGet(s)[1]] : o }, [this.keys[0], this.cacheCallTimes]); this.delete(r) } this.keys.push(e) } let i = this.cache; e.forEach((r, o) => { if (o === e.length - 1) i.set(r, { value: [n, this.cacheCallTimes++] }); else { const s = i.get(r); s ? s.map || (s.map = new Map) : i.set(r, { map: new Map }), i = i.get(r).map } }) } deleteByPath(e, n) { var i; const r = e.get(n[0]); if (n.length === 1) return r.map ? e.set(n[0], { map: r.map }) : e.delete(n[0]), (i = r.value) === null || i === void 0 ? void 0 : i[0]; const o = this.deleteByPath(r.map, n.slice(1)); return (!r.map || r.map.size === 0) && !r.value && e.delete(n[0]), o } delete(e) { if (this.has(e)) return this.keys = this.keys.filter(n => !u5(n, e)), this.deleteByPath(this.cache, e) } } Go.MAX_CACHE_SIZE = 20; Go.MAX_CACHE_OFFSET = 5; let iy = {}; function f5(t, e) { } function h5(t, e, n) { !e && !iy[n] && (t(!1, n), iy[n] = !0) } function d5(t, e) { h5(f5, t, e) } function p5() { } let g5 = p5; const Zw = g5; let ry = 0; class Jw { constructor(e) { this.derivatives = Array.isArray(e) ? e : [e], this.id = ry, e.length === 0 && Zw(e.length > 0), ry += 1 } getDerivativeToken(e) { return this.derivatives.reduce((n, i) => i(e, n), void 0) } } const oh = new Go; function m5(t) { const e = Array.isArray(t) ? t : [t]; return oh.has(e) || oh.set(e, new Jw(e)), oh.get(e) } const oy = new WeakMap; function su(t) { let e = oy.get(t) || ""; return e || (Object.keys(t).forEach(n => { const i = t[n]; e += n, i instanceof Jw ? e += i.id : i && typeof i == "object" ? e += su(i) : e += i }), oy.set(t, e)), e } function v5(t, e) { return Pg(`${e}_${su(t)}`) } const tl = `random-${Date.now()}-${Math.random()}`.replace(/\./g, ""), eC = "_bAmBoO_"; function y5(t, e, n) { var i, r; if (si()) { ou(t, tl); const o = document.createElement("div"); o.style.position = "fixed", o.style.left = "0", o.style.top = "0", e == null || e(o), document.body.appendChild(o); const s = n ? n(o) : (i = getComputedStyle(o).content) === null || i === void 0 ? void 0 : i.includes(eC); return (r = o.parentNode) === null || r === void 0 || r.removeChild(o), ru(tl), s } return !1 } let sh; function b5() { return sh === void 0 && (sh = y5(`@layer ${tl} { .${tl} { content: "${eC}"!important; } }`, t => { t.className = tl })), sh } const sy = {}, O5 = !0, S5 = !1, x5 = !O5 && !S5 ? "css-dev-only-do-not-override" : "css", Rr = new Map; function w5(t) { Rr.set(t, (Rr.get(t) || 0) + 1) } function C5(t, e) { typeof document < "u" && document.querySelectorAll(`style[${jw}="${t}"]`).forEach(i => { var r; i[wo] === e && ((r = i.parentNode) === null || r === void 0 || r.removeChild(i)) }) } const T5 = 0; function $5(t, e) { Rr.set(t, (Rr.get(t) || 0) - 1); const n = Array.from(Rr.keys()), i = n.filter(r => (Rr.get(r) || 0) <= 0); n.length - i.length > T5 && i.forEach(r => { C5(r, e), Rr.delete(r) }) } const k5 = (t, e, n, i) => { const r = n.getDerivativeToken(t); let o = S(S({}, r), e); return i && (o = i(o)), o }; function P5(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : he({}); const i = Ku(), r = E(() => S({}, ...e.value)), o = E(() => su(r.value)), s = E(() => su(n.value.override || sy)); return Xw("token", E(() => [n.value.salt || "", t.value.id, o.value, s.value]), () => { const { salt: a = "", override: c = sy, formatToken: u, getComputedToken: f } = n.value, h = f ? f(r.value, c, t.value) : k5(r.value, c, t.value, u), d = v5(h, a); h._tokenKey = d, w5(d); const p = `${x5}-${Pg(d)}`; return h._hashId = p, [h, p] }, a => { var c; $5(a[0]._tokenKey, (c = i.value) === null || c === void 0 ? void 0 : c.cache.instanceId) }) } var A5 = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, tC = "comm", nC = "rule", iC = "decl", M5 = "@import", E5 = "@keyframes", _5 = "@layer", rC = Math.abs, Ag = String.fromCharCode; function oC(t) { return t.trim() } function fc(t, e, n) { return t.replace(e, n) } function R5(t, e, n) { return t.indexOf(e, n) } function _l(t, e) { return t.charCodeAt(e) | 0 } function Ko(t, e, n) { return t.slice(e, n) } function Un(t) { return t.length } function I5(t) { return t.length } function Ra(t, e) { return e.push(t), t } var Zu = 1, Yo = 1, sC = 0, Tn = 0, st = 0, fs = ""; function Mg(t, e, n, i, r, o, s, l) { return { value: t, root: e, parent: n, type: i, props: r, children: o, line: Zu, column: Yo, length: s, return: "", siblings: l } } function D5() { return st } function B5() { return st = Tn > 0 ? _l(fs, --Tn) : 0, Yo--, st === 10 && (Yo = 1, Zu--), st } function Dn() { return st = Tn < sC ? _l(fs, Tn++) : 0, Yo++, st === 10 && (Yo = 1, Zu++), st } function er() { return _l(fs, Tn) } function hc() { return Tn } function Ju(t, e) { return Ko(fs, t, e) } function Rl(t) { switch (t) { case 0: case 9: case 10: case 13: case 32: return 5; case 33: case 43: case 44: case 47: case 62: case 64: case 126: case 59: case 123: case 125: return 4; case 58: return 3; case 34: case 39: case 40: case 91: return 2; case 41: case 93: return 1 }return 0 } function L5(t) { return Zu = Yo = 1, sC = Un(fs = t), Tn = 0, [] } function Q5(t) { return fs = "", t } function lh(t) { return oC(Ju(Tn - 1, Ud(t === 91 ? t + 2 : t === 40 ? t + 1 : t))) } function N5(t) { for (; (st = er()) && st < 33;)Dn(); return Rl(t) > 2 || Rl(st) > 3 ? "" : " " } function z5(t, e) { for (; --e && Dn() && !(st < 48 || st > 102 || st > 57 && st < 65 || st > 70 && st < 97);); return Ju(t, hc() + (e < 6 && er() == 32 && Dn() == 32)) } function Ud(t) { for (; Dn();)switch (st) { case t: return Tn; case 34: case 39: t !== 34 && t !== 39 && Ud(st); break; case 40: t === 41 && Ud(t); break; case 92: Dn(); break }return Tn } function W5(t, e) { for (; Dn() && t + st !== 47 + 10;)if (t + st === 42 + 42 && er() === 47) break; return "/*" + Ju(e, Tn - 1) + "*" + Ag(t === 47 ? t : Dn()) } function H5(t) { for (; !Rl(er());)Dn(); return Ju(t, Tn) } function F5(t) { return Q5(dc("", null, null, null, [""], t = L5(t), 0, [0], t)) } function dc(t, e, n, i, r, o, s, l, a) { for (var c = 0, u = 0, f = s, h = 0, d = 0, p = 0, g = 1, m = 1, v = 1, b = 0, x = "", w = r, y = o, C = i, O = x; m;)switch (p = b, b = Dn()) { case 40: if (p != 108 && _l(O, f - 1) == 58) { R5(O += fc(lh(b), "&", "&\f"), "&\f", rC(c ? l[c - 1] : 0)) != -1 && (v = -1); break } case 34: case 39: case 91: O += lh(b); break; case 9: case 10: case 13: case 32: O += N5(p); break; case 92: O += z5(hc() - 1, 7); continue; case 47: switch (er()) { case 42: case 47: Ra(j5(W5(Dn(), hc()), e, n, a), a), (Rl(p || 1) == 5 || Rl(er() || 1) == 5) && Un(O) && Ko(O, -1, void 0) !== " " && (O += " "); break; default: O += "/" }break; case 123 * g: l[c++] = Un(O) * v; case 125 * g: case 59: case 0: switch (b) { case 0: case 125: m = 0; case 59 + u: v == -1 && (O = fc(O, /\f/g, "")), d > 0 && (Un(O) - f || g === 0 && p === 47) && Ra(d > 32 ? ay(O + ";", i, n, f - 1, a) : ay(fc(O, " ", "") + ";", i, n, f - 2, a), a); break; case 59: O += ";"; default: if (Ra(C = ly(O, e, n, c, u, r, l, x, w = [], y = [], f, o), o), b === 123) if (u === 0) dc(O, e, C, C, w, o, f, l, y); else switch (h === 99 && _l(O, 3) === 110 ? 100 : h) { case 100: case 108: case 109: case 115: dc(t, C, C, i && Ra(ly(t, C, C, 0, 0, r, l, x, r, w = [], f, y), y), r, y, f, l, i ? w : y); break; default: dc(O, C, C, C, [""], y, 0, l, y) } }c = u = d = 0, g = v = 1, x = O = "", f = s; break; case 58: f = 1 + Un(O), d = p; default: if (g < 1) { if (b == 123) --g; else if (b == 125 && g++ == 0 && B5() == 125) continue } switch (O += Ag(b), b * g) { case 38: v = u > 0 ? 1 : (O += "\f", -1); break; case 44: l[c++] = (Un(O) - 1) * v, v = 1; break; case 64: er() === 45 && (O += lh(Dn())), h = er(), u = f = Un(x = O += H5(hc())), b++; break; case 45: p === 45 && Un(O) == 2 && (g = 0) } }return o } function ly(t, e, n, i, r, o, s, l, a, c, u, f) { for (var h = r - 1, d = r === 0 ? o : [""], p = I5(d), g = 0, m = 0, v = 0; g < i; ++g)for (var b = 0, x = Ko(t, h + 1, h = rC(m = s[g])), w = t; b < p; ++b)(w = oC(m > 0 ? d[b] + " " + x : fc(x, /&\f/g, d[b]))) && (a[v++] = w); return Mg(t, e, n, r === 0 ? nC : l, a, c, u, f) } function j5(t, e, n, i) { return Mg(t, e, n, tC, Ag(D5()), Ko(t, 2, -2), 0, i) } function ay(t, e, n, i, r) { return Mg(t, e, n, iC, Ko(t, 0, i), Ko(t, i + 1, -1), i, r) } function Gd(t, e) { for (var n = "", i = 0; i < t.length; i++)n += e(t[i], i, t, e) || ""; return n } function q5(t, e, n, i) { switch (t.type) { case _5: if (t.children.length) break; case M5: case iC: return t.return = t.return || t.value; case tC: return ""; case E5: return t.return = t.value + "{" + Gd(t.children, i) + "}"; case nC: if (!Un(t.value = t.props.join(","))) return "" }return Un(n = Gd(t.children, i)) ? t.return = t.value + "{" + n + "}" : "" } const cy = "data-ant-cssinjs-cache-path", V5 = "_FILE_STYLE__"; let Wr, lC = !0; function X5() { var t; if (!Wr && (Wr = {}, si())) { const e = document.createElement("div"); e.className = cy, e.style.position = "fixed", e.style.visibility = "hidden", e.style.top = "-9999px", document.body.appendChild(e); let n = getComputedStyle(e).content || ""; n = n.replace(/^"/, "").replace(/"$/, ""), n.split(";").forEach(r => { const [o, s] = r.split(":"); Wr[o] = s }); const i = document.querySelector(`style[${cy}]`); i && (lC = !1, (t = i.parentNode) === null || t === void 0 || t.removeChild(i)), document.body.removeChild(e) } } function U5(t) { return X5(), !!Wr[t] } function G5(t) { const e = Wr[t]; let n = null; if (e && si()) if (lC) n = V5; else { const i = document.querySelector(`style[${zr}="${Wr[t]}"]`); i ? n = i.innerHTML : delete Wr[t] } return [n, e] } const uy = si(), K5 = "_skip_check_", aC = "_multi_value_"; function fy(t) { return Gd(F5(t), q5).replace(/\{%%%\:[^;];}/g, ";") } function Y5(t) { return typeof t == "object" && t && (K5 in t || aC in t) } function Z5(t, e, n) { if (!e) return t; const i = `.${e}`, r = n === "low" ? `:where(${i})` : i; return t.split(",").map(s => { var l; const a = s.trim().split(/\s+/); let c = a[0] || ""; const u = ((l = c.match(/^\w+/)) === null || l === void 0 ? void 0 : l[0]) || ""; return c = `${u}${r}${c.slice(u.length)}`, [c, ...a.slice(1)].join(" ") }).join(",") } const hy = new Set, Kd = function (t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { root: n, injectHash: i, parentSelectors: r } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { root: !0, parentSelectors: [] }; const { hashId: o, layer: s, path: l, hashPriority: a, transformers: c = [], linters: u = [] } = e; let f = "", h = {}; function d(m) { const v = m.getName(o); if (!h[v]) { const [b] = Kd(m.style, e, { root: !1, parentSelectors: r }); h[v] = `@keyframes ${m.getName(o)}${b}` } } function p(m) { let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; return m.forEach(b => { Array.isArray(b) ? p(b, v) : b && v.push(b) }), v } if (p(Array.isArray(t) ? t : [t]).forEach(m => {
            const v = typeof m == "string" && !n ? {} : m; if (typeof v == "string") f += `${v}
`; else if (v._keyframe) d(v); else { const b = c.reduce((x, w) => { var y; return ((y = w == null ? void 0 : w.visit) === null || y === void 0 ? void 0 : y.call(w, x)) || x }, v); Object.keys(b).forEach(x => { var w; const y = b[x]; if (typeof y == "object" && y && (x !== "animationName" || !y._keyframe) && !Y5(y)) { let O = !1, P = x.trim(), M = !1; (n || i) && o ? P.startsWith("@") ? O = !0 : P = Z5(x, o, a) : n && !o && (P === "&" || P === "") && (P = "", M = !0); const [A, B] = Kd(y, e, { root: M, injectHash: O, parentSelectors: [...r, P] }); h = S(S({}, h), B), f += `${P}${A}` } else { let O = function (M, A) { const B = M.replace(/[A-Z]/g, X => `-${X.toLowerCase()}`); let R = A; !A5[M] && typeof R == "number" && R !== 0 && (R = `${R}px`), M === "animationName" && (A != null && A._keyframe) && (d(A), R = A.getName(o)), f += `${B}:${R};` }; var C = O; const P = (w = y == null ? void 0 : y.value) !== null && w !== void 0 ? w : y; typeof y == "object" && (y != null && y[aC]) && Array.isArray(P) ? P.forEach(M => { O(x, M) }) : O(x, P) } }) }
        }), !n) f = `{${f}}`; else if (s && b5()) { const m = s.split(","); f = `@layer ${m[m.length - 1].trim()} {${f}}`, m.length > 1 && (f = `@layer ${s}{%%%:%}${f}`) } return [f, h]
    }; function J5(t, e) { return Pg(`${t.join("%")}${e}`) } function dy(t, e) { const n = Ku(), i = E(() => t.value.token._tokenKey), r = E(() => [i.value, ...t.value.path]); let o = uy; return Xw("style", r, () => { const { path: s, hashId: l, layer: a, nonce: c, clientOnly: u, order: f = 0 } = t.value, h = r.value.join("|"); if (U5(h)) { const [O, P] = G5(h); if (O) return [O, i.value, P, {}, u, f] } const d = e(), { hashPriority: p, container: g, transformers: m, linters: v, cache: b } = n.value, [x, w] = Kd(d, { hashId: l, hashPriority: p, layer: a, path: s.join("-"), transformers: m, linters: v }), y = fy(x), C = J5(r.value, y); if (o) { const O = { mark: zr, prepend: "queue", attachTo: g, priority: f }, P = typeof c == "function" ? c() : c; P && (O.csp = { nonce: P }); const M = ou(y, C, O); M[wo] = b.instanceId, M.setAttribute(jw, i.value), Object.keys(w).forEach(A => { hy.has(A) || (hy.add(A), ou(fy(w[A]), `_effect-${A}`, { mark: zr, prepend: "queue", attachTo: g })) }) } return [y, i.value, C, w, u, f] }, (s, l) => { let [, , a] = s; (l || n.value.autoClear) && uy && ru(a, { mark: zr }) }), s => s } class eL { constructor(e, n) { this._keyframe = !0, this.name = e, this.style = n } getName() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; return e ? `${e}-${this.name}` : this.name } } const rt = eL, tL = "4.2.5", lu = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"]; function Pt(t, e) { nL(t) && (t = "100%"); var n = iL(t); return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t) } function Ia(t) { return Math.min(1, Math.max(0, t)) } function nL(t) { return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1 } function iL(t) { return typeof t == "string" && t.indexOf("%") !== -1 } function cC(t) { return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t } function Da(t) { return t <= 1 ? "".concat(Number(t) * 100, "%") : t } function Br(t) { return t.length === 1 ? "0" + t : String(t) } function rL(t, e, n) { return { r: Pt(t, 255) * 255, g: Pt(e, 255) * 255, b: Pt(n, 255) * 255 } } function py(t, e, n) { t = Pt(t, 255), e = Pt(e, 255), n = Pt(n, 255); var i = Math.max(t, e, n), r = Math.min(t, e, n), o = 0, s = 0, l = (i + r) / 2; if (i === r) s = 0, o = 0; else { var a = i - r; switch (s = l > .5 ? a / (2 - i - r) : a / (i + r), i) { case t: o = (e - n) / a + (e < n ? 6 : 0); break; case e: o = (n - t) / a + 2; break; case n: o = (t - e) / a + 4; break }o /= 6 } return { h: o, s, l } } function ah(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function oL(t, e, n) { var i, r, o; if (t = Pt(t, 360), e = Pt(e, 100), n = Pt(n, 100), e === 0) r = n, o = n, i = n; else { var s = n < .5 ? n * (1 + e) : n + e - n * e, l = 2 * n - s; i = ah(l, s, t + 1 / 3), r = ah(l, s, t), o = ah(l, s, t - 1 / 3) } return { r: i * 255, g: r * 255, b: o * 255 } } function Yd(t, e, n) { t = Pt(t, 255), e = Pt(e, 255), n = Pt(n, 255); var i = Math.max(t, e, n), r = Math.min(t, e, n), o = 0, s = i, l = i - r, a = i === 0 ? 0 : l / i; if (i === r) o = 0; else { switch (i) { case t: o = (e - n) / l + (e < n ? 6 : 0); break; case e: o = (n - t) / l + 2; break; case n: o = (t - e) / l + 4; break }o /= 6 } return { h: o, s: a, v: s } } function sL(t, e, n) { t = Pt(t, 360) * 6, e = Pt(e, 100), n = Pt(n, 100); var i = Math.floor(t), r = t - i, o = n * (1 - e), s = n * (1 - r * e), l = n * (1 - (1 - r) * e), a = i % 6, c = [n, s, o, o, l, n][a], u = [l, n, n, s, o, o][a], f = [o, o, l, n, n, s][a]; return { r: c * 255, g: u * 255, b: f * 255 } } function Zd(t, e, n, i) { var r = [Br(Math.round(t).toString(16)), Br(Math.round(e).toString(16)), Br(Math.round(n).toString(16))]; return i && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("") } function lL(t, e, n, i, r) { var o = [Br(Math.round(t).toString(16)), Br(Math.round(e).toString(16)), Br(Math.round(n).toString(16)), Br(aL(i))]; return r && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("") } function aL(t) { return Math.round(parseFloat(t) * 255).toString(16) } function gy(t) { return sn(t) / 255 } function sn(t) { return parseInt(t, 16) } function cL(t) { return { r: t >> 16, g: (t & 65280) >> 8, b: t & 255 } } var Jd = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", goldenrod: "#daa520", gold: "#ffd700", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavenderblush: "#fff0f5", lavender: "#e6e6fa", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" }; function vo(t) { var e = { r: 0, g: 0, b: 0 }, n = 1, i = null, r = null, o = null, s = !1, l = !1; return typeof t == "string" && (t = hL(t)), typeof t == "object" && (gi(t.r) && gi(t.g) && gi(t.b) ? (e = rL(t.r, t.g, t.b), s = !0, l = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : gi(t.h) && gi(t.s) && gi(t.v) ? (i = Da(t.s), r = Da(t.v), e = sL(t.h, i, r), s = !0, l = "hsv") : gi(t.h) && gi(t.s) && gi(t.l) && (i = Da(t.s), o = Da(t.l), e = oL(t.h, i, o), s = !0, l = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = cC(n), { ok: s, format: t.format || l, r: Math.min(255, Math.max(e.r, 0)), g: Math.min(255, Math.max(e.g, 0)), b: Math.min(255, Math.max(e.b, 0)), a: n } } var uL = "[-\\+]?\\d+%?", fL = "[-\\+]?\\d*\\.\\d+%?", tr = "(?:".concat(fL, ")|(?:").concat(uL, ")"), ch = "[\\s|\\(]+(".concat(tr, ")[,|\\s]+(").concat(tr, ")[,|\\s]+(").concat(tr, ")\\s*\\)?"), uh = "[\\s|\\(]+(".concat(tr, ")[,|\\s]+(").concat(tr, ")[,|\\s]+(").concat(tr, ")[,|\\s]+(").concat(tr, ")\\s*\\)?"), Pn = { CSS_UNIT: new RegExp(tr), rgb: new RegExp("rgb" + ch), rgba: new RegExp("rgba" + uh), hsl: new RegExp("hsl" + ch), hsla: new RegExp("hsla" + uh), hsv: new RegExp("hsv" + ch), hsva: new RegExp("hsva" + uh), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ }; function hL(t) { if (t = t.trim().toLowerCase(), t.length === 0) return !1; var e = !1; if (Jd[t]) t = Jd[t], e = !0; else if (t === "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" }; var n = Pn.rgb.exec(t); return n ? { r: n[1], g: n[2], b: n[3] } : (n = Pn.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = Pn.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = Pn.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = Pn.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = Pn.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = Pn.hex8.exec(t), n ? { r: sn(n[1]), g: sn(n[2]), b: sn(n[3]), a: gy(n[4]), format: e ? "name" : "hex8" } : (n = Pn.hex6.exec(t), n ? { r: sn(n[1]), g: sn(n[2]), b: sn(n[3]), format: e ? "name" : "hex" } : (n = Pn.hex4.exec(t), n ? { r: sn(n[1] + n[1]), g: sn(n[2] + n[2]), b: sn(n[3] + n[3]), a: gy(n[4] + n[4]), format: e ? "name" : "hex8" } : (n = Pn.hex3.exec(t), n ? { r: sn(n[1] + n[1]), g: sn(n[2] + n[2]), b: sn(n[3] + n[3]), format: e ? "name" : "hex" } : !1))))))))) } function gi(t) { return !!Pn.CSS_UNIT.exec(String(t)) } var _t = function () { function t(e, n) { e === void 0 && (e = ""), n === void 0 && (n = {}); var i; if (e instanceof t) return e; typeof e == "number" && (e = cL(e)), this.originalInput = e; var r = vo(e); this.originalInput = e, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (i = n.format) !== null && i !== void 0 ? i : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok } return t.prototype.isDark = function () { return this.getBrightness() < 128 }, t.prototype.isLight = function () { return !this.isDark() }, t.prototype.getBrightness = function () { var e = this.toRgb(); return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3 }, t.prototype.getLuminance = function () { var e = this.toRgb(), n, i, r, o = e.r / 255, s = e.g / 255, l = e.b / 255; return o <= .03928 ? n = o / 12.92 : n = Math.pow((o + .055) / 1.055, 2.4), s <= .03928 ? i = s / 12.92 : i = Math.pow((s + .055) / 1.055, 2.4), l <= .03928 ? r = l / 12.92 : r = Math.pow((l + .055) / 1.055, 2.4), .2126 * n + .7152 * i + .0722 * r }, t.prototype.getAlpha = function () { return this.a }, t.prototype.setAlpha = function (e) { return this.a = cC(e), this.roundA = Math.round(100 * this.a) / 100, this }, t.prototype.isMonochrome = function () { var e = this.toHsl().s; return e === 0 }, t.prototype.toHsv = function () { var e = Yd(this.r, this.g, this.b); return { h: e.h * 360, s: e.s, v: e.v, a: this.a } }, t.prototype.toHsvString = function () { var e = Yd(this.r, this.g, this.b), n = Math.round(e.h * 360), i = Math.round(e.s * 100), r = Math.round(e.v * 100); return this.a === 1 ? "hsv(".concat(n, ", ").concat(i, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")") }, t.prototype.toHsl = function () { var e = py(this.r, this.g, this.b); return { h: e.h * 360, s: e.s, l: e.l, a: this.a } }, t.prototype.toHslString = function () { var e = py(this.r, this.g, this.b), n = Math.round(e.h * 360), i = Math.round(e.s * 100), r = Math.round(e.l * 100); return this.a === 1 ? "hsl(".concat(n, ", ").concat(i, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")") }, t.prototype.toHex = function (e) { return e === void 0 && (e = !1), Zd(this.r, this.g, this.b, e) }, t.prototype.toHexString = function (e) { return e === void 0 && (e = !1), "#" + this.toHex(e) }, t.prototype.toHex8 = function (e) { return e === void 0 && (e = !1), lL(this.r, this.g, this.b, this.a, e) }, t.prototype.toHex8String = function (e) { return e === void 0 && (e = !1), "#" + this.toHex8(e) }, t.prototype.toHexShortString = function (e) { return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e) }, t.prototype.toRgb = function () { return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a } }, t.prototype.toRgbString = function () { var e = Math.round(this.r), n = Math.round(this.g), i = Math.round(this.b); return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(i, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(i, ", ").concat(this.roundA, ")") }, t.prototype.toPercentageRgb = function () { var e = function (n) { return "".concat(Math.round(Pt(n, 255) * 100), "%") }; return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a } }, t.prototype.toPercentageRgbString = function () { var e = function (n) { return Math.round(Pt(n, 255) * 100) }; return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")") }, t.prototype.toName = function () { if (this.a === 0) return "transparent"; if (this.a < 1) return !1; for (var e = "#" + Zd(this.r, this.g, this.b, !1), n = 0, i = Object.entries(Jd); n < i.length; n++) { var r = i[n], o = r[0], s = r[1]; if (e === s) return o } return !1 }, t.prototype.toString = function (e) { var n = !!e; e = e ?? this.format; var i = !1, r = this.a < 1 && this.a >= 0, o = !n && r && (e.startsWith("hex") || e === "name"); return o ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (i = this.toRgbString()), e === "prgb" && (i = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (i = this.toHexString()), e === "hex3" && (i = this.toHexString(!0)), e === "hex4" && (i = this.toHex8String(!0)), e === "hex8" && (i = this.toHex8String()), e === "name" && (i = this.toName()), e === "hsl" && (i = this.toHslString()), e === "hsv" && (i = this.toHsvString()), i || this.toHexString()) }, t.prototype.toNumber = function () { return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b) }, t.prototype.clone = function () { return new t(this.toString()) }, t.prototype.lighten = function (e) { e === void 0 && (e = 10); var n = this.toHsl(); return n.l += e / 100, n.l = Ia(n.l), new t(n) }, t.prototype.brighten = function (e) { e === void 0 && (e = 10); var n = this.toRgb(); return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new t(n) }, t.prototype.darken = function (e) { e === void 0 && (e = 10); var n = this.toHsl(); return n.l -= e / 100, n.l = Ia(n.l), new t(n) }, t.prototype.tint = function (e) { return e === void 0 && (e = 10), this.mix("white", e) }, t.prototype.shade = function (e) { return e === void 0 && (e = 10), this.mix("black", e) }, t.prototype.desaturate = function (e) { e === void 0 && (e = 10); var n = this.toHsl(); return n.s -= e / 100, n.s = Ia(n.s), new t(n) }, t.prototype.saturate = function (e) { e === void 0 && (e = 10); var n = this.toHsl(); return n.s += e / 100, n.s = Ia(n.s), new t(n) }, t.prototype.greyscale = function () { return this.desaturate(100) }, t.prototype.spin = function (e) { var n = this.toHsl(), i = (n.h + e) % 360; return n.h = i < 0 ? 360 + i : i, new t(n) }, t.prototype.mix = function (e, n) { n === void 0 && (n = 50); var i = this.toRgb(), r = new t(e).toRgb(), o = n / 100, s = { r: (r.r - i.r) * o + i.r, g: (r.g - i.g) * o + i.g, b: (r.b - i.b) * o + i.b, a: (r.a - i.a) * o + i.a }; return new t(s) }, t.prototype.analogous = function (e, n) { e === void 0 && (e = 6), n === void 0 && (n = 30); var i = this.toHsl(), r = 360 / n, o = [this]; for (i.h = (i.h - (r * e >> 1) + 720) % 360; --e;)i.h = (i.h + r) % 360, o.push(new t(i)); return o }, t.prototype.complement = function () { var e = this.toHsl(); return e.h = (e.h + 180) % 360, new t(e) }, t.prototype.monochromatic = function (e) { e === void 0 && (e = 6); for (var n = this.toHsv(), i = n.h, r = n.s, o = n.v, s = [], l = 1 / e; e--;)s.push(new t({ h: i, s: r, v: o })), o = (o + l) % 1; return s }, t.prototype.splitcomplement = function () { var e = this.toHsl(), n = e.h; return [this, new t({ h: (n + 72) % 360, s: e.s, l: e.l }), new t({ h: (n + 216) % 360, s: e.s, l: e.l })] }, t.prototype.onBackground = function (e) { var n = this.toRgb(), i = new t(e).toRgb(), r = n.a + i.a * (1 - n.a); return new t({ r: (n.r * n.a + i.r * i.a * (1 - n.a)) / r, g: (n.g * n.a + i.g * i.a * (1 - n.a)) / r, b: (n.b * n.a + i.b * i.a * (1 - n.a)) / r, a: r }) }, t.prototype.triad = function () { return this.polyad(3) }, t.prototype.tetrad = function () { return this.polyad(4) }, t.prototype.polyad = function (e) { for (var n = this.toHsl(), i = n.h, r = [this], o = 360 / e, s = 1; s < e; s++)r.push(new t({ h: (i + s * o) % 360, s: n.s, l: n.l })); return r }, t.prototype.equals = function (e) { return this.toRgbString() === new t(e).toRgbString() }, t }(), Ba = 2, my = .16, dL = .05, pL = .05, gL = .15, uC = 5, fC = 4, mL = [{ index: 7, opacity: .15 }, { index: 6, opacity: .25 }, { index: 5, opacity: .3 }, { index: 5, opacity: .45 }, { index: 5, opacity: .65 }, { index: 5, opacity: .85 }, { index: 4, opacity: .9 }, { index: 3, opacity: .95 }, { index: 2, opacity: .97 }, { index: 1, opacity: .98 }]; function vy(t) { var e = t.r, n = t.g, i = t.b, r = Yd(e, n, i); return { h: r.h * 360, s: r.s, v: r.v } } function La(t) { var e = t.r, n = t.g, i = t.b; return "#".concat(Zd(e, n, i, !1)) } function vL(t, e, n) { var i = n / 100, r = { r: (e.r - t.r) * i + t.r, g: (e.g - t.g) * i + t.g, b: (e.b - t.b) * i + t.b }; return r } function yy(t, e, n) { var i; return Math.round(t.h) >= 60 && Math.round(t.h) <= 240 ? i = n ? Math.round(t.h) - Ba * e : Math.round(t.h) + Ba * e : i = n ? Math.round(t.h) + Ba * e : Math.round(t.h) - Ba * e, i < 0 ? i += 360 : i >= 360 && (i -= 360), i } function by(t, e, n) { if (t.h === 0 && t.s === 0) return t.s; var i; return n ? i = t.s - my * e : e === fC ? i = t.s + my : i = t.s + dL * e, i > 1 && (i = 1), n && e === uC && i > .1 && (i = .1), i < .06 && (i = .06), Number(i.toFixed(2)) } function Oy(t, e, n) { var i; return n ? i = t.v + pL * e : i = t.v - gL * e, i > 1 && (i = 1), Number(i.toFixed(2)) } function Il(t) { for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], i = vo(t), r = uC; r > 0; r -= 1) { var o = vy(i), s = La(vo({ h: yy(o, r, !0), s: by(o, r, !0), v: Oy(o, r, !0) })); n.push(s) } n.push(La(i)); for (var l = 1; l <= fC; l += 1) { var a = vy(i), c = La(vo({ h: yy(a, l), s: by(a, l), v: Oy(a, l) })); n.push(c) } return e.theme === "dark" ? mL.map(function (u) { var f = u.index, h = u.opacity, d = La(vL(vo(e.backgroundColor || "#141414"), vo(n[f]), h * 100)); return d }) : n } var fh = { red: "#F5222D", volcano: "#FA541C", orange: "#FA8C16", gold: "#FAAD14", yellow: "#FADB14", lime: "#A0D911", green: "#52C41A", cyan: "#13C2C2", blue: "#1890FF", geekblue: "#2F54EB", purple: "#722ED1", magenta: "#EB2F96", grey: "#666666" }, pc = {}, hh = {}; Object.keys(fh).forEach(function (t) { pc[t] = Il(fh[t]), pc[t].primary = pc[t][5], hh[t] = Il(fh[t], { theme: "dark", backgroundColor: "#141414" }), hh[t].primary = hh[t][5] }); var yL = pc.blue; const bL = t => { const { controlHeight: e } = t; return { controlHeightSM: e * .75, controlHeightXS: e * .5, controlHeightLG: e * 1.25 } }, OL = bL; function SL(t) { const { sizeUnit: e, sizeStep: n } = t; return { sizeXXL: e * (n + 8), sizeXL: e * (n + 4), sizeLG: e * (n + 2), sizeMD: e * (n + 1), sizeMS: e * n, size: e * n, sizeSM: e * (n - 1), sizeXS: e * (n - 2), sizeXXS: e * (n - 3) } } const hC = { blue: "#1677ff", purple: "#722ED1", cyan: "#13C2C2", green: "#52C41A", magenta: "#EB2F96", pink: "#eb2f96", red: "#F5222D", orange: "#FA8C16", yellow: "#FADB14", volcano: "#FA541C", geekblue: "#2F54EB", gold: "#FAAD14", lime: "#A0D911" }, xL = S(S({}, hC), {
        colorPrimary: "#1677ff", colorSuccess: "#52c41a", colorWarning: "#faad14", colorError: "#ff4d4f", colorInfo: "#1677ff", colorTextBase: "", colorBgBase: "", fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`, fontSize: 14, lineWidth: 1, lineType: "solid", motionUnit: .1, motionBase: 0, motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)", motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)", motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)", motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)", motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)", motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)", motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)", borderRadius: 6, sizeUnit: 4, sizeStep: 4, sizePopupArrow: 16, controlHeight: 32, zIndexBase: 0, zIndexPopupBase: 1e3, opacityImage: 1, wireframe: !1
    }), Eg = xL; function wL(t, e) { let { generateColorPalettes: n, generateNeutralColorPalettes: i } = e; const { colorSuccess: r, colorWarning: o, colorError: s, colorInfo: l, colorPrimary: a, colorBgBase: c, colorTextBase: u } = t, f = n(a), h = n(r), d = n(o), p = n(s), g = n(l), m = i(c, u); return S(S({}, m), { colorPrimaryBg: f[1], colorPrimaryBgHover: f[2], colorPrimaryBorder: f[3], colorPrimaryBorderHover: f[4], colorPrimaryHover: f[5], colorPrimary: f[6], colorPrimaryActive: f[7], colorPrimaryTextHover: f[8], colorPrimaryText: f[9], colorPrimaryTextActive: f[10], colorSuccessBg: h[1], colorSuccessBgHover: h[2], colorSuccessBorder: h[3], colorSuccessBorderHover: h[4], colorSuccessHover: h[4], colorSuccess: h[6], colorSuccessActive: h[7], colorSuccessTextHover: h[8], colorSuccessText: h[9], colorSuccessTextActive: h[10], colorErrorBg: p[1], colorErrorBgHover: p[2], colorErrorBorder: p[3], colorErrorBorderHover: p[4], colorErrorHover: p[5], colorError: p[6], colorErrorActive: p[7], colorErrorTextHover: p[8], colorErrorText: p[9], colorErrorTextActive: p[10], colorWarningBg: d[1], colorWarningBgHover: d[2], colorWarningBorder: d[3], colorWarningBorderHover: d[4], colorWarningHover: d[4], colorWarning: d[6], colorWarningActive: d[7], colorWarningTextHover: d[8], colorWarningText: d[9], colorWarningTextActive: d[10], colorInfoBg: g[1], colorInfoBgHover: g[2], colorInfoBorder: g[3], colorInfoBorderHover: g[4], colorInfoHover: g[4], colorInfo: g[6], colorInfoActive: g[7], colorInfoTextHover: g[8], colorInfoText: g[9], colorInfoTextActive: g[10], colorBgMask: new _t("#000").setAlpha(.45).toRgbString(), colorWhite: "#fff" }) } const CL = t => { let e = t, n = t, i = t, r = t; return t < 6 && t >= 5 ? e = t + 1 : t < 16 && t >= 6 ? e = t + 2 : t >= 16 && (e = 16), t < 7 && t >= 5 ? n = 4 : t < 8 && t >= 7 ? n = 5 : t < 14 && t >= 8 ? n = 6 : t < 16 && t >= 14 ? n = 7 : t >= 16 && (n = 8), t < 6 && t >= 2 ? i = 1 : t >= 6 && (i = 2), t > 4 && t < 8 ? r = 4 : t >= 8 && (r = 6), { borderRadius: t > 16 ? 16 : t, borderRadiusXS: i, borderRadiusSM: n, borderRadiusLG: e, borderRadiusOuter: r } }, TL = CL; function $L(t) { const { motionUnit: e, motionBase: n, borderRadius: i, lineWidth: r } = t; return S({ motionDurationFast: `${(n + e).toFixed(1)}s`, motionDurationMid: `${(n + e * 2).toFixed(1)}s`, motionDurationSlow: `${(n + e * 3).toFixed(1)}s`, lineWidthBold: r + 1 }, TL(i)) } const mi = (t, e) => new _t(t).setAlpha(e).toRgbString(), ks = (t, e) => new _t(t).darken(e).toHexString(), kL = t => { const e = Il(t); return { 1: e[0], 2: e[1], 3: e[2], 4: e[3], 5: e[4], 6: e[5], 7: e[6], 8: e[4], 9: e[5], 10: e[6] } }, PL = (t, e) => { const n = t || "#fff", i = e || "#000"; return { colorBgBase: n, colorTextBase: i, colorText: mi(i, .88), colorTextSecondary: mi(i, .65), colorTextTertiary: mi(i, .45), colorTextQuaternary: mi(i, .25), colorFill: mi(i, .15), colorFillSecondary: mi(i, .06), colorFillTertiary: mi(i, .04), colorFillQuaternary: mi(i, .02), colorBgLayout: ks(n, 4), colorBgContainer: ks(n, 0), colorBgElevated: ks(n, 0), colorBgSpotlight: mi(i, .85), colorBorder: ks(n, 15), colorBorderSecondary: ks(n, 6) } }; function AL(t) { const e = new Array(10).fill(null).map((n, i) => { const r = i - 1, o = t * Math.pow(2.71828, r / 5), s = i > 1 ? Math.floor(o) : Math.ceil(o); return Math.floor(s / 2) * 2 }); return e[1] = t, e.map(n => { const i = n + 8; return { size: n, lineHeight: i / n } }) } const ML = t => { const e = AL(t), n = e.map(r => r.size), i = e.map(r => r.lineHeight); return { fontSizeSM: n[0], fontSize: n[1], fontSizeLG: n[2], fontSizeXL: n[3], fontSizeHeading1: n[6], fontSizeHeading2: n[5], fontSizeHeading3: n[4], fontSizeHeading4: n[3], fontSizeHeading5: n[2], lineHeight: i[1], lineHeightLG: i[2], lineHeightSM: i[0], lineHeightHeading1: i[6], lineHeightHeading2: i[5], lineHeightHeading3: i[4], lineHeightHeading4: i[3], lineHeightHeading5: i[2] } }, EL = ML; function _L(t) { const e = Object.keys(hC).map(n => { const i = Il(t[n]); return new Array(10).fill(1).reduce((r, o, s) => (r[`${n}-${s + 1}`] = i[s], r), {}) }).reduce((n, i) => (n = S(S({}, n), i), n), {}); return S(S(S(S(S(S(S({}, t), e), wL(t, { generateColorPalettes: kL, generateNeutralColorPalettes: PL })), EL(t.fontSize)), SL(t)), OL(t)), $L(t)) } function dh(t) { return t >= 0 && t <= 255 } function Qa(t, e) { const { r: n, g: i, b: r, a: o } = new _t(t).toRgb(); if (o < 1) return t; const { r: s, g: l, b: a } = new _t(e).toRgb(); for (let c = .01; c <= 1; c += .01) { const u = Math.round((n - s * (1 - c)) / c), f = Math.round((i - l * (1 - c)) / c), h = Math.round((r - a * (1 - c)) / c); if (dh(u) && dh(f) && dh(h)) return new _t({ r: u, g: f, b: h, a: Math.round(c * 100) / 100 }).toRgbString() } return new _t({ r: n, g: i, b: r, a: 1 }).toRgbString() } var RL = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; function IL(t) {
        const { override: e } = t, n = RL(t, ["override"]), i = S({}, e); Object.keys(Eg).forEach(d => { delete i[d] }); const r = S(S({}, n), i), o = 480, s = 576, l = 768, a = 992, c = 1200, u = 1600, f = 2e3; return S(S(S({}, r), {
            colorLink: r.colorInfoText, colorLinkHover: r.colorInfoHover, colorLinkActive: r.colorInfoActive, colorFillContent: r.colorFillSecondary, colorFillContentHover: r.colorFill, colorFillAlter: r.colorFillQuaternary, colorBgContainerDisabled: r.colorFillTertiary, colorBorderBg: r.colorBgContainer, colorSplit: Qa(r.colorBorderSecondary, r.colorBgContainer), colorTextPlaceholder: r.colorTextQuaternary, colorTextDisabled: r.colorTextQuaternary, colorTextHeading: r.colorText, colorTextLabel: r.colorTextSecondary, colorTextDescription: r.colorTextTertiary, colorTextLightSolid: r.colorWhite, colorHighlight: r.colorError, colorBgTextHover: r.colorFillSecondary, colorBgTextActive: r.colorFill, colorIcon: r.colorTextTertiary, colorIconHover: r.colorText, colorErrorOutline: Qa(r.colorErrorBg, r.colorBgContainer), colorWarningOutline: Qa(r.colorWarningBg, r.colorBgContainer), fontSizeIcon: r.fontSizeSM, lineWidth: r.lineWidth, controlOutlineWidth: r.lineWidth * 2, controlInteractiveSize: r.controlHeight / 2, controlItemBgHover: r.colorFillTertiary, controlItemBgActive: r.colorPrimaryBg, controlItemBgActiveHover: r.colorPrimaryBgHover, controlItemBgActiveDisabled: r.colorFill, controlTmpOutline: r.colorFillQuaternary, controlOutline: Qa(r.colorPrimaryBg, r.colorBgContainer), lineType: r.lineType, borderRadius: r.borderRadius, borderRadiusXS: r.borderRadiusXS, borderRadiusSM: r.borderRadiusSM, borderRadiusLG: r.borderRadiusLG, fontWeightStrong: 600, opacityLoading: .65, linkDecoration: "none", linkHoverDecoration: "none", linkFocusDecoration: "none", controlPaddingHorizontal: 12, controlPaddingHorizontalSM: 8, paddingXXS: r.sizeXXS, paddingXS: r.sizeXS, paddingSM: r.sizeSM, padding: r.size, paddingMD: r.sizeMD, paddingLG: r.sizeLG, paddingXL: r.sizeXL, paddingContentHorizontalLG: r.sizeLG, paddingContentVerticalLG: r.sizeMS, paddingContentHorizontal: r.sizeMS, paddingContentVertical: r.sizeSM, paddingContentHorizontalSM: r.size, paddingContentVerticalSM: r.sizeXS, marginXXS: r.sizeXXS, marginXS: r.sizeXS, marginSM: r.sizeSM, margin: r.size, marginMD: r.sizeMD, marginLG: r.sizeLG, marginXL: r.sizeXL, marginXXL: r.sizeXXL, boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `, boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `, boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `, screenXS: o, screenXSMin: o, screenXSMax: s - 1, screenSM: s, screenSMMin: s, screenSMMax: l - 1, screenMD: l, screenMDMin: l, screenMDMax: a - 1, screenLG: a, screenLGMin: a, screenLGMax: c - 1, screenXL: c, screenXLMin: c, screenXLMax: u - 1, screenXXL: u, screenXXLMin: u, screenXXLMax: f - 1, screenXXXL: f, screenXXXLMin: f, boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)", boxShadowCard: `
      0 1px 2px -2px ${new _t("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new _t("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new _t("rgba(0, 0, 0, 0.09)").toRgbString()}
    `, boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `, boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `, boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `, boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `, boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)", boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)", boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)", boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
        }), i)
    } const DL = (t, e, n, i, r) => { const o = t / 2, s = 0, l = o, a = n * 1 / Math.sqrt(2), c = o - n * (1 - 1 / Math.sqrt(2)), u = o - e * (1 / Math.sqrt(2)), f = n * (Math.sqrt(2) - 1) + e * (1 / Math.sqrt(2)), h = 2 * o - u, d = f, p = 2 * o - a, g = c, m = 2 * o - s, v = l, b = o * Math.sqrt(2) + n * (Math.sqrt(2) - 2), x = n * (Math.sqrt(2) - 1); return { pointerEvents: "none", width: t, height: t, overflow: "hidden", "&::after": { content: '""', position: "absolute", width: b, height: b, bottom: 0, insetInline: 0, margin: "auto", borderRadius: { _skip_check_: !0, value: `0 0 ${e}px 0` }, transform: "translateY(50%) rotate(-135deg)", boxShadow: r, zIndex: 0, background: "transparent" }, "&::before": { position: "absolute", bottom: 0, insetInlineStart: 0, width: t, height: t / 2, background: i, clipPath: { _multi_value_: !0, value: [`polygon(${x}px 100%, 50% ${x}px, ${2 * o - x}px 100%, ${x}px 100%)`, `path('M ${s} ${l} A ${n} ${n} 0 0 0 ${a} ${c} L ${u} ${f} A ${e} ${e} 0 0 1 ${h} ${d} L ${p} ${g} A ${n} ${n} 0 0 0 ${m} ${v} Z')`] }, content: '""' } } }; function BL(t, e) { return lu.reduce((n, i) => { const r = t[`${i}-1`], o = t[`${i}-3`], s = t[`${i}-6`], l = t[`${i}-7`]; return S(S({}, n), e(i, { lightColor: r, lightBorderColor: o, darkColor: s, textColor: l })) }, {}) } const ef = { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis" }, Yl = t => ({ boxSizing: "border-box", margin: 0, padding: 0, color: t.colorText, fontSize: t.fontSize, lineHeight: t.lineHeight, listStyle: "none", fontFamily: t.fontFamily }), LL = () => ({ display: "inline-flex", alignItems: "center", color: "inherit", fontStyle: "normal", lineHeight: 0, textAlign: "center", textTransform: "none", verticalAlign: "-0.125em", textRendering: "optimizeLegibility", "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale", "> *": { lineHeight: 1 }, svg: { display: "inline-block" } }), Zo = () => ({ "&::before": { display: "table", content: '""' }, "&::after": { display: "table", clear: "both", content: '""' } }), QL = t => ({
        a: {
            color: t.colorLink, textDecoration: t.linkDecoration, backgroundColor: "transparent", outline: "none", cursor: "pointer", transition: `color ${t.motionDurationSlow}`, "-webkit-text-decoration-skip": "objects", "&:hover": { color: t.colorLinkHover }, "&:active": { color: t.colorLinkActive }, [`&:active,
  &:hover`]: { textDecoration: t.linkHoverDecoration, outline: 0 }, "&:focus": { textDecoration: t.linkFocusDecoration, outline: 0 }, "&[disabled]": { color: t.colorTextDisabled, cursor: "not-allowed" }
        }
    }), NL = (t, e) => { const { fontFamily: n, fontSize: i } = t, r = `[class^="${e}"], [class*=" ${e}"]`; return { [r]: { fontFamily: n, fontSize: i, boxSizing: "border-box", "&::before, &::after": { boxSizing: "border-box" }, [r]: { boxSizing: "border-box", "&::before, &::after": { boxSizing: "border-box" } } } } }, dC = t => ({ outline: `${t.lineWidthBold}px solid ${t.colorPrimaryBorder}`, outlineOffset: 1, transition: "outline-offset 0s, outline 0s" }), _g = t => ({ "&:focus-visible": S({}, dC(t)) }); function zn(t, e, n) { return i => { const r = E(() => i == null ? void 0 : i.value), [o, s, l] = Zl(), { getPrefixCls: a, iconPrefixCls: c } = XB(), u = E(() => a()), f = E(() => ({ theme: o.value, token: s.value, hashId: l.value, path: ["Shared", u.value] })); dy(f, () => [{ "&": QL(s.value) }]); const h = E(() => ({ theme: o.value, token: s.value, hashId: l.value, path: [t, r.value, c.value] })); return [dy(h, () => { const { token: d, flush: p } = WL(s.value), g = typeof n == "function" ? n(d) : n, m = S(S({}, g), s.value[t]), v = `.${r.value}`, b = dn(d, { componentCls: v, prefixCls: r.value, iconCls: `.${c.value}`, antCls: `.${u.value}` }, m), x = e(b, { hashId: l.value, prefixCls: r.value, rootPrefixCls: u.value, iconPrefixCls: c.value, overrideComponentToken: s.value[t] }); return p(t, m), [NL(s.value, r.value), x] }), l] } } const pC = typeof CSSINJS_STATISTIC < "u"; let ep = !0; function dn() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; if (!pC) return S({}, ...e); ep = !1; const i = {}; return e.forEach(r => { Object.keys(r).forEach(s => { Object.defineProperty(i, s, { configurable: !0, enumerable: !0, get: () => r[s] }) }) }), ep = !0, i } function zL() { } function WL(t) { let e, n = t, i = zL; return pC && (e = new Set, n = new Proxy(t, { get(r, o) { return ep && e.add(o), r[o] } }), i = (r, o) => { Array.from(e) }), { token: n, keys: e, flush: i } } const HL = m5(_L), FL = { token: Eg, hashed: !0 }, jL = Symbol("DesignTokenContext"), qL = oe(); function Zl() { const t = Ke(jL, E(() => qL.value || FL)), e = E(() => `${tL}-${t.value.hashed || ""}`), n = E(() => t.value.theme || HL), i = P5(n, E(() => [Eg, t.value.token]), E(() => ({ salt: e.value, override: S({ override: t.value.token }, t.value.components), formatToken: IL }))); return [n, E(() => i.value[0]), E(() => t.value.hashed ? i.value[1] : "")] } const gC = ue({ compatConfig: { MODE: 3 }, setup() { const [, t] = Zl(), e = E(() => new _t(t.value.colorBgBase).toHsl().l < .5 ? { opacity: .65 } : {}); return () => $("svg", { style: e.value, width: "184", height: "152", viewBox: "0 0 184 152", xmlns: "http://www.w3.org/2000/svg" }, [$("g", { fill: "none", "fill-rule": "evenodd" }, [$("g", { transform: "translate(24 31.67)" }, [$("ellipse", { "fill-opacity": ".8", fill: "#F5F5F7", cx: "67.797", cy: "106.89", rx: "67.797", ry: "12.668" }, null), $("path", { d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z", fill: "#AEB8C2" }, null), $("path", { d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z", fill: "url(#linearGradient-1)", transform: "translate(13.56)" }, null), $("path", { d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z", fill: "#F5F5F7" }, null), $("path", { d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z", fill: "#DCE0E6" }, null)]), $("path", { d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z", fill: "#DCE0E6" }, null), $("g", { transform: "translate(149.65 15.383)", fill: "#FFF" }, [$("ellipse", { cx: "20.654", cy: "3.167", rx: "2.849", ry: "2.815" }, null), $("path", { d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z" }, null)])])]) } }); gC.PRESENTED_IMAGE_DEFAULT = !0; const mC = gC, vC = ue({ compatConfig: { MODE: 3 }, setup() { const [, t] = Zl(), e = E(() => { const { colorFill: n, colorFillTertiary: i, colorFillQuaternary: r, colorBgContainer: o } = t.value; return { borderColor: new _t(n).onBackground(o).toHexString(), shadowColor: new _t(i).onBackground(o).toHexString(), contentColor: new _t(r).onBackground(o).toHexString() } }); return () => $("svg", { width: "64", height: "41", viewBox: "0 0 64 41", xmlns: "http://www.w3.org/2000/svg" }, [$("g", { transform: "translate(0 1)", fill: "none", "fill-rule": "evenodd" }, [$("ellipse", { fill: e.value.shadowColor, cx: "32", cy: "33", rx: "32", ry: "7" }, null), $("g", { "fill-rule": "nonzero", stroke: e.value.borderColor }, [$("path", { d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z" }, null), $("path", { d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z", fill: e.value.contentColor }, null)])])]) } }); vC.PRESENTED_IMAGE_SIMPLE = !0; const VL = vC, XL = t => { const { componentCls: e, margin: n, marginXS: i, marginXL: r, fontSize: o, lineHeight: s } = t; return { [e]: { marginInline: i, fontSize: o, lineHeight: s, textAlign: "center", [`${e}-image`]: { height: t.emptyImgHeight, marginBottom: i, opacity: t.opacityImage, img: { height: "100%" }, svg: { height: "100%", margin: "auto" } }, [`${e}-footer`]: { marginTop: n }, "&-normal": { marginBlock: r, color: t.colorTextDisabled, [`${e}-image`]: { height: t.emptyImgHeightMD } }, "&-small": { marginBlock: i, color: t.colorTextDisabled, [`${e}-image`]: { height: t.emptyImgHeightSM } } } } }, UL = zn("Empty", t => { const { componentCls: e, controlHeightLG: n } = t, i = dn(t, { emptyImgCls: `${e}-img`, emptyImgHeight: n * 2.5, emptyImgHeightMD: n, emptyImgHeightSM: n * .875 }); return [XL(i)] }); var GL = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; const KL = () => ({ prefixCls: String, imageStyle: zt(), image: qd(), description: qd() }), Rg = ue({ name: "AEmpty", compatConfig: { MODE: 3 }, inheritAttrs: !1, props: KL(), setup(t, e) { let { slots: n = {}, attrs: i } = e; const { direction: r, prefixCls: o } = dt("empty", t), [s, l] = UL(o); return () => { var a, c; const u = o.value, f = S(S({}, t), i), { image: h = ((a = n.image) === null || a === void 0 ? void 0 : a.call(n)) || Fr(mC), description: d = ((c = n.description) === null || c === void 0 ? void 0 : c.call(n)) || void 0, imageStyle: p, class: g = "" } = f, m = GL(f, ["image", "description", "imageStyle", "class"]), v = typeof h == "function" ? h() : h, b = typeof v == "object" && "type" in v && v.type.PRESENTED_IMAGE_SIMPLE; return s($(t5, { componentName: "Empty", children: x => { const w = typeof d < "u" ? d : x.description, y = typeof w == "string" ? w : "empty"; let C = null; return typeof v == "string" ? C = $("img", { alt: y, src: v }, null) : C = v, $("div", ee({ class: ke(u, g, l.value, { [`${u}-normal`]: b, [`${u}-rtl`]: r.value === "rtl" }) }, m), [$("div", { class: `${u}-image`, style: p }, [C]), w && $("p", { class: `${u}-description` }, [w]), n.default && $("div", { class: `${u}-footer` }, [us(n.default())])]) } }, null)) } } }); Rg.PRESENTED_IMAGE_DEFAULT = () => Fr(mC); Rg.PRESENTED_IMAGE_SIMPLE = () => Fr(VL); const Ps = Kl(Rg), YL = t => { const { prefixCls: e } = dt("empty", t); return (i => { switch (i) { case "Table": case "List": return $(Ps, { image: Ps.PRESENTED_IMAGE_SIMPLE }, null); case "Select": case "TreeSelect": case "Cascader": case "Transfer": case "Mentions": return $(Ps, { image: Ps.PRESENTED_IMAGE_SIMPLE, class: `${e.value}-small` }, null); default: return $(Ps, null, null) } })(t.componentName) }, ZL = Symbol("SizeContextKey"), JL = () => Ke(ZL, he(void 0)), dt = (t, e) => { const n = JL(), i = Hw(), r = Ke(zw, S(S({}, Ww), { renderEmpty: O => Fr(YL, { componentName: O }) })), o = E(() => r.getPrefixCls(t, e.prefixCls)), s = E(() => { var O, P; return (O = e.direction) !== null && O !== void 0 ? O : (P = r.direction) === null || P === void 0 ? void 0 : P.value }), l = E(() => { var O; return (O = e.iconPrefixCls) !== null && O !== void 0 ? O : r.iconPrefixCls.value }), a = E(() => r.getPrefixCls()), c = E(() => { var O; return (O = r.autoInsertSpaceInButton) === null || O === void 0 ? void 0 : O.value }), u = r.renderEmpty, f = r.space, h = r.pageHeader, d = r.form, p = E(() => { var O, P; return (O = e.getTargetContainer) !== null && O !== void 0 ? O : (P = r.getTargetContainer) === null || P === void 0 ? void 0 : P.value }), g = E(() => { var O, P, M; return (P = (O = e.getContainer) !== null && O !== void 0 ? O : e.getPopupContainer) !== null && P !== void 0 ? P : (M = r.getPopupContainer) === null || M === void 0 ? void 0 : M.value }), m = E(() => { var O, P; return (O = e.dropdownMatchSelectWidth) !== null && O !== void 0 ? O : (P = r.dropdownMatchSelectWidth) === null || P === void 0 ? void 0 : P.value }), v = E(() => { var O; return (e.virtual === void 0 ? ((O = r.virtual) === null || O === void 0 ? void 0 : O.value) !== !1 : e.virtual !== !1) && m.value !== !1 }), b = E(() => e.size || n.value), x = E(() => { var O, P, M; return (O = e.autocomplete) !== null && O !== void 0 ? O : (M = (P = r.input) === null || P === void 0 ? void 0 : P.value) === null || M === void 0 ? void 0 : M.autocomplete }), w = E(() => { var O; return (O = e.disabled) !== null && O !== void 0 ? O : i.value }), y = E(() => { var O; return (O = e.csp) !== null && O !== void 0 ? O : r.csp }), C = E(() => { var O, P; return (O = e.wave) !== null && O !== void 0 ? O : (P = r.wave) === null || P === void 0 ? void 0 : P.value }); return { configProvider: r, prefixCls: o, direction: s, size: b, getTargetContainer: p, getPopupContainer: g, space: f, pageHeader: h, form: d, autoInsertSpaceInButton: c, renderEmpty: u, virtual: v, dropdownMatchSelectWidth: m, rootPrefixCls: a, getPrefixCls: r.getPrefixCls, autocomplete: x, csp: y, iconPrefixCls: l, disabled: w, select: r.select, wave: C } }; function Ig(t, e) { const n = S({}, t); for (let i = 0; i < e.length; i += 1) { const r = e[i]; delete n[r] } return n } function Sy(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function yC(t, e, n) { return e && Sy(t.prototype, e), n && Sy(t, n), t } function gc() { return (gc = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }).apply(this, arguments) } function bC(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } function OC(t, e) { if (t == null) return {}; var n, i, r = {}, o = Object.keys(t); for (i = 0; i < o.length; i++)e.indexOf(n = o[i]) >= 0 || (r[n] = t[n]); return r } function xy(t) { return ((e = t) != null && typeof e == "object" && Array.isArray(e) === !1) == 1 && Object.prototype.toString.call(t) === "[object Object]"; var e } var SC = Object.prototype, xC = SC.toString, eQ = SC.hasOwnProperty, wC = /^\s*function (\w+)/; function wy(t) { var e, n = (e = t == null ? void 0 : t.type) !== null && e !== void 0 ? e : t; if (n) { var i = n.toString().match(wC); return i ? i[1] : "" } return "" } var Kr = function (t) { var e, n; return xy(t) !== !1 && typeof (e = t.constructor) == "function" && xy(n = e.prototype) !== !1 && n.hasOwnProperty("isPrototypeOf") !== !1 }, tQ = function (t) { return t }, Nt = tQ, Dl = function (t, e) { return eQ.call(t, e) }, nQ = Number.isInteger || function (t) { return typeof t == "number" && isFinite(t) && Math.floor(t) === t }, Jo = Array.isArray || function (t) { return xC.call(t) === "[object Array]" }, es = function (t) { return xC.call(t) === "[object Function]" }, au = function (t) { return Kr(t) && Dl(t, "_vueTypes_name") }, CC = function (t) { return Kr(t) && (Dl(t, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function (e) { return Dl(t, e) })) }; function Dg(t, e) { return Object.defineProperty(t.bind(e), "__original", { value: t }) } function no(t, e, n) {
        var i; n === void 0 && (n = !1); var r = !0, o = ""; i = Kr(t) ? t : { type: t }; var s = au(i) ? i._vueTypes_name + " - " : ""; if (CC(i) && i.type !== null) { if (i.type === void 0 || i.type === !0 || !i.required && e === void 0) return r; Jo(i.type) ? (r = i.type.some(function (f) { return no(f, e, !0) === !0 }), o = i.type.map(function (f) { return wy(f) }).join(" or ")) : r = (o = wy(i)) === "Array" ? Jo(e) : o === "Object" ? Kr(e) : o === "String" || o === "Number" || o === "Boolean" || o === "Function" ? function (f) { if (f == null) return ""; var h = f.constructor.toString().match(wC); return h ? h[1] : "" }(e) === o : e instanceof i.type } if (!r) { var l = s + 'value "' + e + '" should be of type "' + o + '"'; return n === !1 ? (Nt(l), !1) : l } if (Dl(i, "validator") && es(i.validator)) {
            var a = Nt, c = []; if (Nt = function (f) { c.push(f) }, r = i.validator(e), Nt = a, !r) {
                var u = (c.length > 1 ? "* " : "") + c.join(`
* `); return c.length = 0, n === !1 ? (Nt(u), r) : u
            }
        } return r
    } function pn(t, e) { var n = Object.defineProperties(e, { _vueTypes_name: { value: t, writable: !0 }, isRequired: { get: function () { return this.required = !0, this } }, def: { value: function (r) { return r !== void 0 || this.default ? es(r) || no(this, r, !0) === !0 ? (this.default = Jo(r) ? function () { return [].concat(r) } : Kr(r) ? function () { return Object.assign({}, r) } : r, this) : (Nt(this._vueTypes_name + ' - invalid default value: "' + r + '"'), this) : this } } }), i = n.validator; return es(i) && (n.validator = Dg(i, n)), n } function li(t, e) {
        var n = pn(t, e); return Object.defineProperty(n, "validate", {
            value: function (i) {
                return es(this.validator) && Nt(this._vueTypes_name + ` - calling .validate() will overwrite the current custom validator function. Validator info:
`+ JSON.stringify(this)), this.validator = Dg(i, this), this
            }
        })
    } function Cy(t, e, n) { var i, r, o = (i = e, r = {}, Object.getOwnPropertyNames(i).forEach(function (f) { r[f] = Object.getOwnPropertyDescriptor(i, f) }), Object.defineProperties({}, r)); if (o._vueTypes_name = t, !Kr(n)) return o; var s, l, a = n.validator, c = OC(n, ["validator"]); if (es(a)) { var u = o.validator; u && (u = (l = (s = u).__original) !== null && l !== void 0 ? l : s), o.validator = Dg(u ? function (f) { return u.call(this, f) && a.call(this, f) } : a, o) } return Object.assign(o, c) } function tf(t) { return t.replace(/^(?!\s*$)/gm, "  ") } var iQ = function () { return li("any", {}) }, rQ = function () { return li("function", { type: Function }) }, oQ = function () { return li("boolean", { type: Boolean }) }, sQ = function () { return li("string", { type: String }) }, lQ = function () { return li("number", { type: Number }) }, aQ = function () { return li("array", { type: Array }) }, cQ = function () { return li("object", { type: Object }) }, uQ = function () { return pn("integer", { type: Number, validator: function (t) { return nQ(t) } }) }, fQ = function () { return pn("symbol", { validator: function (t) { return typeof t == "symbol" } }) }; function hQ(t, e) { if (e === void 0 && (e = "custom validation failed"), typeof t != "function") throw new TypeError("[VueTypes error]: You must provide a function as argument"); return pn(t.name || "<<anonymous function>>", { validator: function (n) { var i = t(n); return i || Nt(this._vueTypes_name + " - " + e), i } }) } function dQ(t) { if (!Jo(t)) throw new TypeError("[VueTypes error]: You must provide an array as argument."); var e = 'oneOf - value should be one of "' + t.join('", "') + '".', n = t.reduce(function (i, r) { if (r != null) { var o = r.constructor; i.indexOf(o) === -1 && i.push(o) } return i }, []); return pn("oneOf", { type: n.length > 0 ? n : void 0, validator: function (i) { var r = t.indexOf(i) !== -1; return r || Nt(e), r } }) } function pQ(t) {
        if (!Jo(t)) throw new TypeError("[VueTypes error]: You must provide an array as argument"); for (var e = !1, n = [], i = 0; i < t.length; i += 1) { var r = t[i]; if (CC(r)) { if (au(r) && r._vueTypes_name === "oneOf") { n = n.concat(r.type); continue } if (es(r.validator) && (e = !0), r.type !== !0 && r.type) { n = n.concat(r.type); continue } } n.push(r) } return n = n.filter(function (o, s) { return n.indexOf(o) === s }), pn("oneOfType", e ? {
            type: n, validator: function (o) {
                var s = [], l = t.some(function (a) { var c = no(au(a) && a._vueTypes_name === "oneOf" ? a.type || null : a, o, !0); return typeof c == "string" && s.push(c), c === !0 }); return l || Nt("oneOfType - provided value does not match any of the " + s.length + ` passed-in validators:
`+ tf(s.join(`
`))), l
            }
        } : { type: n })
    } function gQ(t) {
        return pn("arrayOf", {
            type: Array, validator: function (e) {
                var n, i = e.every(function (r) { return (n = no(t, r, !0)) === !0 }); return i || Nt(`arrayOf - value validation error:
`+ tf(n)), i
            }
        })
    } function mQ(t) { return pn("instanceOf", { type: t }) } function vQ(t) {
        return pn("objectOf", {
            type: Object, validator: function (e) {
                var n, i = Object.keys(e).every(function (r) { return (n = no(t, e[r], !0)) === !0 }); return i || Nt(`objectOf - value validation error:
`+ tf(n)), i
            }
        })
    } function yQ(t) {
        var e = Object.keys(t), n = e.filter(function (r) { var o; return !!(!((o = t[r]) === null || o === void 0) && o.required) }), i = pn("shape", {
            type: Object, validator: function (r) {
                var o = this; if (!Kr(r)) return !1; var s = Object.keys(r); if (n.length > 0 && n.some(function (a) { return s.indexOf(a) === -1 })) { var l = n.filter(function (a) { return s.indexOf(a) === -1 }); return Nt(l.length === 1 ? 'shape - required property "' + l[0] + '" is not defined.' : 'shape - required properties "' + l.join('", "') + '" are not defined.'), !1 } return s.every(function (a) {
                    if (e.indexOf(a) === -1) return o._vueTypes_isLoose === !0 || (Nt('shape - shape definition does not include a "' + a + '" property. Allowed keys: "' + e.join('", "') + '".'), !1); var c = no(t[a], r[a], !0); return typeof c == "string" && Nt('shape - "' + a + `" property validation error:
 `+ tf(c)), c === !0
                })
            }
        }); return Object.defineProperty(i, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(i, "loose", { get: function () { return this._vueTypes_isLoose = !0, this } }), i
    } var Vn = function () { function t() { } return t.extend = function (e) { var n = this; if (Jo(e)) return e.forEach(function (f) { return n.extend(f) }), this; var i = e.name, r = e.validate, o = r !== void 0 && r, s = e.getter, l = s !== void 0 && s, a = OC(e, ["name", "validate", "getter"]); if (Dl(this, i)) throw new TypeError('[VueTypes error]: Type "' + i + '" already defined'); var c, u = a.type; return au(u) ? (delete a.type, Object.defineProperty(this, i, l ? { get: function () { return Cy(i, u, a) } } : { value: function () { var f, h = Cy(i, u, a); return h.validator && (h.validator = (f = h.validator).bind.apply(f, [h].concat([].slice.call(arguments)))), h } })) : (c = l ? { get: function () { var f = Object.assign({}, a); return o ? li(i, f) : pn(i, f) }, enumerable: !0 } : { value: function () { var f, h, d = Object.assign({}, a); return f = o ? li(i, d) : pn(i, d), d.validator && (f.validator = (h = d.validator).bind.apply(h, [f].concat([].slice.call(arguments)))), f }, enumerable: !0 }, Object.defineProperty(this, i, c)) }, yC(t, null, [{ key: "any", get: function () { return iQ() } }, { key: "func", get: function () { return rQ().def(this.defaults.func) } }, { key: "bool", get: function () { return oQ().def(this.defaults.bool) } }, { key: "string", get: function () { return sQ().def(this.defaults.string) } }, { key: "number", get: function () { return lQ().def(this.defaults.number) } }, { key: "array", get: function () { return aQ().def(this.defaults.array) } }, { key: "object", get: function () { return cQ().def(this.defaults.object) } }, { key: "integer", get: function () { return uQ().def(this.defaults.integer) } }, { key: "symbol", get: function () { return fQ() } }]), t }(); function TC(t) { var e; return t === void 0 && (t = { func: function () { }, bool: !0, string: "", number: 0, array: function () { return [] }, object: function () { return {} }, integer: 0 }), (e = function (n) { function i() { return n.apply(this, arguments) || this } return bC(i, n), yC(i, null, [{ key: "sensibleDefaults", get: function () { return gc({}, this.defaults) }, set: function (r) { this.defaults = r !== !1 ? gc({}, r !== !0 ? r : t) : {} } }]), i }(Vn)).defaults = gc({}, t), e } Vn.defaults = {}, Vn.custom = hQ, Vn.oneOf = dQ, Vn.instanceOf = mQ, Vn.oneOfType = pQ, Vn.arrayOf = gQ, Vn.objectOf = vQ, Vn.shape = yQ, Vn.utils = { validate: function (t, e) { return no(e, t, !0) === !0 }, toType: function (t, e, n) { return n === void 0 && (n = !1), n ? li(t, e) : pn(t, e) } }; (function (t) { function e() { return t.apply(this, arguments) || this } return bC(e, t), e })(TC()); const $C = TC({ func: void 0, bool: void 0, string: void 0, number: void 0, array: void 0, object: void 0, integer: void 0 }); $C.extend([{ name: "looseBool", getter: !0, type: Boolean, default: void 0 }, { name: "style", getter: !0, type: [String, Object], default: void 0 }, { name: "VueNode", getter: !0, type: null }]); const ne = $C, ii = (t, e, n) => { d5(t, `[ant-design-vue: ${e}] ${n}`) }; function bQ() { return "" } function OQ(t) { return t ? t.ownerDocument : window.document } function kC() { } const SQ = () => ({ action: ne.oneOfType([ne.string, ne.arrayOf(ne.string)]).def([]), showAction: ne.any.def([]), hideAction: ne.any.def([]), getPopupClassNameFromAlign: ne.any.def(bQ), onPopupVisibleChange: Function, afterPopupVisibleChange: ne.func.def(kC), popup: ne.any, arrow: ne.bool.def(!0), popupStyle: { type: Object, default: void 0 }, prefixCls: ne.string.def("rc-trigger-popup"), popupClassName: ne.string.def(""), popupPlacement: String, builtinPlacements: ne.object, popupTransitionName: String, popupAnimation: ne.any, mouseEnterDelay: ne.number.def(0), mouseLeaveDelay: ne.number.def(.1), zIndex: Number, focusDelay: ne.number.def(0), blurDelay: ne.number.def(.15), getPopupContainer: Function, getDocument: ne.func.def(OQ), forceRender: { type: Boolean, default: void 0 }, destroyPopupOnHide: { type: Boolean, default: !1 }, mask: { type: Boolean, default: !1 }, maskClosable: { type: Boolean, default: !0 }, popupAlign: ne.object.def(() => ({})), popupVisible: { type: Boolean, default: void 0 }, defaultPopupVisible: { type: Boolean, default: !1 }, maskTransitionName: String, maskAnimation: String, stretch: String, alignPoint: { type: Boolean, default: void 0 }, autoDestroy: { type: Boolean, default: !1 }, mobile: Object, getTriggerDOMNode: Function }), Bg = { visible: Boolean, prefixCls: String, zIndex: Number, destroyPopupOnHide: Boolean, forceRender: Boolean, arrow: { type: Boolean, default: !0 }, animation: [String, Object], transitionName: String, stretch: { type: String }, align: { type: Object }, point: { type: Object }, getRootDomNode: { type: Function }, getClassNameFromAlign: { type: Function }, onAlign: { type: Function }, onMouseenter: { type: Function }, onMouseleave: { type: Function }, onMousedown: { type: Function }, onTouchstart: { type: Function } }, xQ = S(S({}, Bg), { mobile: { type: Object } }), wQ = S(S({}, Bg), { mask: Boolean, mobile: { type: Object }, maskAnimation: String, maskTransitionName: String }); function PC(t) { let { prefixCls: e, animation: n, transitionName: i } = t; return n ? { name: `${e}-${n}` } : i ? { name: i } : {} } function AC(t) { const { prefixCls: e, visible: n, zIndex: i, mask: r, maskAnimation: o, maskTransitionName: s } = t; if (!r) return null; let l = {}; return (s || o) && (l = PC({ prefixCls: e, transitionName: s, animation: o })), $(os, ee({ appear: !0 }, l), { default: () => [Bp($("div", { style: { zIndex: i }, class: `${e}-mask` }, null), [[pk("if"), n]])] }) } AC.displayName = "Mask"; const CQ = ue({ compatConfig: { MODE: 3 }, name: "MobilePopupInner", inheritAttrs: !1, props: xQ, emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"], setup(t, e) { let { expose: n, slots: i } = e; const r = he(); return n({ forceAlign: () => { }, getElement: () => r.value }), () => { var o; const { zIndex: s, visible: l, prefixCls: a, mobile: { popupClassName: c, popupStyle: u, popupMotion: f = {}, popupRender: h } = {} } = t, d = S({ zIndex: s }, u); let p = Ft((o = i.default) === null || o === void 0 ? void 0 : o.call(i)); p.length > 1 && (p = $("div", { class: `${a}-content` }, [p])), h && (p = h(p)); const g = ke(a, c); return $(os, ee({ ref: r }, f), { default: () => [l ? $("div", { class: g, style: d }, [p]) : null] }) } } }); var TQ = globalThis && globalThis.__awaiter || function (t, e, n, i) { function r(o) { return o instanceof n ? o : new n(function (s) { s(o) }) } return new (n || (n = Promise))(function (o, s) { function l(u) { try { c(i.next(u)) } catch (f) { s(f) } } function a(u) { try { c(i.throw(u)) } catch (f) { s(f) } } function c(u) { u.done ? o(u.value) : r(u.value).then(l, a) } c((i = i.apply(t, e || [])).next()) }) }; const Ty = ["measure", "align", null, "motion"], $Q = (t, e) => { const n = oe(null), i = oe(), r = oe(!1); function o(a) { r.value || (n.value = a) } function s() { nt.cancel(i.value) } function l(a) { s(), i.value = nt(() => { let c = n.value; switch (n.value) { case "align": c = "motion"; break; case "motion": c = "stable"; break }o(c), a == null || a() }) } return Te(t, () => { o("measure") }, { immediate: !0, flush: "post" }), vt(() => { Te(n, () => { switch (n.value) { case "measure": e(); break }n.value && (i.value = nt(() => TQ(void 0, void 0, void 0, function* () { const a = Ty.indexOf(n.value), c = Ty[a + 1]; c && a !== -1 && o(c) }))) }, { immediate: !0, flush: "post" }) }), At(() => { r.value = !0, s() }), [n, l] }, kQ = t => { const e = oe({ width: 0, height: 0 }); function n(r) { e.value = { width: r.offsetWidth, height: r.offsetHeight } } return [E(() => { const r = {}; if (t.value) { const { width: o, height: s } = e.value; t.value.indexOf("height") !== -1 && s ? r.height = `${s}px` : t.value.indexOf("minHeight") !== -1 && s && (r.minHeight = `${s}px`), t.value.indexOf("width") !== -1 && o ? r.width = `${o}px` : t.value.indexOf("minWidth") !== -1 && o && (r.minWidth = `${o}px`) } return r }), n] }; function $y(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(t, r).enumerable })), n.push.apply(n, i) } return n } function ky(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? $y(Object(n), !0).forEach(function (i) { PQ(t, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $y(Object(n)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i)) }) } return t } function tp(t) { "@babel/helpers - typeof"; return tp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, tp(t) } function PQ(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var As, AQ = { Webkit: "-webkit-", Moz: "-moz-", ms: "-ms-", O: "-o-" }; function cu() { if (As !== void 0) return As; As = ""; var t = document.createElement("p").style, e = "Transform"; for (var n in AQ) n + e in t && (As = n); return As } function MC() { return cu() ? "".concat(cu(), "TransitionProperty") : "transitionProperty" } function nf() { return cu() ? "".concat(cu(), "Transform") : "transform" } function Py(t, e) { var n = MC(); n && (t.style[n] = e, n !== "transitionProperty" && (t.style.transitionProperty = e)) } function ph(t, e) { var n = nf(); n && (t.style[n] = e, n !== "transform" && (t.style.transform = e)) } function MQ(t) { return t.style.transitionProperty || t.style[MC()] } function EQ(t) { var e = window.getComputedStyle(t, null), n = e.getPropertyValue("transform") || e.getPropertyValue(nf()); if (n && n !== "none") { var i = n.replace(/[^0-9\-.,]/g, "").split(","); return { x: parseFloat(i[12] || i[4], 0), y: parseFloat(i[13] || i[5], 0) } } return { x: 0, y: 0 } } var _Q = /matrix\((.*)\)/, RQ = /matrix3d\((.*)\)/; function IQ(t, e) { var n = window.getComputedStyle(t, null), i = n.getPropertyValue("transform") || n.getPropertyValue(nf()); if (i && i !== "none") { var r, o = i.match(_Q); if (o) o = o[1], r = o.split(",").map(function (l) { return parseFloat(l, 10) }), r[4] = e.x, r[5] = e.y, ph(t, "matrix(".concat(r.join(","), ")")); else { var s = i.match(RQ)[1]; r = s.split(",").map(function (l) { return parseFloat(l, 10) }), r[12] = e.x, r[13] = e.y, ph(t, "matrix3d(".concat(r.join(","), ")")) } } else ph(t, "translateX(".concat(e.x, "px) translateY(").concat(e.y, "px) translateZ(0)")) } var DQ = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, Jl; function Ay(t) { var e = t.style.display; t.style.display = "none", t.offsetHeight, t.style.display = e } function Bo(t, e, n) { var i = n; if (tp(e) === "object") { for (var r in e) e.hasOwnProperty(r) && Bo(t, r, e[r]); return } if (typeof i < "u") { typeof i == "number" && (i = "".concat(i, "px")), t.style[e] = i; return } return Jl(t, e) } function BQ(t) { var e, n, i, r = t.ownerDocument, o = r.body, s = r && r.documentElement; return e = t.getBoundingClientRect(), n = Math.floor(e.left), i = Math.floor(e.top), n -= s.clientLeft || o.clientLeft || 0, i -= s.clientTop || o.clientTop || 0, { left: n, top: i } } function EC(t, e) { var n = t["page".concat(e ? "Y" : "X", "Offset")], i = "scroll".concat(e ? "Top" : "Left"); if (typeof n != "number") { var r = t.document; n = r.documentElement[i], typeof n != "number" && (n = r.body[i]) } return n } function _C(t) { return EC(t) } function RC(t) { return EC(t, !0) } function Bl(t) { var e = BQ(t), n = t.ownerDocument, i = n.defaultView || n.parentWindow; return e.left += _C(i), e.top += RC(i), e } function Lg(t) { return t != null && t == t.window } function IC(t) { return Lg(t) ? t.document : t.nodeType === 9 ? t : t.ownerDocument } function LQ(t, e, n) { var i = n, r = "", o = IC(t); return i = i || o.defaultView.getComputedStyle(t, null), i && (r = i.getPropertyValue(e) || i[e]), r } var QQ = new RegExp("^(".concat(DQ, ")(?!px)[a-z%]+$"), "i"), NQ = /^(top|right|bottom|left)$/, gh = "currentStyle", mh = "runtimeStyle", Tr = "left", zQ = "px"; function WQ(t, e) { var n = t[gh] && t[gh][e]; if (QQ.test(n) && !NQ.test(e)) { var i = t.style, r = i[Tr], o = t[mh][Tr]; t[mh][Tr] = t[gh][Tr], i[Tr] = e === "fontSize" ? "1em" : n || 0, n = i.pixelLeft + zQ, i[Tr] = r, t[mh][Tr] = o } return n === "" ? "auto" : n } typeof window < "u" && (Jl = window.getComputedStyle ? LQ : WQ); function Na(t, e) { return t === "left" ? e.useCssRight ? "right" : t : e.useCssBottom ? "bottom" : t } function My(t) { if (t === "left") return "right"; if (t === "right") return "left"; if (t === "top") return "bottom"; if (t === "bottom") return "top" } function Ey(t, e, n) { Bo(t, "position") === "static" && (t.style.position = "relative"); var i = -999, r = -999, o = Na("left", n), s = Na("top", n), l = My(o), a = My(s); o !== "left" && (i = 999), s !== "top" && (r = 999); var c = "", u = Bl(t); ("left" in e || "top" in e) && (c = MQ(t) || "", Py(t, "none")), "left" in e && (t.style[l] = "", t.style[o] = "".concat(i, "px")), "top" in e && (t.style[a] = "", t.style[s] = "".concat(r, "px")), Ay(t); var f = Bl(t), h = {}; for (var d in e) if (e.hasOwnProperty(d)) { var p = Na(d, n), g = d === "left" ? i : r, m = u[d] - f[d]; p === d ? h[p] = g + m : h[p] = g - m } Bo(t, h), Ay(t), ("left" in e || "top" in e) && Py(t, c); var v = {}; for (var b in e) if (e.hasOwnProperty(b)) { var x = Na(b, n), w = e[b] - u[b]; b === x ? v[x] = h[x] + w : v[x] = h[x] - w } Bo(t, v) } function HQ(t, e) { var n = Bl(t), i = EQ(t), r = { x: i.x, y: i.y }; "left" in e && (r.x = i.x + e.left - n.left), "top" in e && (r.y = i.y + e.top - n.top), IQ(t, r) } function FQ(t, e, n) { if (n.ignoreShake) { var i = Bl(t), r = i.left.toFixed(0), o = i.top.toFixed(0), s = e.left.toFixed(0), l = e.top.toFixed(0); if (r === s && o === l) return } n.useCssRight || n.useCssBottom ? Ey(t, e, n) : n.useCssTransform && nf() in document.body.style ? HQ(t, e) : Ey(t, e, n) } function Qg(t, e) { for (var n = 0; n < t.length; n++)e(t[n]) } function DC(t) { return Jl(t, "boxSizing") === "border-box" } var jQ = ["margin", "border", "padding"], np = -1, qQ = 2, ip = 1, VQ = 0; function XQ(t, e, n) { var i = {}, r = t.style, o; for (o in e) e.hasOwnProperty(o) && (i[o] = r[o], r[o] = e[o]); n.call(t); for (o in e) e.hasOwnProperty(o) && (r[o] = i[o]) } function Ns(t, e, n) { var i = 0, r, o, s; for (o = 0; o < e.length; o++)if (r = e[o], r) for (s = 0; s < n.length; s++) { var l = void 0; r === "border" ? l = "".concat(r).concat(n[s], "Width") : l = r + n[s], i += parseFloat(Jl(t, l)) || 0 } return i } var ti = { getParent: function (e) { var n = e; do n.nodeType === 11 && n.host ? n = n.host : n = n.parentNode; while (n && n.nodeType !== 1 && n.nodeType !== 9); return n } }; Qg(["Width", "Height"], function (t) { ti["doc".concat(t)] = function (e) { var n = e.document; return Math.max(n.documentElement["scroll".concat(t)], n.body["scroll".concat(t)], ti["viewport".concat(t)](n)) }, ti["viewport".concat(t)] = function (e) { var n = "client".concat(t), i = e.document, r = i.body, o = i.documentElement, s = o[n]; return i.compatMode === "CSS1Compat" && s || r && r[n] || s } }); function _y(t, e, n) { var i = n; if (Lg(t)) return e === "width" ? ti.viewportWidth(t) : ti.viewportHeight(t); if (t.nodeType === 9) return e === "width" ? ti.docWidth(t) : ti.docHeight(t); var r = e === "width" ? ["Left", "Right"] : ["Top", "Bottom"], o = Math.floor(e === "width" ? t.getBoundingClientRect().width : t.getBoundingClientRect().height), s = DC(t), l = 0; (o == null || o <= 0) && (o = void 0, l = Jl(t, e), (l == null || Number(l) < 0) && (l = t.style[e] || 0), l = Math.floor(parseFloat(l)) || 0), i === void 0 && (i = s ? ip : np); var a = o !== void 0 || s, c = o || l; return i === np ? a ? c - Ns(t, ["border", "padding"], r) : l : a ? i === ip ? c : c + (i === qQ ? -Ns(t, ["border"], r) : Ns(t, ["margin"], r)) : l + Ns(t, jQ.slice(i), r) } var UQ = { position: "absolute", visibility: "hidden", display: "block" }; function Ry() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; var i, r = e[0]; return r.offsetWidth !== 0 ? i = _y.apply(void 0, e) : XQ(r, UQ, function () { i = _y.apply(void 0, e) }), i } Qg(["width", "height"], function (t) { var e = t.charAt(0).toUpperCase() + t.slice(1); ti["outer".concat(e)] = function (i, r) { return i && Ry(i, t, r ? VQ : ip) }; var n = t === "width" ? ["Left", "Right"] : ["Top", "Bottom"]; ti[t] = function (i, r) { var o = r; if (o !== void 0) { if (i) { var s = DC(i); return s && (o += Ns(i, ["padding", "border"], n)), Bo(i, t, o) } return } return i && Ry(i, t, np) } }); function BC(t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } var we = { getWindow: function (e) { if (e && e.document && e.setTimeout) return e; var n = e.ownerDocument || e; return n.defaultView || n.parentWindow }, getDocument: IC, offset: function (e, n, i) { if (typeof n < "u") FQ(e, n, i || {}); else return Bl(e) }, isWindow: Lg, each: Qg, css: Bo, clone: function (e) { var n, i = {}; for (n in e) e.hasOwnProperty(n) && (i[n] = e[n]); var r = e.overflow; if (r) for (n in e) e.hasOwnProperty(n) && (i.overflow[n] = e.overflow[n]); return i }, mix: BC, getWindowScrollLeft: function (e) { return _C(e) }, getWindowScrollTop: function (e) { return RC(e) }, merge: function () { for (var e = {}, n = 0; n < arguments.length; n++)we.mix(e, n < 0 || arguments.length <= n ? void 0 : arguments[n]); return e }, viewportWidth: 0, viewportHeight: 0 }; BC(we, ti); var vh = we.getParent; function rp(t) { if (we.isWindow(t) || t.nodeType === 9) return null; var e = we.getDocument(t), n = e.body, i, r = we.css(t, "position"), o = r === "fixed" || r === "absolute"; if (!o) return t.nodeName.toLowerCase() === "html" ? null : vh(t); for (i = vh(t); i && i !== n && i.nodeType !== 9; i = vh(i))if (r = we.css(i, "position"), r !== "static") return i; return null } var Iy = we.getParent; function GQ(t) { if (we.isWindow(t) || t.nodeType === 9) return !1; var e = we.getDocument(t), n = e.body, i = null; for (i = Iy(t); i && i !== n && i !== e; i = Iy(i)) { var r = we.css(i, "position"); if (r === "fixed") return !0 } return !1 } function Ng(t, e) { for (var n = { left: 0, right: 1 / 0, top: 0, bottom: 1 / 0 }, i = rp(t), r = we.getDocument(t), o = r.defaultView || r.parentWindow, s = r.body, l = r.documentElement; i;) { if ((navigator.userAgent.indexOf("MSIE") === -1 || i.clientWidth !== 0) && i !== s && i !== l && we.css(i, "overflow") !== "visible") { var a = we.offset(i); a.left += i.clientLeft, a.top += i.clientTop, n.top = Math.max(n.top, a.top), n.right = Math.min(n.right, a.left + i.clientWidth), n.bottom = Math.min(n.bottom, a.top + i.clientHeight), n.left = Math.max(n.left, a.left) } else if (i === s || i === l) break; i = rp(i) } var c = null; if (!we.isWindow(t) && t.nodeType !== 9) { c = t.style.position; var u = we.css(t, "position"); u === "absolute" && (t.style.position = "fixed") } var f = we.getWindowScrollLeft(o), h = we.getWindowScrollTop(o), d = we.viewportWidth(o), p = we.viewportHeight(o), g = l.scrollWidth, m = l.scrollHeight, v = window.getComputedStyle(s); if (v.overflowX === "hidden" && (g = o.innerWidth), v.overflowY === "hidden" && (m = o.innerHeight), t.style && (t.style.position = c), e || GQ(t)) n.left = Math.max(n.left, f), n.top = Math.max(n.top, h), n.right = Math.min(n.right, f + d), n.bottom = Math.min(n.bottom, h + p); else { var b = Math.max(g, f + d); n.right = Math.min(n.right, b); var x = Math.max(m, h + p); n.bottom = Math.min(n.bottom, x) } return n.top >= 0 && n.left >= 0 && n.bottom > n.top && n.right > n.left ? n : null } function KQ(t, e, n, i) { var r = we.clone(t), o = { width: e.width, height: e.height }; return i.adjustX && r.left < n.left && (r.left = n.left), i.resizeWidth && r.left >= n.left && r.left + o.width > n.right && (o.width -= r.left + o.width - n.right), i.adjustX && r.left + o.width > n.right && (r.left = Math.max(n.right - o.width, n.left)), i.adjustY && r.top < n.top && (r.top = n.top), i.resizeHeight && r.top >= n.top && r.top + o.height > n.bottom && (o.height -= r.top + o.height - n.bottom), i.adjustY && r.top + o.height > n.bottom && (r.top = Math.max(n.bottom - o.height, n.top)), we.mix(r, o) } function zg(t) { var e, n, i; if (!we.isWindow(t) && t.nodeType !== 9) e = we.offset(t), n = we.outerWidth(t), i = we.outerHeight(t); else { var r = we.getWindow(t); e = { left: we.getWindowScrollLeft(r), top: we.getWindowScrollTop(r) }, n = we.viewportWidth(r), i = we.viewportHeight(r) } return e.width = n, e.height = i, e } function Dy(t, e) { var n = e.charAt(0), i = e.charAt(1), r = t.width, o = t.height, s = t.left, l = t.top; return n === "c" ? l += o / 2 : n === "b" && (l += o), i === "c" ? s += r / 2 : i === "r" && (s += r), { left: s, top: l } } function za(t, e, n, i, r) { var o = Dy(e, n[1]), s = Dy(t, n[0]), l = [s.left - o.left, s.top - o.top]; return { left: Math.round(t.left - l[0] + i[0] - r[0]), top: Math.round(t.top - l[1] + i[1] - r[1]) } } function By(t, e, n) { return t.left < n.left || t.left + e.width > n.right } function Ly(t, e, n) { return t.top < n.top || t.top + e.height > n.bottom } function YQ(t, e, n) { return t.left > n.right || t.left + e.width < n.left } function ZQ(t, e, n) { return t.top > n.bottom || t.top + e.height < n.top } function Wa(t, e, n) { var i = []; return we.each(t, function (r) { i.push(r.replace(e, function (o) { return n[o] })) }), i } function Ha(t, e) { return t[e] = -t[e], t } function Qy(t, e) { var n; return /%$/.test(t) ? n = parseInt(t.substring(0, t.length - 1), 10) / 100 * e : n = parseInt(t, 10), n || 0 } function Ny(t, e) { t[0] = Qy(t[0], e.width), t[1] = Qy(t[1], e.height) } function LC(t, e, n, i) { var r = n.points, o = n.offset || [0, 0], s = n.targetOffset || [0, 0], l = n.overflow, a = n.source || t; o = [].concat(o), s = [].concat(s), l = l || {}; var c = {}, u = 0, f = !!(l && l.alwaysByViewport), h = Ng(a, f), d = zg(a); Ny(o, d), Ny(s, e); var p = za(d, e, r, o, s), g = we.merge(d, p); if (h && (l.adjustX || l.adjustY) && i) { if (l.adjustX && By(p, d, h)) { var m = Wa(r, /[lr]/gi, { l: "r", r: "l" }), v = Ha(o, 0), b = Ha(s, 0), x = za(d, e, m, v, b); YQ(x, d, h) || (u = 1, r = m, o = v, s = b) } if (l.adjustY && Ly(p, d, h)) { var w = Wa(r, /[tb]/gi, { t: "b", b: "t" }), y = Ha(o, 1), C = Ha(s, 1), O = za(d, e, w, y, C); ZQ(O, d, h) || (u = 1, r = w, o = y, s = C) } u && (p = za(d, e, r, o, s), we.mix(g, p)); var P = By(p, d, h), M = Ly(p, d, h); if (P || M) { var A = r; P && (A = Wa(r, /[lr]/gi, { l: "r", r: "l" })), M && (A = Wa(r, /[tb]/gi, { t: "b", b: "t" })), r = A, o = n.offset || [0, 0], s = n.targetOffset || [0, 0] } c.adjustX = l.adjustX && P, c.adjustY = l.adjustY && M, (c.adjustX || c.adjustY) && (g = KQ(p, d, h, c)) } return g.width !== d.width && we.css(a, "width", we.width(a) + g.width - d.width), g.height !== d.height && we.css(a, "height", we.height(a) + g.height - d.height), we.offset(a, { left: g.left, top: g.top }, { useCssRight: n.useCssRight, useCssBottom: n.useCssBottom, useCssTransform: n.useCssTransform, ignoreShake: n.ignoreShake }), { points: r, offset: o, targetOffset: s, overflow: c } } function JQ(t, e) { var n = Ng(t, e), i = zg(t); return !n || i.left + i.width <= n.left || i.top + i.height <= n.top || i.left >= n.right || i.top >= n.bottom } function Wg(t, e, n) { var i = n.target || e, r = zg(i), o = !JQ(i, n.overflow && n.overflow.alwaysByViewport); return LC(t, r, n, o) } Wg.__getOffsetParent = rp; Wg.__getVisibleRectForElement = Ng; function eN(t, e, n) { var i, r, o = we.getDocument(t), s = o.defaultView || o.parentWindow, l = we.getWindowScrollLeft(s), a = we.getWindowScrollTop(s), c = we.viewportWidth(s), u = we.viewportHeight(s); "pageX" in e ? i = e.pageX : i = l + e.clientX, "pageY" in e ? r = e.pageY : r = a + e.clientY; var f = { left: i, top: r, width: 0, height: 0 }, h = i >= 0 && i <= l + c && r >= 0 && r <= a + u, d = [n.points[0], "cc"]; return LC(t, f, ky(ky({}, n), {}, { points: d }), h) } function ai(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, r = t; if (Array.isArray(t) && (r = us(t)[0]), !r) return null; const o = Pi(r, e, i); return o.props = n ? S(S({}, o.props), e) : o.props, Zw(typeof o.props.class != "object"), o } const QC = t => (t || []).some(e => wn(e) ? !(e.type === Ut || e.type === et && !QC(e.children)) : !0) ? t : null; function tN(t, e, n, i) { var r; const o = (r = t[e]) === null || r === void 0 ? void 0 : r.call(t, n); return QC(o) ? o : i == null ? void 0 : i() } const NC = t => { if (!t) return !1; if (t.offsetParent) return !0; if (t.getBBox) { const e = t.getBBox(); if (e.width || e.height) return !0 } if (t.getBoundingClientRect) { const e = t.getBoundingClientRect(); if (e.width || e.height) return !0 } return !1 }; function nN(t, e) { return t === e ? !0 : !t || !e ? !1 : "pageX" in e && "pageY" in e ? t.pageX === e.pageX && t.pageY === e.pageY : "clientX" in e && "clientY" in e ? t.clientX === e.clientX && t.clientY === e.clientY : !1 } function iN(t, e) { t !== document.activeElement && _r(e, t) && typeof t.focus == "function" && t.focus() } function zy(t, e) { let n = null, i = null; function r(s) { let [{ target: l }] = s; if (!document.documentElement.contains(l)) return; const { width: a, height: c } = l.getBoundingClientRect(), u = Math.floor(a), f = Math.floor(c); (n !== u || i !== f) && Promise.resolve().then(() => { e({ width: u, height: f }) }), n = u, i = f } const o = new Iw(r); return t && o.observe(t), () => { o.disconnect() } } const rN = (t, e) => { let n = !1, i = null; function r() { clearTimeout(i) } function o(s) { if (!n || s === !0) { if (t() === !1) return; n = !0, r(), i = setTimeout(() => { n = !1 }, e.value) } else r(), i = setTimeout(() => { n = !1, o() }, e.value) } return [o, () => { n = !1, r() }] }; function oN() { this.__data__ = [], this.size = 0 } function Hg(t, e) { return t === e || t !== t && e !== e } function rf(t, e) { for (var n = t.length; n--;)if (Hg(t[n][0], e)) return n; return -1 } var sN = Array.prototype, lN = sN.splice; function aN(t) { var e = this.__data__, n = rf(e, t); if (n < 0) return !1; var i = e.length - 1; return n == i ? e.pop() : lN.call(e, n, 1), --this.size, !0 } function cN(t) { var e = this.__data__, n = rf(e, t); return n < 0 ? void 0 : e[n][1] } function uN(t) { return rf(this.__data__, t) > -1 } function fN(t, e) { var n = this.__data__, i = rf(n, t); return i < 0 ? (++this.size, n.push([t, e])) : n[i][1] = e, this } function Di(t) { var e = -1, n = t == null ? 0 : t.length; for (this.clear(); ++e < n;) { var i = t[e]; this.set(i[0], i[1]) } } Di.prototype.clear = oN; Di.prototype.delete = aN; Di.prototype.get = cN; Di.prototype.has = uN; Di.prototype.set = fN; function hN() { this.__data__ = new Di, this.size = 0 } function dN(t) { var e = this.__data__, n = e.delete(t); return this.size = e.size, n } function pN(t) { return this.__data__.get(t) } function gN(t) { return this.__data__.has(t) } var mN = typeof global == "object" && global && global.Object === Object && global; const zC = mN; var vN = typeof self == "object" && self && self.Object === Object && self, yN = zC || vN || Function("return this")(); const Bi = yN; var bN = Bi.Symbol; const ci = bN; var WC = Object.prototype, ON = WC.hasOwnProperty, SN = WC.toString, Ms = ci ? ci.toStringTag : void 0; function xN(t) { var e = ON.call(t, Ms), n = t[Ms]; try { t[Ms] = void 0; var i = !0 } catch { } var r = SN.call(t); return i && (e ? t[Ms] = n : delete t[Ms]), r } var wN = Object.prototype, CN = wN.toString; function TN(t) { return CN.call(t) } var $N = "[object Null]", kN = "[object Undefined]", Wy = ci ? ci.toStringTag : void 0; function io(t) { return t == null ? t === void 0 ? kN : $N : Wy && Wy in Object(t) ? xN(t) : TN(t) } function uu(t) { var e = typeof t; return t != null && (e == "object" || e == "function") } var PN = "[object AsyncFunction]", AN = "[object Function]", MN = "[object GeneratorFunction]", EN = "[object Proxy]"; function HC(t) { if (!uu(t)) return !1; var e = io(t); return e == AN || e == MN || e == PN || e == EN } var _N = Bi["__core-js_shared__"]; const yh = _N; var Hy = function () { var t = /[^.]+$/.exec(yh && yh.keys && yh.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }(); function RN(t) { return !!Hy && Hy in t } var IN = Function.prototype, DN = IN.toString; function ro(t) { if (t != null) { try { return DN.call(t) } catch { } try { return t + "" } catch { } } return "" } var BN = /[\\^$.*+?()[\]{}|]/g, LN = /^\[object .+?Constructor\]$/, QN = Function.prototype, NN = Object.prototype, zN = QN.toString, WN = NN.hasOwnProperty, HN = RegExp("^" + zN.call(WN).replace(BN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function FN(t) { if (!uu(t) || RN(t)) return !1; var e = HC(t) ? HN : LN; return e.test(ro(t)) } function jN(t, e) { return t == null ? void 0 : t[e] } function oo(t, e) { var n = jN(t, e); return FN(n) ? n : void 0 } var qN = oo(Bi, "Map"); const Ll = qN; var VN = oo(Object, "create"); const Ql = VN; function XN() { this.__data__ = Ql ? Ql(null) : {}, this.size = 0 } function UN(t) { var e = this.has(t) && delete this.__data__[t]; return this.size -= e ? 1 : 0, e } var GN = "__lodash_hash_undefined__", KN = Object.prototype, YN = KN.hasOwnProperty; function ZN(t) { var e = this.__data__; if (Ql) { var n = e[t]; return n === GN ? void 0 : n } return YN.call(e, t) ? e[t] : void 0 } var JN = Object.prototype, ez = JN.hasOwnProperty; function tz(t) { var e = this.__data__; return Ql ? e[t] !== void 0 : ez.call(e, t) } var nz = "__lodash_hash_undefined__"; function iz(t, e) { var n = this.__data__; return this.size += this.has(t) ? 0 : 1, n[t] = Ql && e === void 0 ? nz : e, this } function Yr(t) { var e = -1, n = t == null ? 0 : t.length; for (this.clear(); ++e < n;) { var i = t[e]; this.set(i[0], i[1]) } } Yr.prototype.clear = XN; Yr.prototype.delete = UN; Yr.prototype.get = ZN; Yr.prototype.has = tz; Yr.prototype.set = iz; function rz() { this.size = 0, this.__data__ = { hash: new Yr, map: new (Ll || Di), string: new Yr } } function oz(t) { var e = typeof t; return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null } function of(t, e) { var n = t.__data__; return oz(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map } function sz(t) { var e = of(this, t).delete(t); return this.size -= e ? 1 : 0, e } function lz(t) { return of(this, t).get(t) } function az(t) { return of(this, t).has(t) } function cz(t, e) { var n = of(this, t), i = n.size; return n.set(t, e), this.size += n.size == i ? 0 : 1, this } function Li(t) { var e = -1, n = t == null ? 0 : t.length; for (this.clear(); ++e < n;) { var i = t[e]; this.set(i[0], i[1]) } } Li.prototype.clear = rz; Li.prototype.delete = sz; Li.prototype.get = lz; Li.prototype.has = az; Li.prototype.set = cz; var uz = 200; function fz(t, e) { var n = this.__data__; if (n instanceof Di) { var i = n.__data__; if (!Ll || i.length < uz - 1) return i.push([t, e]), this.size = ++n.size, this; n = this.__data__ = new Li(i) } return n.set(t, e), this.size = n.size, this } function or(t) { var e = this.__data__ = new Di(t); this.size = e.size } or.prototype.clear = hN; or.prototype.delete = dN; or.prototype.get = pN; or.prototype.has = gN; or.prototype.set = fz; var hz = "__lodash_hash_undefined__"; function dz(t) { return this.__data__.set(t, hz), this } function pz(t) { return this.__data__.has(t) } function Nl(t) { var e = -1, n = t == null ? 0 : t.length; for (this.__data__ = new Li; ++e < n;)this.add(t[e]) } Nl.prototype.add = Nl.prototype.push = dz; Nl.prototype.has = pz; function gz(t, e) { for (var n = -1, i = t == null ? 0 : t.length; ++n < i;)if (e(t[n], n, t)) return !0; return !1 } function FC(t, e) { return t.has(e) } var mz = 1, vz = 2; function jC(t, e, n, i, r, o) { var s = n & mz, l = t.length, a = e.length; if (l != a && !(s && a > l)) return !1; var c = o.get(t), u = o.get(e); if (c && u) return c == e && u == t; var f = -1, h = !0, d = n & vz ? new Nl : void 0; for (o.set(t, e), o.set(e, t); ++f < l;) { var p = t[f], g = e[f]; if (i) var m = s ? i(g, p, f, e, t, o) : i(p, g, f, t, e, o); if (m !== void 0) { if (m) continue; h = !1; break } if (d) { if (!gz(e, function (v, b) { if (!FC(d, b) && (p === v || r(p, v, n, i, o))) return d.push(b) })) { h = !1; break } } else if (!(p === g || r(p, g, n, i, o))) { h = !1; break } } return o.delete(t), o.delete(e), h } var yz = Bi.Uint8Array; const Fy = yz; function bz(t) { var e = -1, n = Array(t.size); return t.forEach(function (i, r) { n[++e] = [r, i] }), n } function Fg(t) { var e = -1, n = Array(t.size); return t.forEach(function (i) { n[++e] = i }), n } var Oz = 1, Sz = 2, xz = "[object Boolean]", wz = "[object Date]", Cz = "[object Error]", Tz = "[object Map]", $z = "[object Number]", kz = "[object RegExp]", Pz = "[object Set]", Az = "[object String]", Mz = "[object Symbol]", Ez = "[object ArrayBuffer]", _z = "[object DataView]", jy = ci ? ci.prototype : void 0, bh = jy ? jy.valueOf : void 0; function Rz(t, e, n, i, r, o, s) { switch (n) { case _z: if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1; t = t.buffer, e = e.buffer; case Ez: return !(t.byteLength != e.byteLength || !o(new Fy(t), new Fy(e))); case xz: case wz: case $z: return Hg(+t, +e); case Cz: return t.name == e.name && t.message == e.message; case kz: case Az: return t == e + ""; case Tz: var l = bz; case Pz: var a = i & Oz; if (l || (l = Fg), t.size != e.size && !a) return !1; var c = s.get(t); if (c) return c == e; i |= Sz, s.set(t, e); var u = jC(l(t), l(e), i, r, o, s); return s.delete(t), u; case Mz: if (bh) return bh.call(t) == bh.call(e) }return !1 } function qC(t, e) { for (var n = -1, i = e.length, r = t.length; ++n < i;)t[r + n] = e[n]; return t } var Iz = Array.isArray; const ui = Iz; function Dz(t, e, n) { var i = e(t); return ui(t) ? i : qC(i, n(t)) } function Bz(t, e) { for (var n = -1, i = t == null ? 0 : t.length, r = 0, o = []; ++n < i;) { var s = t[n]; e(s, n, t) && (o[r++] = s) } return o } function Lz() { return [] } var Qz = Object.prototype, Nz = Qz.propertyIsEnumerable, qy = Object.getOwnPropertySymbols, zz = qy ? function (t) { return t == null ? [] : (t = Object(t), Bz(qy(t), function (e) { return Nz.call(t, e) })) } : Lz; const Wz = zz; function Hz(t, e) { for (var n = -1, i = Array(t); ++n < t;)i[n] = e(n); return i } function Zr(t) { return t != null && typeof t == "object" } var Fz = "[object Arguments]"; function Vy(t) { return Zr(t) && io(t) == Fz } var VC = Object.prototype, jz = VC.hasOwnProperty, qz = VC.propertyIsEnumerable, Vz = Vy(function () { return arguments }()) ? Vy : function (t) { return Zr(t) && jz.call(t, "callee") && !qz.call(t, "callee") }; const sf = Vz; function Xz() { return !1 } var XC = typeof Ci == "object" && Ci && !Ci.nodeType && Ci, Xy = XC && typeof Ti == "object" && Ti && !Ti.nodeType && Ti, Uz = Xy && Xy.exports === XC, Uy = Uz ? Bi.Buffer : void 0, Gz = Uy ? Uy.isBuffer : void 0, Kz = Gz || Xz; const fu = Kz; var Yz = 9007199254740991, Zz = /^(?:0|[1-9]\d*)$/; function jg(t, e) { var n = typeof t; return e = e ?? Yz, !!e && (n == "number" || n != "symbol" && Zz.test(t)) && t > -1 && t % 1 == 0 && t < e } var Jz = 9007199254740991; function qg(t) { return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Jz } var e4 = "[object Arguments]", t4 = "[object Array]", n4 = "[object Boolean]", i4 = "[object Date]", r4 = "[object Error]", o4 = "[object Function]", s4 = "[object Map]", l4 = "[object Number]", a4 = "[object Object]", c4 = "[object RegExp]", u4 = "[object Set]", f4 = "[object String]", h4 = "[object WeakMap]", d4 = "[object ArrayBuffer]", p4 = "[object DataView]", g4 = "[object Float32Array]", m4 = "[object Float64Array]", v4 = "[object Int8Array]", y4 = "[object Int16Array]", b4 = "[object Int32Array]", O4 = "[object Uint8Array]", S4 = "[object Uint8ClampedArray]", x4 = "[object Uint16Array]", w4 = "[object Uint32Array]", Xe = {}; Xe[g4] = Xe[m4] = Xe[v4] = Xe[y4] = Xe[b4] = Xe[O4] = Xe[S4] = Xe[x4] = Xe[w4] = !0; Xe[e4] = Xe[t4] = Xe[d4] = Xe[n4] = Xe[p4] = Xe[i4] = Xe[r4] = Xe[o4] = Xe[s4] = Xe[l4] = Xe[a4] = Xe[c4] = Xe[u4] = Xe[f4] = Xe[h4] = !1; function C4(t) { return Zr(t) && qg(t.length) && !!Xe[io(t)] } function T4(t) { return function (e) { return t(e) } } var UC = typeof Ci == "object" && Ci && !Ci.nodeType && Ci, nl = UC && typeof Ti == "object" && Ti && !Ti.nodeType && Ti, $4 = nl && nl.exports === UC, Oh = $4 && zC.process, k4 = function () { try { var t = nl && nl.require && nl.require("util").types; return t || Oh && Oh.binding && Oh.binding("util") } catch { } }(); const Gy = k4; var Ky = Gy && Gy.isTypedArray, P4 = Ky ? T4(Ky) : C4; const Vg = P4; var A4 = Object.prototype, M4 = A4.hasOwnProperty; function E4(t, e) { var n = ui(t), i = !n && sf(t), r = !n && !i && fu(t), o = !n && !i && !r && Vg(t), s = n || i || r || o, l = s ? Hz(t.length, String) : [], a = l.length; for (var c in t) (e || M4.call(t, c)) && !(s && (c == "length" || r && (c == "offset" || c == "parent") || o && (c == "buffer" || c == "byteLength" || c == "byteOffset") || jg(c, a))) && l.push(c); return l } var _4 = Object.prototype; function GC(t) { var e = t && t.constructor, n = typeof e == "function" && e.prototype || _4; return t === n } function KC(t, e) { return function (n) { return t(e(n)) } } var R4 = KC(Object.keys, Object); const I4 = R4; var D4 = Object.prototype, B4 = D4.hasOwnProperty; function YC(t) { if (!GC(t)) return I4(t); var e = []; for (var n in Object(t)) B4.call(t, n) && n != "constructor" && e.push(n); return e } function ZC(t) { return t != null && qg(t.length) && !HC(t) } function L4(t) { return ZC(t) ? E4(t) : YC(t) } function Yy(t) { return Dz(t, L4, Wz) } var Q4 = 1, N4 = Object.prototype, z4 = N4.hasOwnProperty; function W4(t, e, n, i, r, o) { var s = n & Q4, l = Yy(t), a = l.length, c = Yy(e), u = c.length; if (a != u && !s) return !1; for (var f = a; f--;) { var h = l[f]; if (!(s ? h in e : z4.call(e, h))) return !1 } var d = o.get(t), p = o.get(e); if (d && p) return d == e && p == t; var g = !0; o.set(t, e), o.set(e, t); for (var m = s; ++f < a;) { h = l[f]; var v = t[h], b = e[h]; if (i) var x = s ? i(b, v, h, e, t, o) : i(v, b, h, t, e, o); if (!(x === void 0 ? v === b || r(v, b, n, i, o) : x)) { g = !1; break } m || (m = h == "constructor") } if (g && !m) { var w = t.constructor, y = e.constructor; w != y && "constructor" in t && "constructor" in e && !(typeof w == "function" && w instanceof w && typeof y == "function" && y instanceof y) && (g = !1) } return o.delete(t), o.delete(e), g } var H4 = oo(Bi, "DataView"); const op = H4; var F4 = oo(Bi, "Promise"); const sp = F4; var j4 = oo(Bi, "Set"); const Lo = j4; var q4 = oo(Bi, "WeakMap"); const lp = q4; var Zy = "[object Map]", V4 = "[object Object]", Jy = "[object Promise]", eb = "[object Set]", tb = "[object WeakMap]", nb = "[object DataView]", X4 = ro(op), U4 = ro(Ll), G4 = ro(sp), K4 = ro(Lo), Y4 = ro(lp), Pr = io; (op && Pr(new op(new ArrayBuffer(1))) != nb || Ll && Pr(new Ll) != Zy || sp && Pr(sp.resolve()) != Jy || Lo && Pr(new Lo) != eb || lp && Pr(new lp) != tb) && (Pr = function (t) { var e = io(t), n = e == V4 ? t.constructor : void 0, i = n ? ro(n) : ""; if (i) switch (i) { case X4: return nb; case U4: return Zy; case G4: return Jy; case K4: return eb; case Y4: return tb }return e }); const ap = Pr; var Z4 = 1, ib = "[object Arguments]", rb = "[object Array]", Fa = "[object Object]", J4 = Object.prototype, ob = J4.hasOwnProperty; function eW(t, e, n, i, r, o) { var s = ui(t), l = ui(e), a = s ? rb : ap(t), c = l ? rb : ap(e); a = a == ib ? Fa : a, c = c == ib ? Fa : c; var u = a == Fa, f = c == Fa, h = a == c; if (h && fu(t)) { if (!fu(e)) return !1; s = !0, u = !1 } if (h && !u) return o || (o = new or), s || Vg(t) ? jC(t, e, n, i, r, o) : Rz(t, e, a, n, i, r, o); if (!(n & Z4)) { var d = u && ob.call(t, "__wrapped__"), p = f && ob.call(e, "__wrapped__"); if (d || p) { var g = d ? t.value() : t, m = p ? e.value() : e; return o || (o = new or), r(g, m, n, i, o) } } return h ? (o || (o = new or), W4(t, e, n, i, r, o)) : !1 } function JC(t, e, n, i, r) { return t === e ? !0 : t == null || e == null || !Zr(t) && !Zr(e) ? t !== t && e !== e : eW(t, e, n, i, JC, r) } function tW(t, e) { return JC(t, e) } const nW = { align: Object, target: [Object, Function], onAlign: Function, monitorBufferTime: Number, monitorWindowResize: Boolean, disabled: Boolean }; function sb(t) { return typeof t != "function" ? null : t() } function lb(t) { return typeof t != "object" || !t ? null : t } const iW = ue({ compatConfig: { MODE: 3 }, name: "Align", props: nW, emits: ["align"], setup(t, e) { let { expose: n, slots: i } = e; const r = he({}), o = he(), [s, l] = rN(() => { const { disabled: h, target: d, align: p, onAlign: g } = t; if (!h && d && o.value) { const m = o.value; let v; const b = sb(d), x = lb(d); r.value.element = b, r.value.point = x, r.value.align = p; const { activeElement: w } = document; return b && NC(b) ? v = Wg(m, b, p) : x && (v = eN(m, x, p)), iN(w, m), g && v && g(m, v), !0 } return !1 }, E(() => t.monitorBufferTime)), a = he({ cancel: () => { } }), c = he({ cancel: () => { } }), u = () => { const h = t.target, d = sb(h), p = lb(h); o.value !== c.value.element && (c.value.cancel(), c.value.element = o.value, c.value.cancel = zy(o.value, s)), (r.value.element !== d || !nN(r.value.point, p) || !tW(r.value.align, t.align)) && (s(), a.value.element !== d && (a.value.cancel(), a.value.element = d, a.value.cancel = zy(d, s))) }; vt(() => { ri(() => { u() }) }), is(() => { ri(() => { u() }) }), Te(() => t.disabled, h => { h ? l() : s() }, { immediate: !0, flush: "post" }); const f = he(null); return Te(() => t.monitorWindowResize, h => { h ? f.value || (f.value = Qs(window, "resize", s)) : f.value && (f.value.remove(), f.value = null) }, { flush: "post" }), Wl(() => { a.value.cancel(), c.value.cancel(), f.value && f.value.remove(), l() }), n({ forceAlign: () => s(!0) }), () => { const h = i == null ? void 0 : i.default(); return h ? ai(h[0], { ref: o }, !0, !0) : null } } }); iu("bottomLeft", "bottomRight", "topLeft", "topRight"); const eT = function (t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return S(t ? { name: t, appear: !0, enterFromClass: `${t}-enter ${t}-enter-prepare ${t}-enter-start`, enterActiveClass: `${t}-enter ${t}-enter-prepare`, enterToClass: `${t}-enter ${t}-enter-active`, leaveFromClass: ` ${t}-leave`, leaveActiveClass: `${t}-leave ${t}-leave-active`, leaveToClass: `${t}-leave ${t}-leave-active` } : { css: !1 }, e) }, rW = (t, e, n) => n !== void 0 ? n : `${t}-${e}`, oW = ue({ compatConfig: { MODE: 3 }, name: "PopupInner", inheritAttrs: !1, props: Bg, emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"], setup(t, e) { let { expose: n, attrs: i, slots: r } = e; const o = oe(), s = oe(), l = oe(), [a, c] = kQ(Rh(t, "stretch")), u = () => { t.stretch && c(t.getRootDomNode()) }, f = oe(!1); let h; Te(() => t.visible, C => { clearTimeout(h), C ? h = setTimeout(() => { f.value = t.visible }) : f.value = !1 }, { immediate: !0 }); const [d, p] = $Q(f, u), g = oe(), m = () => t.point ? t.point : t.getRootDomNode, v = () => { var C; (C = o.value) === null || C === void 0 || C.forceAlign() }, b = (C, O) => { var P; const M = t.getClassNameFromAlign(O), A = l.value; l.value !== M && (l.value = M), d.value === "align" && (A !== M ? Promise.resolve().then(() => { v() }) : p(() => { var B; (B = g.value) === null || B === void 0 || B.call(g) }), (P = t.onAlign) === null || P === void 0 || P.call(t, C, O)) }, x = E(() => { const C = typeof t.animation == "object" ? t.animation : PC(t); return ["onAfterEnter", "onAfterLeave"].forEach(O => { const P = C[O]; C[O] = M => { p(), d.value = "stable", P == null || P(M) } }), C }), w = () => new Promise(C => { g.value = C }); Te([x, d], () => { !x.value && d.value === "motion" && p() }, { immediate: !0 }), n({ forceAlign: v, getElement: () => s.value.$el || s.value }); const y = E(() => { var C; return !(!((C = t.align) === null || C === void 0) && C.points && (d.value === "align" || d.value === "stable")) }); return () => { var C; const { zIndex: O, align: P, prefixCls: M, destroyPopupOnHide: A, onMouseenter: B, onMouseleave: R, onTouchstart: X = () => { }, onMousedown: K } = t, _ = d.value, j = [S(S({}, a.value), { zIndex: O, opacity: _ === "motion" || _ === "stable" || !f.value ? null : 0, pointerEvents: !f.value && _ !== "stable" ? "none" : null }), i.style]; let W = Ft((C = r.default) === null || C === void 0 ? void 0 : C.call(r, { visible: t.visible })); W.length > 1 && (W = $("div", { class: `${M}-content` }, [W])); const G = ke(M, i.class, l.value, !t.arrow && `${M}-arrow-hidden`), ge = f.value || !t.visible ? eT(x.value.name, x.value) : {}; return $(os, ee(ee({ ref: s }, ge), {}, { onBeforeEnter: w }), { default: () => !A || t.visible ? Bp($(iW, { target: m(), key: "popup", ref: o, monitorWindowResize: !0, disabled: y.value, align: P, onAlign: b }, { default: () => $("div", { class: G, onMouseenter: B, onMouseleave: R, onMousedown: Um(K, ["capture"]), [xo ? "onTouchstartPassive" : "onTouchstart"]: Um(X, ["capture"]), style: j }, [W]) }), [[g1, f.value]]) : null }) } } }), sW = ue({ compatConfig: { MODE: 3 }, name: "Popup", inheritAttrs: !1, props: wQ, setup(t, e) { let { attrs: n, slots: i, expose: r } = e; const o = oe(!1), s = oe(!1), l = oe(), a = oe(); return Te([() => t.visible, () => t.mobile], () => { o.value = t.visible, t.visible && t.mobile && (s.value = !0) }, { immediate: !0, flush: "post" }), r({ forceAlign: () => { var c; (c = l.value) === null || c === void 0 || c.forceAlign() }, getElement: () => { var c; return (c = l.value) === null || c === void 0 ? void 0 : c.getElement() } }), () => { const c = S(S(S({}, t), n), { visible: o.value }), u = s.value ? $(CQ, ee(ee({}, c), {}, { mobile: t.mobile, ref: l }), { default: i.default }) : $(oW, ee(ee({}, c), {}, { ref: l }), { default: i.default }); return $("div", { ref: a }, [$(AC, c, null), u]) } } }); function lW(t, e, n) { return n ? t[0] === e[0] : t[0] === e[0] && t[1] === e[1] } function ab(t, e, n) { const i = t[e] || {}; return S(S({}, i), n) } function aW(t, e, n, i) { const { points: r } = n, o = Object.keys(t); for (let s = 0; s < o.length; s += 1) { const l = o[s]; if (lW(t[l].points, r, i)) return `${e}-placement-${l}` } return "" } const cW = { methods: { setState() { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0, n = typeof t == "function" ? t(this.$data, this.$props) : t; if (this.getDerivedStateFromProps) { const i = this.getDerivedStateFromProps(HB(this), S(S({}, this.$data), n)); if (i === null) return; n = S(S({}, n), i || {}) } S(this.$data, n), this._.isMounted && this.$forceUpdate(), ri(() => { e && e() }) }, __emit() { const t = [].slice.call(arguments, 0); let e = t[0]; e = `on${e[0].toUpperCase()}${e.substring(1)}`; const n = this.$props[e] || this.$attrs[e]; if (t.length && n) if (Array.isArray(n)) for (let i = 0, r = n.length; i < r; i++)n[i](...t.slice(1)); else n(...t.slice(1)) } } }, tT = Symbol("PortalContextKey"), nT = function (t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { inTriggerContext: !0 }; en(tT, { inTriggerContext: e.inTriggerContext, shouldRender: E(() => { const { sPopupVisible: n, popupRef: i, forceRender: r, autoDestroy: o } = t || {}; let s = !1; return (n || i || r) && (s = !0), !n && o && (s = !1), s }) }) }, uW = () => { nT({}, { inTriggerContext: !1 }); const t = Ke(tT, { shouldRender: E(() => !1), inTriggerContext: !1 }); return { shouldRender: E(() => t.shouldRender.value || t.inTriggerContext === !1) } }, fW = ue({ compatConfig: { MODE: 3 }, name: "Portal", inheritAttrs: !1, props: { getContainer: ne.func.isRequired, didUpdate: Function }, setup(t, e) { let { slots: n } = e, i = !0, r; const { shouldRender: o } = uW(); function s() { o.value && (r = t.getContainer()) } VO(() => { i = !1, s() }), vt(() => { r || s() }); const l = Te(o, () => { o.value && !r && (r = t.getContainer()), r && l() }); return is(() => { ri(() => { var a; o.value && ((a = t.didUpdate) === null || a === void 0 || a.call(t, t)) }) }), () => { var a; return o.value ? i ? (a = n.default) === null || a === void 0 ? void 0 : a.call(n) : r ? $(LO, { to: r }, n) : null : null } } }); let Sh; function hW(t) { if (typeof document > "u") return 0; if (t || Sh === void 0) { const e = document.createElement("div"); e.style.width = "100%", e.style.height = "200px"; const n = document.createElement("div"), i = n.style; i.position = "absolute", i.top = "0", i.left = "0", i.pointerEvents = "none", i.visibility = "hidden", i.width = "200px", i.height = "150px", i.overflow = "hidden", n.appendChild(e), document.body.appendChild(n); const r = e.offsetWidth; n.style.overflow = "scroll"; let o = e.offsetWidth; r === o && (o = n.clientWidth), document.body.removeChild(n), Sh = r - o } return Sh } const dW = `vc-util-locker-${Date.now()}`; let cb = 0; function pW() { return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth } function gW(t) {
        const e = E(() => !!t && !!t.value); cb += 1; const n = `${dW}_${cb}`; hn(i => {
            if (si()) {
                if (e.value) {
                    const r = hW(), o = pW(); ou(`
html body {
  overflow-y: hidden;
  ${o ? `width: calc(100% - ${r}px);` : ""}
}`, n)
                } else ru(n); i(() => { ru(n) })
            }
        }, { flush: "post" })
    } let $r = 0; const mc = si(), ub = t => { if (!mc) return null; if (t) { if (typeof t == "string") return document.querySelectorAll(t)[0]; if (typeof t == "function") return t(); if (typeof t == "object" && t instanceof window.HTMLElement) return t } return document.body }, mW = ue({ compatConfig: { MODE: 3 }, name: "PortalWrapper", inheritAttrs: !1, props: { wrapperClassName: String, forceRender: { type: Boolean, default: void 0 }, getContainer: ne.any, visible: { type: Boolean, default: void 0 }, autoLock: Nr(), didUpdate: Function }, setup(t, e) { let { slots: n } = e; const i = oe(), r = oe(), o = oe(), s = oe(1), l = si() && document.createElement("div"), a = () => { var d, p; i.value === l && ((p = (d = i.value) === null || d === void 0 ? void 0 : d.parentNode) === null || p === void 0 || p.removeChild(i.value)), i.value = null }; let c = null; const u = function () { return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || i.value && !i.value.parentNode ? (c = ub(t.getContainer), c ? (c.appendChild(i.value), !0) : !1) : !0 }, f = () => mc ? (i.value || (i.value = l, u(!0)), h(), i.value) : null, h = () => { const { wrapperClassName: d } = t; i.value && d && d !== i.value.className && (i.value.className = d) }; return is(() => { h(), u() }), gW(E(() => t.autoLock && t.visible && si() && (i.value === document.body || i.value === l))), vt(() => { let d = !1; Te([() => t.visible, () => t.getContainer], (p, g) => { let [m, v] = p, [b, x] = g; mc && (c = ub(t.getContainer), c === document.body && (m && !b ? $r += 1 : d && ($r -= 1))), d && (typeof v == "function" && typeof x == "function" ? v.toString() !== x.toString() : v !== x) && a(), d = !0 }, { immediate: !0, flush: "post" }), ri(() => { u() || (o.value = nt(() => { s.value += 1 })) }) }), At(() => { const { visible: d } = t; mc && c === document.body && ($r = d && $r ? $r - 1 : $r), a(), nt.cancel(o.value) }), () => { const { forceRender: d, visible: p } = t; let g = null; const m = { getOpenCount: () => $r, getContainer: f }; return s.value && (d || p || r.value) && (g = $(fW, { getContainer: f, ref: r, didUpdate: t.didUpdate }, { default: () => { var v; return (v = n.default) === null || v === void 0 ? void 0 : v.call(n, m) } })), g } } }), vW = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"], Xg = ue({ compatConfig: { MODE: 3 }, name: "Trigger", mixins: [cW], inheritAttrs: !1, props: SQ(), setup(t) { const e = E(() => { const { popupPlacement: r, popupAlign: o, builtinPlacements: s } = t; return r && s ? ab(s, r, o) : o }), n = oe(null), i = r => { n.value = r }; return { vcTriggerContext: Ke("vcTriggerContext", {}), popupRef: n, setPopupRef: i, triggerRef: oe(null), align: e, focusTime: null, clickOutsideHandler: null, contextmenuOutsideHandler1: null, contextmenuOutsideHandler2: null, touchOutsideHandler: null, attachId: null, delayTimer: null, hasPopupMouseDown: !1, preClickTime: null, preTouchTime: null, mouseDownTimeout: null, childOriginEvents: {} } }, data() { const t = this.$props; let e; return this.popupVisible !== void 0 ? e = !!t.popupVisible : e = !!t.defaultPopupVisible, vW.forEach(n => { this[`fire${n}`] = i => { this.fireEvents(n, i) } }), { prevPopupVisible: e, sPopupVisible: e, point: null } }, watch: { popupVisible(t) { t !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = t) } }, created() { en("vcTriggerContext", { onPopupMouseDown: this.onPopupMouseDown, onPopupMouseenter: this.onPopupMouseenter, onPopupMouseleave: this.onPopupMouseleave }), nT(this) }, deactivated() { this.setPopupVisible(!1) }, mounted() { this.$nextTick(() => { this.updatedCal() }) }, updated() { this.$nextTick(() => { this.updatedCal() }) }, beforeUnmount() { this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), nt.cancel(this.attachId) }, methods: { updatedCal() { const t = this.$props; if (this.$data.sPopupVisible) { let n; !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (n = t.getDocument(this.getRootDomNode()), this.clickOutsideHandler = Qs(n, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (n = n || t.getDocument(this.getRootDomNode()), this.touchOutsideHandler = Qs(n, "touchstart", this.onDocumentClick, xo ? { passive: !1 } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (n = n || t.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 = Qs(n, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = Qs(window, "blur", this.onContextmenuClose)) } else this.clearOutsideHandler() }, onMouseenter(t) { const { mouseEnterDelay: e } = this.$props; this.fireEvents("onMouseenter", t), this.delaySetPopupVisible(!0, e, e ? null : t) }, onMouseMove(t) { this.fireEvents("onMousemove", t), this.setPoint(t) }, onMouseleave(t) { this.fireEvents("onMouseleave", t), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay) }, onPopupMouseenter() { const { vcTriggerContext: t = {} } = this; t.onPopupMouseenter && t.onPopupMouseenter(), this.clearDelayTimer() }, onPopupMouseleave(t) { var e; if (t && t.relatedTarget && !t.relatedTarget.setTimeout && _r((e = this.popupRef) === null || e === void 0 ? void 0 : e.getElement(), t.relatedTarget)) return; this.isMouseLeaveToHide() && this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay); const { vcTriggerContext: n = {} } = this; n.onPopupMouseleave && n.onPopupMouseleave(t) }, onFocus(t) { this.fireEvents("onFocus", t), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay)) }, onMousedown(t) { this.fireEvents("onMousedown", t), this.preClickTime = Date.now() }, onTouchstart(t) { this.fireEvents("onTouchstart", t), this.preTouchTime = Date.now() }, onBlur(t) { _r(t.target, t.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", t), this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay)) }, onContextmenu(t) { t.preventDefault(), this.fireEvents("onContextmenu", t), this.setPopupVisible(!0, t) }, onContextmenuClose() { this.isContextmenuToShow() && this.close() }, onClick(t) { if (this.fireEvents("onClick", t), this.focusTime) { let n; if (this.preClickTime && this.preTouchTime ? n = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? n = this.preClickTime : this.preTouchTime && (n = this.preTouchTime), Math.abs(n - this.focusTime) < 20) return; this.focusTime = 0 } this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && t && t.preventDefault && t.preventDefault(), t && t.domEvent && t.domEvent.preventDefault(); const e = !this.$data.sPopupVisible; (this.isClickToHide() && !e || e && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, t) }, onPopupMouseDown() { const { vcTriggerContext: t = {} } = this; this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout(() => { this.hasPopupMouseDown = !1 }, 0), t.onPopupMouseDown && t.onPopupMouseDown(...arguments) }, onDocumentClick(t) { if (this.$props.mask && !this.$props.maskClosable) return; const e = t.target, n = this.getRootDomNode(), i = this.getPopupDomNode(); (!_r(n, e) || this.isContextMenuOnly()) && !_r(i, e) && !this.hasPopupMouseDown && this.delaySetPopupVisible(!1, .1) }, getPopupDomNode() { var t; return ((t = this.popupRef) === null || t === void 0 ? void 0 : t.getElement()) || null }, getRootDomNode() { var t, e, n, i; const { getTriggerDOMNode: r } = this.$props; if (r) { const o = ((e = (t = this.triggerRef) === null || t === void 0 ? void 0 : t.$el) === null || e === void 0 ? void 0 : e.nodeName) === "#comment" ? null : Ji(this.triggerRef); return Ji(r(o)) } try { const o = ((i = (n = this.triggerRef) === null || n === void 0 ? void 0 : n.$el) === null || i === void 0 ? void 0 : i.nodeName) === "#comment" ? null : Ji(this.triggerRef); if (o) return o } catch { } return Ji(this) }, handleGetPopupClassFromAlign(t) { const e = [], n = this.$props, { popupPlacement: i, builtinPlacements: r, prefixCls: o, alignPoint: s, getPopupClassNameFromAlign: l } = n; return i && r && e.push(aW(r, o, t, s)), l && e.push(l(t)), e.join(" ") }, getPopupAlign() { const t = this.$props, { popupPlacement: e, popupAlign: n, builtinPlacements: i } = t; return e && i ? ab(i, e, n) : n }, getComponent() { const t = {}; this.isMouseEnterToShow() && (t.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() && (t.onMouseleave = this.onPopupMouseleave), t.onMousedown = this.onPopupMouseDown, t[xo ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown; const { handleGetPopupClassFromAlign: e, getRootDomNode: n, $attrs: i } = this, { prefixCls: r, destroyPopupOnHide: o, popupClassName: s, popupAnimation: l, popupTransitionName: a, popupStyle: c, mask: u, maskAnimation: f, maskTransitionName: h, zIndex: d, stretch: p, alignPoint: g, mobile: m, arrow: v, forceRender: b } = this.$props, { sPopupVisible: x, point: w } = this.$data, y = S(S({ prefixCls: r, arrow: v, destroyPopupOnHide: o, visible: x, point: g ? w : null, align: this.align, animation: l, getClassNameFromAlign: e, stretch: p, getRootDomNode: n, mask: u, zIndex: d, transitionName: a, maskAnimation: f, maskTransitionName: h, class: s, style: c, onAlign: i.onPopupAlign || kC }, t), { ref: this.setPopupRef, mobile: m, forceRender: b }); return $(sW, y, { default: this.$slots.popup || (() => FB(this, "popup")) }) }, attachParent(t) { nt.cancel(this.attachId); const { getPopupContainer: e, getDocument: n } = this.$props, i = this.getRootDomNode(); let r; e ? (i || e.length === 0) && (r = e(i)) : r = n(this.getRootDomNode()).body, r ? r.appendChild(t) : this.attachId = nt(() => { this.attachParent(t) }) }, getContainer() { const { $props: t } = this, { getDocument: e } = t, n = e(this.getRootDomNode()).createElement("div"); return n.style.position = "absolute", n.style.top = "0", n.style.left = "0", n.style.width = "100%", this.attachParent(n), n }, setPopupVisible(t, e) { const { alignPoint: n, sPopupVisible: i, onPopupVisibleChange: r } = this; this.clearDelayTimer(), i !== t && (zB(this, "popupVisible") || this.setState({ sPopupVisible: t, prevPopupVisible: i }), r && r(t)), n && e && t && this.setPoint(e) }, setPoint(t) { const { alignPoint: e } = this.$props; !e || !t || this.setState({ point: { pageX: t.pageX, pageY: t.pageY } }) }, handlePortalUpdate() { this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible) }, delaySetPopupVisible(t, e, n) { const i = e * 1e3; if (this.clearDelayTimer(), i) { const r = n ? { pageX: n.pageX, pageY: n.pageY } : null; this.delayTimer = setTimeout(() => { this.setPopupVisible(t, r), this.clearDelayTimer() }, i) } else this.setPopupVisible(t, n) }, clearDelayTimer() { this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null) }, clearOutsideHandler() { this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null) }, createTwoChains(t) { let e = () => { }; const n = Kv(this); return this.childOriginEvents[t] && n[t] ? this[`fire${t}`] : (e = this.childOriginEvents[t] || n[t] || e, e) }, isClickToShow() { const { action: t, showAction: e } = this.$props; return t.indexOf("click") !== -1 || e.indexOf("click") !== -1 }, isContextMenuOnly() { const { action: t } = this.$props; return t === "contextmenu" || t.length === 1 && t[0] === "contextmenu" }, isContextmenuToShow() { const { action: t, showAction: e } = this.$props; return t.indexOf("contextmenu") !== -1 || e.indexOf("contextmenu") !== -1 }, isClickToHide() { const { action: t, hideAction: e } = this.$props; return t.indexOf("click") !== -1 || e.indexOf("click") !== -1 }, isMouseEnterToShow() { const { action: t, showAction: e } = this.$props; return t.indexOf("hover") !== -1 || e.indexOf("mouseenter") !== -1 }, isMouseLeaveToHide() { const { action: t, hideAction: e } = this.$props; return t.indexOf("hover") !== -1 || e.indexOf("mouseleave") !== -1 }, isFocusToShow() { const { action: t, showAction: e } = this.$props; return t.indexOf("focus") !== -1 || e.indexOf("focus") !== -1 }, isBlurToHide() { const { action: t, hideAction: e } = this.$props; return t.indexOf("focus") !== -1 || e.indexOf("blur") !== -1 }, forcePopupAlign() { var t; this.$data.sPopupVisible && ((t = this.popupRef) === null || t === void 0 || t.forceAlign()) }, fireEvents(t, e) { this.childOriginEvents[t] && this.childOriginEvents[t](e); const n = this.$props[t] || this.$attrs[t]; n && n(e) }, close() { this.setPopupVisible(!1) } }, render() { const { $attrs: t } = this, e = us(WB(this)), { alignPoint: n, getPopupContainer: i } = this.$props, r = e[0]; this.childOriginEvents = Kv(r); const o = { key: "trigger" }; this.isContextmenuToShow() ? o.onContextmenu = this.onContextmenu : o.onContextmenu = this.createTwoChains("onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (o.onClick = this.onClick, o.onMousedown = this.onMousedown, o[xo ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (o.onClick = this.createTwoChains("onClick"), o.onMousedown = this.createTwoChains("onMousedown"), o[xo ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (o.onMouseenter = this.onMouseenter, n && (o.onMousemove = this.onMouseMove)) : o.onMouseenter = this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? o.onMouseleave = this.onMouseleave : o.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ? (o.onFocus = this.onFocus, o.onBlur = this.onBlur) : (o.onFocus = this.createTwoChains("onFocus"), o.onBlur = c => { c && (!c.relatedTarget || !_r(c.target, c.relatedTarget)) && this.createTwoChains("onBlur")(c) }); const s = ke(r && r.props && r.props.class, t.class); s && (o.class = s); const l = ai(r, S(S({}, o), { ref: "triggerRef" }), !0, !0), a = $(mW, { key: "portal", getContainer: i && (() => i(this.getRootDomNode())), didUpdate: this.handlePortalUpdate, visible: this.$data.sPopupVisible }, { default: this.getComponent }); return $(et, null, [l, a]) } }), me = { MAC_ENTER: 3, BACKSPACE: 8, TAB: 9, NUM_CENTER: 12, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 44, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, QUESTION_MARK: 63, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, META: 91, WIN_KEY_RIGHT: 92, CONTEXT_MENU: 93, NUM_ZERO: 96, NUM_ONE: 97, NUM_TWO: 98, NUM_THREE: 99, NUM_FOUR: 100, NUM_FIVE: 101, NUM_SIX: 102, NUM_SEVEN: 103, NUM_EIGHT: 104, NUM_NINE: 105, NUM_MULTIPLY: 106, NUM_PLUS: 107, NUM_MINUS: 109, NUM_PERIOD: 110, NUM_DIVISION: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, NUMLOCK: 144, SEMICOLON: 186, DASH: 189, EQUALS: 187, COMMA: 188, PERIOD: 190, SLASH: 191, APOSTROPHE: 192, SINGLE_QUOTE: 222, OPEN_SQUARE_BRACKET: 219, BACKSLASH: 220, CLOSE_SQUARE_BRACKET: 221, WIN_KEY: 224, MAC_FF_META: 224, WIN_IME: 229, isTextModifyingKeyEvent: function (e) { const { keyCode: n } = e; if (e.altKey && !e.ctrlKey || e.metaKey || n >= me.F1 && n <= me.F12) return !1; switch (n) { case me.ALT: case me.CAPS_LOCK: case me.CONTEXT_MENU: case me.CTRL: case me.DOWN: case me.END: case me.ESC: case me.HOME: case me.INSERT: case me.LEFT: case me.MAC_FF_META: case me.META: case me.NUMLOCK: case me.NUM_CENTER: case me.PAGE_DOWN: case me.PAGE_UP: case me.PAUSE: case me.PRINT_SCREEN: case me.RIGHT: case me.SHIFT: case me.UP: case me.WIN_KEY: case me.WIN_KEY_RIGHT: return !1; default: return !0 } }, isCharacterKey: function (e) { if (e >= me.ZERO && e <= me.NINE || e >= me.NUM_ZERO && e <= me.NUM_MULTIPLY || e >= me.A && e <= me.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && e === 0) return !0; switch (e) { case me.SPACE: case me.QUESTION_MARK: case me.NUM_PLUS: case me.NUM_MINUS: case me.NUM_PERIOD: case me.NUM_DIVISION: case me.SEMICOLON: case me.DASH: case me.EQUALS: case me.COMMA: case me.PERIOD: case me.SLASH: case me.APOSTROPHE: case me.SINGLE_QUOTE: case me.OPEN_SQUARE_BRACKET: case me.BACKSLASH: case me.CLOSE_SQUARE_BRACKET: return !0; default: return !1 } } }, Mn = me, iT = Symbol("OverflowContextProviderKey"), cp = ue({ compatConfig: { MODE: 3 }, name: "OverflowContextProvider", inheritAttrs: !1, props: { value: { type: Object } }, setup(t, e) { let { slots: n } = e; return en(iT, E(() => t.value)), () => { var i; return (i = n.default) === null || i === void 0 ? void 0 : i.call(n) } } }), yW = () => Ke(iT, E(() => null)); var bW = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; const co = void 0, vc = ue({ compatConfig: { MODE: 3 }, name: "Item", props: { prefixCls: String, item: ne.any, renderItem: Function, responsive: Boolean, itemKey: { type: [String, Number] }, registerSize: Function, display: Boolean, order: Number, component: ne.any, invalidate: Boolean }, setup(t, e) { let { slots: n, expose: i } = e; const r = E(() => t.responsive && !t.display), o = he(); i({ itemNodeRef: o }); function s(l) { t.registerSize(t.itemKey, l) } return Wl(() => { s(null) }), () => { var l; const { prefixCls: a, invalidate: c, item: u, renderItem: f, responsive: h, registerSize: d, itemKey: p, display: g, order: m, component: v = "div" } = t, b = bW(t, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]), x = (l = n.default) === null || l === void 0 ? void 0 : l.call(n), w = f && u !== co ? f(u) : x; let y; c || (y = { opacity: r.value ? 0 : 1, height: r.value ? 0 : co, overflowY: r.value ? "hidden" : co, order: h ? m : co, pointerEvents: r.value ? "none" : co, position: r.value ? "absolute" : co }); const C = {}; return r.value && (C["aria-hidden"] = !0), $(nu, { disabled: !h, onResize: O => { let { offsetWidth: P } = O; s(P) } }, { default: () => $(v, ee(ee(ee({ class: ke(!c && a), style: y }, C), b), {}, { ref: o }), { default: () => [w] }) }) } } }); var xh = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; const OW = ue({ compatConfig: { MODE: 3 }, name: "RawItem", inheritAttrs: !1, props: { component: ne.any, title: ne.any, id: String, onMouseenter: { type: Function }, onMouseleave: { type: Function }, onClick: { type: Function }, onKeydown: { type: Function }, onFocus: { type: Function }, role: String, tabindex: Number }, setup(t, e) { let { slots: n, attrs: i } = e; const r = yW(); return () => { var o; if (!r.value) { const { component: f = "div" } = t, h = xh(t, ["component"]); return $(f, ee(ee({}, h), i), { default: () => [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)] }) } const s = r.value, { className: l } = s, a = xh(s, ["className"]), { class: c } = i, u = xh(i, ["class"]); return $(cp, { value: null }, { default: () => [$(vc, ee(ee(ee({ class: ke(l, c) }, a), u), t), n)] }) } } }); var SW = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; const rT = "responsive", oT = "invalidate"; function xW(t) { return `+ ${t.length} ...` } const wW = () => ({ id: String, prefixCls: String, data: Array, itemKey: [String, Number, Function], itemWidth: { type: Number, default: 10 }, renderItem: Function, renderRawItem: Function, maxCount: [Number, String], renderRest: Function, renderRawRest: Function, suffix: ne.any, component: String, itemComponent: ne.any, onVisibleChange: Function, ssr: String, onMousedown: Function, role: String }), lf = ue({ name: "Overflow", inheritAttrs: !1, props: wW(), emits: ["visibleChange"], setup(t, e) { let { attrs: n, emit: i, slots: r } = e; const o = E(() => t.ssr === "full"), s = oe(null), l = E(() => s.value || 0), a = oe(new Map), c = oe(0), u = oe(0), f = oe(0), h = oe(null), d = oe(null), p = E(() => d.value === null && o.value ? Number.MAX_SAFE_INTEGER : d.value || 0), g = oe(!1), m = E(() => `${t.prefixCls}-item`), v = E(() => Math.max(c.value, u.value)), b = E(() => !!(t.data.length && t.maxCount === rT)), x = E(() => t.maxCount === oT), w = E(() => b.value || typeof t.maxCount == "number" && t.data.length > t.maxCount), y = E(() => { let _ = t.data; return b.value ? s.value === null && o.value ? _ = t.data : _ = t.data.slice(0, Math.min(t.data.length, l.value / t.itemWidth)) : typeof t.maxCount == "number" && (_ = t.data.slice(0, t.maxCount)), _ }), C = E(() => b.value ? t.data.slice(p.value + 1) : t.data.slice(y.value.length)), O = (_, j) => { var W; return typeof t.itemKey == "function" ? t.itemKey(_) : (W = t.itemKey && (_ == null ? void 0 : _[t.itemKey])) !== null && W !== void 0 ? W : j }, P = E(() => t.renderItem || (_ => _)), M = (_, j) => { d.value = _, j || (g.value = _ < t.data.length - 1, i("visibleChange", _)) }, A = (_, j) => { s.value = j.clientWidth }, B = (_, j) => { const W = new Map(a.value); j === null ? W.delete(_) : W.set(_, j), a.value = W }, R = (_, j) => { c.value = u.value, u.value = j }, X = (_, j) => { f.value = j }, K = _ => a.value.get(O(y.value[_], _)); return Te([l, a, u, f, () => t.itemKey, y], () => { if (l.value && v.value && y.value) { let _ = f.value; const j = y.value.length, W = j - 1; if (!j) { M(0), h.value = null; return } for (let G = 0; G < j; G += 1) { const ae = K(G); if (ae === void 0) { M(G - 1, !0); break } if (_ += ae, W === 0 && _ <= l.value || G === W - 1 && _ + K(W) <= l.value) { M(W), h.value = null; break } else if (_ + v.value > l.value) { M(G - 1), h.value = _ - ae - f.value + u.value; break } } t.suffix && K(0) + f.value > l.value && (h.value = null) } }), () => { const _ = g.value && !!C.value.length, { itemComponent: j, renderRawItem: W, renderRawRest: G, renderRest: ae, prefixCls: ge = "rc-overflow", suffix: J, component: ce = "div", id: Oe, onMousedown: Le } = t, { class: Qe, style: Ae } = n, U = SW(n, ["class", "style"]); let pe = {}; h.value !== null && b.value && (pe = { position: "absolute", left: `${h.value}px`, top: 0 }); const ve = { prefixCls: m.value, responsive: b.value, component: j, invalidate: x.value }, Pe = W ? (k, D) => { const V = O(k, D); return $(cp, { key: V, value: S(S({}, ve), { order: D, item: k, itemKey: V, registerSize: B, display: D <= p.value }) }, { default: () => [W(k, D)] }) } : (k, D) => { const V = O(k, D); return $(vc, ee(ee({}, ve), {}, { order: D, key: V, item: k, renderItem: P.value, itemKey: V, registerSize: B, display: D <= p.value }), null) }; let Ie = () => null; const Me = { order: _ ? p.value : Number.MAX_SAFE_INTEGER, className: `${m.value} ${m.value}-rest`, registerSize: R, display: _ }; if (G) G && (Ie = () => $(cp, { value: S(S({}, ve), Me) }, { default: () => [G(C.value)] })); else { const k = ae || xW; Ie = () => $(vc, ee(ee({}, ve), Me), { default: () => typeof k == "function" ? k(C.value) : k }) } const T = () => { var k; return $(ce, ee({ id: Oe, class: ke(!x.value && ge, Qe), style: Ae, onMousedown: Le, role: t.role }, U), { default: () => [y.value.map(Pe), w.value ? Ie() : null, J && $(vc, ee(ee({}, ve), {}, { order: p.value, class: `${m.value}-suffix`, registerSize: X, display: !0, style: pe }), { default: () => J }), (k = r.default) === null || k === void 0 ? void 0 : k.call(r)] }) }; return $(nu, { disabled: !b.value, onResize: A }, { default: T }) } } }); lf.Item = OW; lf.RESPONSIVE = rT; lf.INVALIDATE = oT; const il = lf, CW = () => { if (typeof navigator > "u" || typeof window > "u") return !1; const t = navigator.userAgent || navigator.vendor || window.opera; return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(t == null ? void 0 : t.substring(0, 4)) }; function fb(t, e) { const { defaultValue: n, value: i = he() } = e || {}; let r = typeof t == "function" ? t() : t; i.value !== void 0 && (r = gt(i)), n !== void 0 && (r = typeof n == "function" ? n() : n); const o = he(r), s = he(r); hn(() => { let a = i.value !== void 0 ? i.value : o.value; e.postState && (a = e.postState(a)), s.value = a }); function l(a) { const c = s.value; o.value = a, Re(s.value) !== a && e.onChange && e.onChange(a, c) } return Te(i, () => { o.value = i.value }), [s, l] } function Je(t) { const e = typeof t == "function" ? t() : t, n = he(e); function i(r) { n.value = r } return [n, i] } var TW = Symbol("iconContext"), sT = function () { return Ke(TW, { prefixCls: he("anticon"), rootClassName: he(""), csp: he() }) }; function Ug() { return !!(typeof window < "u" && window.document && window.document.createElement) } function $W(t, e) { return t && t.contains ? t.contains(e) : !1 } var hb = "data-vc-order", kW = "vc-icon-key", up = new Map; function lT() { var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = t.mark; return e ? e.startsWith("data-") ? e : "data-".concat(e) : kW } function Gg(t) { if (t.attachTo) return t.attachTo; var e = document.querySelector("head"); return e || document.body } function PW(t) { return t === "queue" ? "prependQueue" : t ? "prepend" : "append" } function aT(t) { return Array.from((up.get(t) || t).children).filter(function (e) { return e.tagName === "STYLE" }) } function cT(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (!Ug()) return null; var n = e.csp, i = e.prepend, r = document.createElement("style"); r.setAttribute(hb, PW(i)), n && n.nonce && (r.nonce = n.nonce), r.innerHTML = t; var o = Gg(e), s = o.firstChild; if (i) { if (i === "queue") { var l = aT(o).filter(function (a) { return ["prepend", "prependQueue"].includes(a.getAttribute(hb)) }); if (l.length) return o.insertBefore(r, l[l.length - 1].nextSibling), r } o.insertBefore(r, s) } else o.appendChild(r); return r } function AW(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = Gg(e); return aT(n).find(function (i) { return i.getAttribute(lT(e)) === t }) } function MW(t, e) { var n = up.get(t); if (!n || !$W(document, n)) { var i = cT("", e), r = i.parentNode; up.set(t, r), t.removeChild(i) } } function EW(t, e) { var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = Gg(n); MW(i, n); var r = AW(e, n); if (r) return n.csp && n.csp.nonce && r.nonce !== n.csp.nonce && (r.nonce = n.csp.nonce), r.innerHTML !== t && (r.innerHTML = t), r; var o = cT(t, n); return o.setAttribute(lT(n), e), o } function db(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { _W(t, r, n[r]) }) } return t } function _W(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function pb(t) { return typeof t == "object" && typeof t.name == "string" && typeof t.theme == "string" && (typeof t.icon == "object" || typeof t.icon == "function") } function fp(t, e, n) { return n ? Fr(t.tag, db({ key: e }, n, t.attrs), (t.children || []).map(function (i, r) { return fp(i, "".concat(e, "-").concat(t.tag, "-").concat(r)) })) : Fr(t.tag, db({ key: e }, t.attrs), (t.children || []).map(function (i, r) { return fp(i, "".concat(e, "-").concat(t.tag, "-").concat(r)) })) } function uT(t) { return Il(t)[0] } function fT(t) { return t ? Array.isArray(t) ? t : [t] : [] } var RW = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`; function hT(t) { return t && t.getRootNode && t.getRootNode() } function IW(t) { return Ug() ? hT(t) instanceof ShadowRoot : !1 } function DW(t) { return IW(t) ? hT(t) : null } var BW = function () { var e = sT(), n = e.prefixCls, i = e.csp, r = vr(), o = RW; n && (o = o.replace(/anticon/g, n.value)), ri(function () { if (Ug()) { var s = r.vnode.el, l = DW(s); EW(o, "@ant-design-vue-icons", { prepend: !0, csp: i.value, attachTo: l }) } }) }, LW = ["icon", "primaryColor", "secondaryColor"]; function QW(t, e) { if (t == null) return {}; var n = NW(t, e), i, r; if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(t); for (r = 0; r < o.length; r++)i = o[r], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]) } return n } function NW(t, e) { if (t == null) return {}; var n = {}, i = Object.keys(t), r, o; for (o = 0; o < i.length; o++)r = i[o], !(e.indexOf(r) >= 0) && (n[r] = t[r]); return n } function yc(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { zW(t, r, n[r]) }) } return t } function zW(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var rl = eo({ primaryColor: "#333", secondaryColor: "#E6E6E6", calculated: !1 }); function WW(t) { var e = t.primaryColor, n = t.secondaryColor; rl.primaryColor = e, rl.secondaryColor = n || uT(e), rl.calculated = !!n } function HW() { return yc({}, rl) } var hs = function (e, n) { var i = yc({}, e, n.attrs), r = i.icon, o = i.primaryColor, s = i.secondaryColor, l = QW(i, LW), a = rl; if (o && (a = { primaryColor: o, secondaryColor: s || uT(o) }), pb(r), !pb(r)) return null; var c = r; return c && typeof c.icon == "function" && (c = yc({}, c, { icon: c.icon(a.primaryColor, a.secondaryColor) })), fp(c.icon, "svg-".concat(c.name), yc({}, l, { "data-icon": c.name, width: "1em", height: "1em", fill: "currentColor", "aria-hidden": "true" })) }; hs.props = { icon: Object, primaryColor: String, secondaryColor: String, focusable: String }; hs.inheritAttrs = !1; hs.displayName = "IconBase"; hs.getTwoToneColors = HW; hs.setTwoToneColors = WW; const Kg = hs; function FW(t, e) { return XW(t) || VW(t, e) || qW(t, e) || jW() } function jW() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } function qW(t, e) { if (t) { if (typeof t == "string") return gb(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gb(t, e) } } function gb(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, i = new Array(e); n < e; n++)i[n] = t[n]; return i } function VW(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var i = [], r = !0, o = !1, s, l; try { for (n = n.call(t); !(r = (s = n.next()).done) && (i.push(s.value), !(e && i.length === e)); r = !0); } catch (a) { o = !0, l = a } finally { try { !r && n.return != null && n.return() } finally { if (o) throw l } } return i } } function XW(t) { if (Array.isArray(t)) return t } function dT(t) { var e = fT(t), n = FW(e, 2), i = n[0], r = n[1]; return Kg.setTwoToneColors({ primaryColor: i, secondaryColor: r }) } function UW() { var t = Kg.getTwoToneColors(); return t.calculated ? [t.primaryColor, t.secondaryColor] : t.primaryColor } var GW = ue({ name: "InsertStyles", setup: function () { return BW(), function () { return null } } }), KW = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"]; function YW(t, e) { return tH(t) || eH(t, e) || JW(t, e) || ZW() } function ZW() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } function JW(t, e) { if (t) { if (typeof t == "string") return mb(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mb(t, e) } } function mb(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, i = new Array(e); n < e; n++)i[n] = t[n]; return i } function eH(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var i = [], r = !0, o = !1, s, l; try { for (n = n.call(t); !(r = (s = n.next()).done) && (i.push(s.value), !(e && i.length === e)); r = !0); } catch (a) { o = !0, l = a } finally { try { !r && n.return != null && n.return() } finally { if (o) throw l } } return i } } function tH(t) { if (Array.isArray(t)) return t } function vb(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { zs(t, r, n[r]) }) } return t } function zs(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function nH(t, e) { if (t == null) return {}; var n = iH(t, e), i, r; if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(t); for (r = 0; r < o.length; r++)i = o[r], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]) } return n } function iH(t, e) { if (t == null) return {}; var n = {}, i = Object.keys(t), r, o; for (o = 0; o < i.length; o++)r = i[o], !(e.indexOf(r) >= 0) && (n[r] = t[r]); return n } dT(yL.primary); var ds = function (e, n) { var i, r = vb({}, e, n.attrs), o = r.class, s = r.icon, l = r.spin, a = r.rotate, c = r.tabindex, u = r.twoToneColor, f = r.onClick, h = nH(r, KW), d = sT(), p = d.prefixCls, g = d.rootClassName, m = (i = {}, zs(i, g.value, !!g.value), zs(i, p.value, !0), zs(i, "".concat(p.value, "-").concat(s.name), !!s.name), zs(i, "".concat(p.value, "-spin"), !!l || s.name === "loading"), i), v = c; v === void 0 && f && (v = -1); var b = a ? { msTransform: "rotate(".concat(a, "deg)"), transform: "rotate(".concat(a, "deg)") } : void 0, x = fT(u), w = YW(x, 2), y = w[0], C = w[1]; return $("span", vb({ role: "img", "aria-label": s.name }, h, { onClick: f, class: [m, o], tabindex: v }), [$(Kg, { icon: s, primaryColor: y, secondaryColor: C, style: b }, null), $(GW, null, null)]) }; ds.props = { spin: Boolean, rotate: Number, icon: Object, twoToneColor: [String, Array] }; ds.displayName = "AntdIcon"; ds.inheritAttrs = !1; ds.getTwoToneColor = UW; ds.setTwoToneColor = dT; const af = ds; var rH = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" }; const oH = rH; function yb(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { sH(t, r, n[r]) }) } return t } function sH(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var Yg = function (e, n) { var i = yb({}, e, n.attrs); return $(af, yb({}, i, { icon: oH }), null) }; Yg.displayName = "LoadingOutlined"; Yg.inheritAttrs = !1; const bb = Yg; var lH = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" }; const aH = lH; function Ob(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { cH(t, r, n[r]) }) } return t } function cH(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var Zg = function (e, n) { var i = Ob({}, e, n.attrs); return $(af, Ob({}, i, { icon: aH }), null) }; Zg.displayName = "CloseOutlined"; Zg.inheritAttrs = !1; const uH = Zg; function pT(t) { const e = Symbol("contextKey"); return { useProvide: (r, o) => { const s = eo({}); return en(e, s), hn(() => { S(s, r, o || {}) }), s }, useInject: () => Ke(e, t) || {} } } const fH = t => { const { componentCls: e } = t; return { [e]: { display: "inline-flex", "&-block": { display: "flex", width: "100%" }, "&-vertical": { flexDirection: "column" } } } }, hH = fH, dH = t => { const { componentCls: e } = t; return { [e]: { display: "inline-flex", "&-rtl": { direction: "rtl" }, "&-vertical": { flexDirection: "column" }, "&-align": { flexDirection: "column", "&-center": { alignItems: "center" }, "&-start": { alignItems: "flex-start" }, "&-end": { alignItems: "flex-end" }, "&-baseline": { alignItems: "baseline" } }, [`${e}-item`]: { "&:empty": { display: "none" } } } } }, pH = zn("Space", t => [dH(t), hH(t)]); var gH = "[object Symbol]"; function Jg(t) { return typeof t == "symbol" || Zr(t) && io(t) == gH } function mH(t, e) { for (var n = -1, i = t == null ? 0 : t.length, r = Array(i); ++n < i;)r[n] = e(t[n], n, t); return r } var vH = 1 / 0, Sb = ci ? ci.prototype : void 0, xb = Sb ? Sb.toString : void 0; function gT(t) { if (typeof t == "string") return t; if (ui(t)) return mH(t, gT) + ""; if (Jg(t)) return xb ? xb.call(t) : ""; var e = t + ""; return e == "0" && 1 / t == -vH ? "-0" : e } function yH(t) { return t } function bH(t, e, n) { switch (n.length) { case 0: return t.call(e); case 1: return t.call(e, n[0]); case 2: return t.call(e, n[0], n[1]); case 3: return t.call(e, n[0], n[1], n[2]) }return t.apply(e, n) } function OH() { } var SH = 800, xH = 16, wH = Date.now; function CH(t) { var e = 0, n = 0; return function () { var i = wH(), r = xH - (i - n); if (n = i, r > 0) { if (++e >= SH) return arguments[0] } else e = 0; return t.apply(void 0, arguments) } } function TH(t) { return function () { return t } } var $H = function () { try { var t = oo(Object, "defineProperty"); return t({}, "", {}), t } catch { } }(); const hu = $H; var kH = hu ? function (t, e) { return hu(t, "toString", { configurable: !0, enumerable: !1, value: TH(e), writable: !0 }) } : yH; const PH = kH; var AH = CH(PH); const MH = AH; function EH(t, e, n, i) { for (var r = t.length, o = n + (i ? 1 : -1); i ? o-- : ++o < r;)if (e(t[o], o, t)) return o; return -1 } function _H(t) { return t !== t } function RH(t, e, n) { for (var i = n - 1, r = t.length; ++i < r;)if (t[i] === e) return i; return -1 } function IH(t, e, n) { return e === e ? RH(t, e, n) : EH(t, _H, n) } function DH(t, e) { var n = t == null ? 0 : t.length; return !!n && IH(t, e, 0) > -1 } function BH(t, e, n) { e == "__proto__" && hu ? hu(t, e, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : t[e] = n } var LH = Object.prototype, QH = LH.hasOwnProperty; function NH(t, e, n) { var i = t[e]; (!(QH.call(t, e) && Hg(i, n)) || n === void 0 && !(e in t)) && BH(t, e, n) } var wb = Math.max; function zH(t, e, n) { return e = wb(e === void 0 ? t.length - 1 : e, 0), function () { for (var i = arguments, r = -1, o = wb(i.length - e, 0), s = Array(o); ++r < o;)s[r] = i[e + r]; r = -1; for (var l = Array(e + 1); ++r < e;)l[r] = i[r]; return l[e] = n(s), bH(t, this, l) } } var WH = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, HH = /^\w*$/; function FH(t, e) { if (ui(t)) return !1; var n = typeof t; return n == "number" || n == "symbol" || n == "boolean" || t == null || Jg(t) ? !0 : HH.test(t) || !WH.test(t) || e != null && t in Object(e) } var jH = "Expected a function"; function em(t, e) { if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(jH); var n = function () { var i = arguments, r = e ? e.apply(this, i) : i[0], o = n.cache; if (o.has(r)) return o.get(r); var s = t.apply(this, i); return n.cache = o.set(r, s) || o, s }; return n.cache = new (em.Cache || Li), n } em.Cache = Li; var qH = 500; function VH(t) { var e = em(t, function (i) { return n.size === qH && n.clear(), i }), n = e.cache; return e } var XH = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, UH = /\\(\\)?/g, GH = VH(function (t) { var e = []; return t.charCodeAt(0) === 46 && e.push(""), t.replace(XH, function (n, i, r, o) { e.push(r ? o.replace(UH, "$1") : i || n) }), e }); const KH = GH; function YH(t) { return t == null ? "" : gT(t) } function cf(t, e) { return ui(t) ? t : FH(t, e) ? [t] : KH(YH(t)) } var ZH = 1 / 0; function tm(t) { if (typeof t == "string" || Jg(t)) return t; var e = t + ""; return e == "0" && 1 / t == -ZH ? "-0" : e } function JH(t, e) { e = cf(e, t); for (var n = 0, i = e.length; t != null && n < i;)t = t[tm(e[n++])]; return n && n == i ? t : void 0 } var Cb = ci ? ci.isConcatSpreadable : void 0; function eF(t) { return ui(t) || sf(t) || !!(Cb && t && t[Cb]) } function mT(t, e, n, i, r) { var o = -1, s = t.length; for (n || (n = eF), r || (r = []); ++o < s;) { var l = t[o]; e > 0 && n(l) ? e > 1 ? mT(l, e - 1, n, i, r) : qC(r, l) : i || (r[r.length] = l) } return r } function tF(t) { var e = t == null ? 0 : t.length; return e ? mT(t, 1) : [] } function nF(t) { return MH(zH(t, void 0, tF), t + "") } var iF = KC(Object.getPrototypeOf, Object); const rF = iF; var oF = "[object Object]", sF = Function.prototype, lF = Object.prototype, vT = sF.toString, aF = lF.hasOwnProperty, cF = vT.call(Object); function uF(t) { if (!Zr(t) || io(t) != oF) return !1; var e = rF(t); if (e === null) return !0; var n = aF.call(e, "constructor") && e.constructor; return typeof n == "function" && n instanceof n && vT.call(n) == cF } function fF(t, e) { return t != null && e in Object(t) } function hF(t, e, n) { e = cf(e, t); for (var i = -1, r = e.length, o = !1; ++i < r;) { var s = tm(e[i]); if (!(o = t != null && n(t, s))) break; t = t[s] } return o || ++i != r ? o : (r = t == null ? 0 : t.length, !!r && qg(r) && jg(s, r) && (ui(t) || sf(t))) } function dF(t, e) { return t != null && hF(t, e, fF) } function pF(t, e, n) { for (var i = -1, r = t == null ? 0 : t.length; ++i < r;)if (n(e, t[i])) return !0; return !1 } var gF = "[object Map]", mF = "[object Set]", vF = Object.prototype, yF = vF.hasOwnProperty; function yT(t) { if (t == null) return !0; if (ZC(t) && (ui(t) || typeof t == "string" || typeof t.splice == "function" || fu(t) || Vg(t) || sf(t))) return !t.length; var e = ap(t); if (e == gF || e == mF) return !t.size; if (GC(t)) return !YC(t).length; for (var n in t) if (yF.call(t, n)) return !1; return !0 } function bF(t, e, n, i) { if (!uu(t)) return t; e = cf(e, t); for (var r = -1, o = e.length, s = o - 1, l = t; l != null && ++r < o;) { var a = tm(e[r]), c = n; if (a === "__proto__" || a === "constructor" || a === "prototype") return t; if (r != s) { var u = l[a]; c = i ? i(u, a, l) : void 0, c === void 0 && (c = uu(u) ? u : jg(e[r + 1]) ? [] : {}) } NH(l, a, c), l = l[a] } return t } function OF(t, e, n) { for (var i = -1, r = e.length, o = {}; ++i < r;) { var s = e[i], l = JH(t, s); n(l, s) && bF(o, cf(s, t), l) } return o } function SF(t, e) { return OF(t, e, function (n, i) { return dF(t, i) }) } var xF = nF(function (t, e) { return t == null ? {} : SF(t, e) }); const bT = xF; var wF = 1 / 0, CF = Lo && 1 / Fg(new Lo([, -0]))[1] == wF ? function (t) { return new Lo(t) } : OH; const TF = CF; var $F = 200; function kF(t, e, n) { var i = -1, r = DH, o = t.length, s = !0, l = [], a = l; if (n) s = !1, r = pF; else if (o >= $F) { var c = e ? null : TF(t); if (c) return Fg(c); s = !1, r = FC, a = new Nl } else a = e ? [] : l; e: for (; ++i < o;) { var u = t[i], f = e ? e(u) : u; if (u = n || u !== 0 ? u : 0, s && f === f) { for (var h = a.length; h--;)if (a[h] === f) continue e; e && a.push(f), l.push(u) } else r(a, f, n) || (a !== l && a.push(f), l.push(u)) } return l } function wh(t) { return t && t.length ? kF(t) : [] } const PF = () => ({ compactSize: String, compactDirection: ne.oneOf(iu("horizontal", "vertical")).def("horizontal"), isFirstItem: Nr(), isLastItem: Nr() }), nm = pT(null), AF = (t, e) => { const n = nm.useInject(), i = E(() => { if (!n || yT(n)) return ""; const { compactDirection: r, isFirstItem: o, isLastItem: s } = n, l = r === "vertical" ? "-vertical-" : "-"; return ke({ [`${t.value}-compact${l}item`]: !0, [`${t.value}-compact${l}first-item`]: o, [`${t.value}-compact${l}last-item`]: s, [`${t.value}-compact${l}item-rtl`]: e.value === "rtl" }) }); return { compactSize: E(() => n == null ? void 0 : n.compactSize), compactDirection: E(() => n == null ? void 0 : n.compactDirection), compactItemClassnames: i } }, MF = () => ({ prefixCls: String, size: { type: String }, direction: ne.oneOf(iu("horizontal", "vertical")).def("horizontal"), align: ne.oneOf(iu("start", "end", "center", "baseline")), block: { type: Boolean, default: void 0 } }), EF = ue({ name: "CompactItem", props: PF(), setup(t, e) { let { slots: n } = e; return nm.useProvide(t), () => { var i; return (i = n.default) === null || i === void 0 ? void 0 : i.call(n) } } }); ue({ name: "ASpaceCompact", inheritAttrs: !1, props: MF(), setup(t, e) { let { attrs: n, slots: i } = e; const { prefixCls: r, direction: o } = dt("space-compact", t), s = nm.useInject(), [l, a] = pH(r), c = E(() => ke(r.value, a.value, { [`${r.value}-rtl`]: o.value === "rtl", [`${r.value}-block`]: t.block, [`${r.value}-vertical`]: t.direction === "vertical" })); return () => { var u; const f = Ft(((u = i.default) === null || u === void 0 ? void 0 : u.call(i)) || []); return f.length === 0 ? null : l($("div", ee(ee({}, n), {}, { class: [c.value, n.class] }), [f.map((h, d) => { var p; const g = h && h.key || `${r.value}-item-${d}`, m = !s || yT(s); return $(EF, { key: g, compactSize: (p = t.size) !== null && p !== void 0 ? p : "middle", compactDirection: t.direction, isFirstItem: d === 0 && (m || (s == null ? void 0 : s.isFirstItem)), isLastItem: d === f.length - 1 && (m || (s == null ? void 0 : s.isLastItem)) }, { default: () => [h] }) })])) } } }); const _F = t => ({ animationDuration: t, animationFillMode: "both" }), RF = t => ({ animationDuration: t, animationFillMode: "both" }), OT = function (t, e, n, i) {
        const o = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : ""; return {
            [`
      ${o}${t}-enter,
      ${o}${t}-appear
    `]: S(S({}, _F(i)), { animationPlayState: "paused" }), [`${o}${t}-leave`]: S(S({}, RF(i)), { animationPlayState: "paused" }), [`
      ${o}${t}-enter${t}-enter-active,
      ${o}${t}-appear${t}-appear-active
    `]: { animationName: e, animationPlayState: "running" }, [`${o}${t}-leave${t}-leave-active`]: { animationName: n, animationPlayState: "running", pointerEvents: "none" }
        }
    }, IF = new rt("antSlideUpIn", { "0%": { transform: "scaleY(0.8)", transformOrigin: "0% 0%", opacity: 0 }, "100%": { transform: "scaleY(1)", transformOrigin: "0% 0%", opacity: 1 } }), DF = new rt("antSlideUpOut", { "0%": { transform: "scaleY(1)", transformOrigin: "0% 0%", opacity: 1 }, "100%": { transform: "scaleY(0.8)", transformOrigin: "0% 0%", opacity: 0 } }), BF = new rt("antSlideDownIn", { "0%": { transform: "scaleY(0.8)", transformOrigin: "100% 100%", opacity: 0 }, "100%": { transform: "scaleY(1)", transformOrigin: "100% 100%", opacity: 1 } }), LF = new rt("antSlideDownOut", { "0%": { transform: "scaleY(1)", transformOrigin: "100% 100%", opacity: 1 }, "100%": { transform: "scaleY(0.8)", transformOrigin: "100% 100%", opacity: 0 } }), QF = new rt("antSlideLeftIn", { "0%": { transform: "scaleX(0.8)", transformOrigin: "0% 0%", opacity: 0 }, "100%": { transform: "scaleX(1)", transformOrigin: "0% 0%", opacity: 1 } }), NF = new rt("antSlideLeftOut", { "0%": { transform: "scaleX(1)", transformOrigin: "0% 0%", opacity: 1 }, "100%": { transform: "scaleX(0.8)", transformOrigin: "0% 0%", opacity: 0 } }), zF = new rt("antSlideRightIn", { "0%": { transform: "scaleX(0.8)", transformOrigin: "100% 0%", opacity: 0 }, "100%": { transform: "scaleX(1)", transformOrigin: "100% 0%", opacity: 1 } }), WF = new rt("antSlideRightOut", { "0%": { transform: "scaleX(1)", transformOrigin: "100% 0%", opacity: 1 }, "100%": { transform: "scaleX(0.8)", transformOrigin: "100% 0%", opacity: 0 } }), HF = { "slide-up": { inKeyframes: IF, outKeyframes: DF }, "slide-down": { inKeyframes: BF, outKeyframes: LF }, "slide-left": { inKeyframes: QF, outKeyframes: NF }, "slide-right": { inKeyframes: zF, outKeyframes: WF } }, du = (t, e) => {
        const { antCls: n } = t, i = `${n}-${e}`, { inKeyframes: r, outKeyframes: o } = HF[e]; return [OT(i, r, o, t.motionDurationMid), {
            [`
      ${i}-enter,
      ${i}-appear
    `]: { transform: "scale(0)", transformOrigin: "0% 0%", opacity: 0, animationTimingFunction: t.motionEaseOutQuint }, [`${i}-leave`]: { animationTimingFunction: t.motionEaseInQuint }
        }]
    }, FF = new rt("antZoomIn", { "0%": { transform: "scale(0.2)", opacity: 0 }, "100%": { transform: "scale(1)", opacity: 1 } }), jF = new rt("antZoomOut", { "0%": { transform: "scale(1)" }, "100%": { transform: "scale(0.2)", opacity: 0 } }), Tb = new rt("antZoomBigIn", { "0%": { transform: "scale(0.8)", opacity: 0 }, "100%": { transform: "scale(1)", opacity: 1 } }), $b = new rt("antZoomBigOut", { "0%": { transform: "scale(1)" }, "100%": { transform: "scale(0.8)", opacity: 0 } }), qF = new rt("antZoomUpIn", { "0%": { transform: "scale(0.8)", transformOrigin: "50% 0%", opacity: 0 }, "100%": { transform: "scale(1)", transformOrigin: "50% 0%" } }), VF = new rt("antZoomUpOut", { "0%": { transform: "scale(1)", transformOrigin: "50% 0%" }, "100%": { transform: "scale(0.8)", transformOrigin: "50% 0%", opacity: 0 } }), XF = new rt("antZoomLeftIn", { "0%": { transform: "scale(0.8)", transformOrigin: "0% 50%", opacity: 0 }, "100%": { transform: "scale(1)", transformOrigin: "0% 50%" } }), UF = new rt("antZoomLeftOut", { "0%": { transform: "scale(1)", transformOrigin: "0% 50%" }, "100%": { transform: "scale(0.8)", transformOrigin: "0% 50%", opacity: 0 } }), GF = new rt("antZoomRightIn", { "0%": { transform: "scale(0.8)", transformOrigin: "100% 50%", opacity: 0 }, "100%": { transform: "scale(1)", transformOrigin: "100% 50%" } }), KF = new rt("antZoomRightOut", { "0%": { transform: "scale(1)", transformOrigin: "100% 50%" }, "100%": { transform: "scale(0.8)", transformOrigin: "100% 50%", opacity: 0 } }), YF = new rt("antZoomDownIn", { "0%": { transform: "scale(0.8)", transformOrigin: "50% 100%", opacity: 0 }, "100%": { transform: "scale(1)", transformOrigin: "50% 100%" } }), ZF = new rt("antZoomDownOut", { "0%": { transform: "scale(1)", transformOrigin: "50% 100%" }, "100%": { transform: "scale(0.8)", transformOrigin: "50% 100%", opacity: 0 } }), JF = { zoom: { inKeyframes: FF, outKeyframes: jF }, "zoom-big": { inKeyframes: Tb, outKeyframes: $b }, "zoom-big-fast": { inKeyframes: Tb, outKeyframes: $b }, "zoom-left": { inKeyframes: XF, outKeyframes: UF }, "zoom-right": { inKeyframes: GF, outKeyframes: KF }, "zoom-up": { inKeyframes: qF, outKeyframes: VF }, "zoom-down": { inKeyframes: YF, outKeyframes: ZF } }, ST = (t, e) => {
        const { antCls: n } = t, i = `${n}-${e}`, { inKeyframes: r, outKeyframes: o } = JF[e]; return [OT(i, r, o, e === "zoom-big-fast" ? t.motionDurationFast : t.motionDurationMid), {
            [`
        ${i}-enter,
        ${i}-appear
      `]: { transform: "scale(0)", opacity: 0, animationTimingFunction: t.motionEaseOutCirc, "&-prepare": { transform: "none" } }, [`${i}-leave`]: { animationTimingFunction: t.motionEaseInOutCirc }
        }]
    }, e3 = t => ({
        [t.componentCls]: {
            [`${t.antCls}-motion-collapse-legacy`]: {
                overflow: "hidden", "&-active": {
                    transition: `height ${t.motionDurationMid} ${t.motionEaseInOut},
        opacity ${t.motionDurationMid} ${t.motionEaseInOut} !important`
                }
            }, [`${t.antCls}-motion-collapse`]: {
                overflow: "hidden", transition: `height ${t.motionDurationMid} ${t.motionEaseInOut},
        opacity ${t.motionDurationMid} ${t.motionEaseInOut} !important`
            }
        }
    }), t3 = e3; function n3(t, e, n) { const { focusElCls: i, focus: r, borderElCls: o } = n, s = o ? "> *" : "", l = ["hover", r ? "focus" : null, "active"].filter(Boolean).map(a => `&:${a} ${s}`).join(","); return { [`&-item:not(${e}-last-item)`]: { marginInlineEnd: -t.lineWidth }, "&-item": S(S({ [l]: { zIndex: 2 } }, i ? { [`&${i}`]: { zIndex: 2 } } : {}), { [`&[disabled] ${s}`]: { zIndex: 0 } }) } } function i3(t, e, n) { const { borderElCls: i } = n, r = i ? `> ${i}` : ""; return { [`&-item:not(${e}-first-item):not(${e}-last-item) ${r}`]: { borderRadius: 0 }, [`&-item:not(${e}-last-item)${e}-first-item`]: { [`& ${r}, &${t}-sm ${r}, &${t}-lg ${r}`]: { borderStartEndRadius: 0, borderEndEndRadius: 0 } }, [`&-item:not(${e}-first-item)${e}-last-item`]: { [`& ${r}, &${t}-sm ${r}, &${t}-lg ${r}`]: { borderStartStartRadius: 0, borderEndStartRadius: 0 } } } } function r3(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { focus: !0 }; const { componentCls: n } = t, i = `${n}-compact`; return { [i]: S(S({}, n3(t, i, e)), i3(n, i, e)) } } const ja = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"], o3 = t => ({ xs: `(max-width: ${t.screenXSMax}px)`, sm: `(min-width: ${t.screenSM}px)`, md: `(min-width: ${t.screenMD}px)`, lg: `(min-width: ${t.screenLG}px)`, xl: `(min-width: ${t.screenXL}px)`, xxl: `(min-width: ${t.screenXXL}px)`, xxxl: `{min-width: ${t.screenXXXL}px}` }); function s3() { const [, t] = Zl(); return E(() => { const e = o3(t.value), n = new Map; let i = -1, r = {}; return { matchHandlers: {}, dispatch(o) { return r = o, n.forEach(s => s(r)), n.size >= 1 }, subscribe(o) { return n.size || this.register(), i += 1, n.set(i, o), o(r), i }, unsubscribe(o) { n.delete(o), n.size || this.unregister() }, unregister() { Object.keys(e).forEach(o => { const s = e[o], l = this.matchHandlers[s]; l == null || l.mql.removeListener(l == null ? void 0 : l.listener) }), n.clear() }, register() { Object.keys(e).forEach(o => { const s = e[o], l = c => { let { matches: u } = c; this.dispatch(S(S({}, r), { [o]: u })) }, a = window.matchMedia(s); a.addListener(l), this.matchHandlers[s] = { mql: a, listener: l }, l(a) }) }, responsiveMap: e } }) } const mn = { adjustX: 1, adjustY: 1 }, vn = [0, 0], xT = { left: { points: ["cr", "cl"], overflow: mn, offset: [-4, 0], targetOffset: vn }, right: { points: ["cl", "cr"], overflow: mn, offset: [4, 0], targetOffset: vn }, top: { points: ["bc", "tc"], overflow: mn, offset: [0, -4], targetOffset: vn }, bottom: { points: ["tc", "bc"], overflow: mn, offset: [0, 4], targetOffset: vn }, topLeft: { points: ["bl", "tl"], overflow: mn, offset: [0, -4], targetOffset: vn }, leftTop: { points: ["tr", "tl"], overflow: mn, offset: [-4, 0], targetOffset: vn }, topRight: { points: ["br", "tr"], overflow: mn, offset: [0, -4], targetOffset: vn }, rightTop: { points: ["tl", "tr"], overflow: mn, offset: [4, 0], targetOffset: vn }, bottomRight: { points: ["tr", "br"], overflow: mn, offset: [0, 4], targetOffset: vn }, rightBottom: { points: ["bl", "br"], overflow: mn, offset: [4, 0], targetOffset: vn }, bottomLeft: { points: ["tl", "bl"], overflow: mn, offset: [0, 4], targetOffset: vn }, leftBottom: { points: ["br", "bl"], overflow: mn, offset: [-4, 0], targetOffset: vn } }, l3 = { prefixCls: String, id: String, overlayInnerStyle: ne.any }, a3 = ue({ compatConfig: { MODE: 3 }, name: "TooltipContent", props: l3, setup(t, e) { let { slots: n } = e; return () => { var i; return $("div", { class: `${t.prefixCls}-inner`, id: t.id, role: "tooltip", style: t.overlayInnerStyle }, [(i = n.overlay) === null || i === void 0 ? void 0 : i.call(n)]) } } }); var c3 = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; function kb() { } const u3 = ue({ compatConfig: { MODE: 3 }, name: "Tooltip", inheritAttrs: !1, props: { trigger: ne.any.def(["hover"]), defaultVisible: { type: Boolean, default: void 0 }, visible: { type: Boolean, default: void 0 }, placement: ne.string.def("right"), transitionName: String, animation: ne.any, afterVisibleChange: ne.func.def(() => { }), overlayStyle: { type: Object, default: void 0 }, overlayClassName: String, prefixCls: ne.string.def("rc-tooltip"), mouseEnterDelay: ne.number.def(.1), mouseLeaveDelay: ne.number.def(.1), getPopupContainer: Function, destroyTooltipOnHide: { type: Boolean, default: !1 }, align: ne.object.def(() => ({})), arrowContent: ne.any.def(null), tipId: String, builtinPlacements: ne.object, overlayInnerStyle: { type: Object, default: void 0 }, popupVisible: { type: Boolean, default: void 0 }, onVisibleChange: Function, onPopupAlign: Function, arrow: { type: Boolean, default: !0 } }, setup(t, e) { let { slots: n, attrs: i, expose: r } = e; const o = oe(), s = () => { const { prefixCls: u, tipId: f, overlayInnerStyle: h } = t; return [t.arrow ? $("div", { class: `${u}-arrow`, key: "arrow" }, [Do(n, t, "arrowContent")]) : null, $(a3, { key: "content", prefixCls: u, id: f, overlayInnerStyle: h }, { overlay: n.overlay })] }; r({ getPopupDomNode: () => o.value.getPopupDomNode(), triggerDOM: o, forcePopupAlign: () => { var u; return (u = o.value) === null || u === void 0 ? void 0 : u.forcePopupAlign() } }); const a = oe(!1), c = oe(!1); return hn(() => { const { destroyTooltipOnHide: u } = t; if (typeof u == "boolean") a.value = u; else if (u && typeof u == "object") { const { keepParent: f } = u; a.value = f === !0, c.value = f === !1 } }), () => { const { overlayClassName: u, trigger: f, mouseEnterDelay: h, mouseLeaveDelay: d, overlayStyle: p, prefixCls: g, afterVisibleChange: m, transitionName: v, animation: b, placement: x, align: w, destroyTooltipOnHide: y, defaultVisible: C } = t, O = c3(t, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]), P = S({}, O); t.visible !== void 0 && (P.popupVisible = t.visible); const M = S(S(S({ popupClassName: u, prefixCls: g, action: f, builtinPlacements: xT, popupPlacement: x, popupAlign: w, afterPopupVisibleChange: m, popupTransitionName: v, popupAnimation: b, defaultPopupVisible: C, destroyPopupOnHide: a.value, autoDestroy: c.value, mouseLeaveDelay: d, popupStyle: p, mouseEnterDelay: h }, P), i), { onPopupVisibleChange: t.onVisibleChange || kb, onPopupAlign: t.onPopupAlign || kb, ref: o, arrow: !!t.arrow, popup: s() }); return $(Xg, M, { default: n.default }) } } }), f3 = () => ({ trigger: [String, Array], open: { type: Boolean, default: void 0 }, visible: { type: Boolean, default: void 0 }, placement: String, color: String, transitionName: String, overlayStyle: zt(), overlayInnerStyle: zt(), overlayClassName: String, openClassName: String, prefixCls: String, mouseEnterDelay: Number, mouseLeaveDelay: Number, getPopupContainer: Function, arrowPointAtCenter: { type: Boolean, default: void 0 }, arrow: { type: [Boolean, Object], default: !0 }, autoAdjustOverflow: { type: [Boolean, Object], default: void 0 }, destroyTooltipOnHide: { type: Boolean, default: void 0 }, align: zt(), builtinPlacements: zt(), children: Array, onVisibleChange: Function, "onUpdate:visible": Function, onOpenChange: Function, "onUpdate:open": Function }), h3 = { adjustX: 1, adjustY: 1 }, Pb = { adjustX: 0, adjustY: 0 }, d3 = [0, 0]; function Ab(t) { return typeof t == "boolean" ? t ? h3 : Pb : S(S({}, Pb), t) } function p3(t) { const { arrowWidth: e = 4, horizontalArrowShift: n = 16, verticalArrowShift: i = 8, autoAdjustOverflow: r, arrowPointAtCenter: o } = t, s = { left: { points: ["cr", "cl"], offset: [-4, 0] }, right: { points: ["cl", "cr"], offset: [4, 0] }, top: { points: ["bc", "tc"], offset: [0, -4] }, bottom: { points: ["tc", "bc"], offset: [0, 4] }, topLeft: { points: ["bl", "tc"], offset: [-(n + e), -4] }, leftTop: { points: ["tr", "cl"], offset: [-4, -(i + e)] }, topRight: { points: ["br", "tc"], offset: [n + e, -4] }, rightTop: { points: ["tl", "cr"], offset: [4, -(i + e)] }, bottomRight: { points: ["tr", "bc"], offset: [n + e, 4] }, rightBottom: { points: ["bl", "cr"], offset: [4, i + e] }, bottomLeft: { points: ["tl", "bc"], offset: [-(n + e), 4] }, leftBottom: { points: ["br", "cl"], offset: [-4, i + e] } }; return Object.keys(s).forEach(l => { s[l] = o ? S(S({}, s[l]), { overflow: Ab(r), targetOffset: d3 }) : S(S({}, xT[l]), { overflow: Ab(r) }), s[l].ignoreShake = !0 }), s } function g3() { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; for (let e = 0, n = t.length; e < n; e++)if (t[e] !== void 0) return t[e] } const m3 = lu.map(t => `${t}-inverse`); function v3(t) { return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [...m3, ...lu].includes(t) : lu.includes(t) } function y3(t, e) { const n = v3(e), i = ke({ [`${t}-${e}`]: e && n }), r = {}, o = {}; return e && !n && (r.background = e, o["--antd-arrow-background-color"] = e), { className: i, overlayStyle: r, arrowStyle: o } } function qa(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ""; return t.map(n => `${e}${n}`).join(",") } const wT = 8; function b3(t) { const e = wT, { sizePopupArrow: n, contentRadius: i, borderRadiusOuter: r, limitVerticalRadius: o } = t, s = n / 2 - Math.ceil(r * (Math.sqrt(2) - 1)), l = (i > 12 ? i + 2 : 12) - s, a = o ? e - s : l; return { dropdownArrowOffset: l, dropdownArrowOffsetVertical: a } } function O3(t, e) { const { componentCls: n, sizePopupArrow: i, marginXXS: r, borderRadiusXS: o, borderRadiusOuter: s, boxShadowPopoverArrow: l } = t, { colorBg: a, showArrowCls: c, contentRadius: u = t.borderRadiusLG, limitVerticalRadius: f } = e, { dropdownArrowOffsetVertical: h, dropdownArrowOffset: d } = b3({ sizePopupArrow: i, contentRadius: u, borderRadiusOuter: s, limitVerticalRadius: f }), p = i / 2 + r; return { [n]: { [`${n}-arrow`]: [S(S({ position: "absolute", zIndex: 1, display: "block" }, DL(i, o, s, a, l)), { "&:before": { background: a } })], [[`&-placement-top ${n}-arrow`, `&-placement-topLeft ${n}-arrow`, `&-placement-topRight ${n}-arrow`].join(",")]: { bottom: 0, transform: "translateY(100%) rotate(180deg)" }, [`&-placement-top ${n}-arrow`]: { left: { _skip_check_: !0, value: "50%" }, transform: "translateX(-50%) translateY(100%) rotate(180deg)" }, [`&-placement-topLeft ${n}-arrow`]: { left: { _skip_check_: !0, value: d } }, [`&-placement-topRight ${n}-arrow`]: { right: { _skip_check_: !0, value: d } }, [[`&-placement-bottom ${n}-arrow`, `&-placement-bottomLeft ${n}-arrow`, `&-placement-bottomRight ${n}-arrow`].join(",")]: { top: 0, transform: "translateY(-100%)" }, [`&-placement-bottom ${n}-arrow`]: { left: { _skip_check_: !0, value: "50%" }, transform: "translateX(-50%) translateY(-100%)" }, [`&-placement-bottomLeft ${n}-arrow`]: { left: { _skip_check_: !0, value: d } }, [`&-placement-bottomRight ${n}-arrow`]: { right: { _skip_check_: !0, value: d } }, [[`&-placement-left ${n}-arrow`, `&-placement-leftTop ${n}-arrow`, `&-placement-leftBottom ${n}-arrow`].join(",")]: { right: { _skip_check_: !0, value: 0 }, transform: "translateX(100%) rotate(90deg)" }, [`&-placement-left ${n}-arrow`]: { top: { _skip_check_: !0, value: "50%" }, transform: "translateY(-50%) translateX(100%) rotate(90deg)" }, [`&-placement-leftTop ${n}-arrow`]: { top: h }, [`&-placement-leftBottom ${n}-arrow`]: { bottom: h }, [[`&-placement-right ${n}-arrow`, `&-placement-rightTop ${n}-arrow`, `&-placement-rightBottom ${n}-arrow`].join(",")]: { left: { _skip_check_: !0, value: 0 }, transform: "translateX(-100%) rotate(-90deg)" }, [`&-placement-right ${n}-arrow`]: { top: { _skip_check_: !0, value: "50%" }, transform: "translateY(-50%) translateX(-100%) rotate(-90deg)" }, [`&-placement-rightTop ${n}-arrow`]: { top: h }, [`&-placement-rightBottom ${n}-arrow`]: { bottom: h }, [qa(["&-placement-topLeft", "&-placement-top", "&-placement-topRight"].map(g => g += ":not(&-arrow-hidden)"), c)]: { paddingBottom: p }, [qa(["&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight"].map(g => g += ":not(&-arrow-hidden)"), c)]: { paddingTop: p }, [qa(["&-placement-leftTop", "&-placement-left", "&-placement-leftBottom"].map(g => g += ":not(&-arrow-hidden)"), c)]: { paddingRight: { _skip_check_: !0, value: p } }, [qa(["&-placement-rightTop", "&-placement-right", "&-placement-rightBottom"].map(g => g += ":not(&-arrow-hidden)"), c)]: { paddingLeft: { _skip_check_: !0, value: p } } } } } const S3 = t => { const { componentCls: e, tooltipMaxWidth: n, tooltipColor: i, tooltipBg: r, tooltipBorderRadius: o, zIndexPopup: s, controlHeight: l, boxShadowSecondary: a, paddingSM: c, paddingXS: u, tooltipRadiusOuter: f } = t; return [{ [e]: S(S(S(S({}, Yl(t)), { position: "absolute", zIndex: s, display: "block", "&": [{ width: "max-content" }, { width: "intrinsic" }], maxWidth: n, visibility: "visible", "&-hidden": { display: "none" }, "--antd-arrow-background-color": r, [`${e}-inner`]: { minWidth: l, minHeight: l, padding: `${c / 2}px ${u}px`, color: i, textAlign: "start", textDecoration: "none", wordWrap: "break-word", backgroundColor: r, borderRadius: o, boxShadow: a }, [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: { [`${e}-inner`]: { borderRadius: Math.min(o, wT) } }, [`${e}-content`]: { position: "relative" } }), BL(t, (h, d) => { let { darkColor: p } = d; return { [`&${e}-${h}`]: { [`${e}-inner`]: { backgroundColor: p }, [`${e}-arrow`]: { "--antd-arrow-background-color": p } } } })), { "&-rtl": { direction: "rtl" } }) }, O3(dn(t, { borderRadiusOuter: f }), { colorBg: "var(--antd-arrow-background-color)", showArrowCls: "", contentRadius: o, limitVerticalRadius: !0 }), { [`${e}-pure`]: { position: "relative", maxWidth: "none" } }] }, x3 = (t, e) => zn("Tooltip", i => { if ((e == null ? void 0 : e.value) === !1) return []; const { borderRadius: r, colorTextLightSolid: o, colorBgDefault: s, borderRadiusOuter: l } = i, a = dn(i, { tooltipMaxWidth: 250, tooltipColor: o, tooltipBorderRadius: r, tooltipBg: s, tooltipRadiusOuter: l > 4 ? 4 : l }); return [S3(a), ST(i, "zoom-big-fast")] }, i => { let { zIndexPopupBase: r, colorBgSpotlight: o } = i; return { zIndexPopup: r + 70, colorBgDefault: o } })(t), w3 = (t, e) => { const n = {}, i = S({}, t); return e.forEach(r => { t && r in t && (n[r] = t[r], delete i[r]) }), { picked: n, omitted: i } }, C3 = () => S(S({}, f3()), { title: ne.any }), T3 = ue({ compatConfig: { MODE: 3 }, name: "ATooltip", inheritAttrs: !1, props: to(C3(), { trigger: "hover", align: {}, placement: "top", mouseEnterDelay: .1, mouseLeaveDelay: .1, arrowPointAtCenter: !1, autoAdjustOverflow: !0 }), slots: Object, setup(t, e) { let { slots: n, emit: i, attrs: r, expose: o } = e; const { prefixCls: s, getPopupContainer: l, direction: a, rootPrefixCls: c } = dt("tooltip", t), u = E(() => { var A; return (A = t.open) !== null && A !== void 0 ? A : t.visible }), f = he(g3([t.open, t.visible])), h = he(); let d; Te(u, A => { nt.cancel(d), d = nt(() => { f.value = !!A }) }); const p = () => { var A; const B = (A = t.title) !== null && A !== void 0 ? A : n.title; return !B && B !== 0 }, g = A => { const B = p(); u.value === void 0 && (f.value = B ? !1 : A), B || (i("update:visible", A), i("visibleChange", A), i("update:open", A), i("openChange", A)) }; o({ getPopupDomNode: () => h.value.getPopupDomNode(), open: f, forcePopupAlign: () => { var A; return (A = h.value) === null || A === void 0 ? void 0 : A.forcePopupAlign() } }); const v = E(() => { var A; const { builtinPlacements: B, autoAdjustOverflow: R, arrow: X, arrowPointAtCenter: K } = t; let _ = K; return typeof X == "object" && (_ = (A = X.pointAtCenter) !== null && A !== void 0 ? A : K), B || p3({ arrowPointAtCenter: _, autoAdjustOverflow: R }) }), b = A => A || A === "", x = A => { const B = A.type; if (typeof B == "object" && A.props && ((B.__ANT_BUTTON === !0 || B === "button") && b(A.props.disabled) || B.__ANT_SWITCH === !0 && (b(A.props.disabled) || b(A.props.loading)) || B.__ANT_RADIO === !0 && b(A.props.disabled))) { const { picked: R, omitted: X } = w3(jB(A), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), K = S(S({ display: "inline-block" }, R), { cursor: "not-allowed", lineHeight: 1, width: A.props && A.props.block ? "100%" : void 0 }), _ = S(S({}, X), { pointerEvents: "none" }), j = ai(A, { style: _ }, !0); return $("span", { style: K, class: `${s.value}-disabled-compatible-wrapper` }, [j]) } return A }, w = () => { var A, B; return (A = t.title) !== null && A !== void 0 ? A : (B = n.title) === null || B === void 0 ? void 0 : B.call(n) }, y = (A, B) => { const R = v.value, X = Object.keys(R).find(K => { var _, j; return R[K].points[0] === ((_ = B.points) === null || _ === void 0 ? void 0 : _[0]) && R[K].points[1] === ((j = B.points) === null || j === void 0 ? void 0 : j[1]) }); if (X) { const K = A.getBoundingClientRect(), _ = { top: "50%", left: "50%" }; X.indexOf("top") >= 0 || X.indexOf("Bottom") >= 0 ? _.top = `${K.height - B.offset[1]}px` : (X.indexOf("Top") >= 0 || X.indexOf("bottom") >= 0) && (_.top = `${-B.offset[1]}px`), X.indexOf("left") >= 0 || X.indexOf("Right") >= 0 ? _.left = `${K.width - B.offset[0]}px` : (X.indexOf("right") >= 0 || X.indexOf("Left") >= 0) && (_.left = `${-B.offset[0]}px`), A.style.transformOrigin = `${_.left} ${_.top}` } }, C = E(() => y3(s.value, t.color)), O = E(() => r["data-popover-inject"]), [P, M] = x3(s, E(() => !O.value)); return () => { var A, B; const { openClassName: R, overlayClassName: X, overlayStyle: K, overlayInnerStyle: _ } = t; let j = (B = us((A = n.default) === null || A === void 0 ? void 0 : A.call(n))) !== null && B !== void 0 ? B : null; j = j.length === 1 ? j[0] : j; let W = f.value; if (u.value === void 0 && p() && (W = !1), !j) return null; const G = x(Gu(j) && !qB(j) ? j : $("span", null, [j])), ae = ke({ [R || `${s.value}-open`]: !0, [G.props && G.props.class]: G.props && G.props.class }), ge = ke(X, { [`${s.value}-rtl`]: a.value === "rtl" }, C.value.className, M.value), J = S(S({}, C.value.overlayStyle), _), ce = C.value.arrowStyle, Oe = S(S(S({}, r), t), { prefixCls: s.value, arrow: !!t.arrow, getPopupContainer: l == null ? void 0 : l.value, builtinPlacements: v.value, visible: W, ref: h, overlayClassName: ge, overlayStyle: S(S({}, ce), K), overlayInnerStyle: J, onVisibleChange: g, onPopupAlign: y, transitionName: rW(c.value, "zoom-big-fast", t.transitionName) }); return P($(u3, Oe, { default: () => [f.value ? ai(G, { class: ae }) : G], arrowContent: () => $("span", { class: `${s.value}-arrow-content` }, null), overlay: w })) } } }), $3 = Kl(T3), uo = { adjustX: 1, adjustY: 1 }, fo = [0, 0], k3 = { topLeft: { points: ["bl", "tl"], overflow: uo, offset: [0, -4], targetOffset: fo }, topCenter: { points: ["bc", "tc"], overflow: uo, offset: [0, -4], targetOffset: fo }, topRight: { points: ["br", "tr"], overflow: uo, offset: [0, -4], targetOffset: fo }, bottomLeft: { points: ["tl", "bl"], overflow: uo, offset: [0, 4], targetOffset: fo }, bottomCenter: { points: ["tc", "bc"], overflow: uo, offset: [0, 4], targetOffset: fo }, bottomRight: { points: ["tr", "br"], overflow: uo, offset: [0, 4], targetOffset: fo } }, P3 = k3; var A3 = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; const M3 = ue({ compatConfig: { MODE: 3 }, props: { minOverlayWidthMatchTrigger: { type: Boolean, default: void 0 }, arrow: { type: Boolean, default: !1 }, prefixCls: ne.string.def("rc-dropdown"), transitionName: String, overlayClassName: ne.string.def(""), openClassName: String, animation: ne.any, align: ne.object, overlayStyle: { type: Object, default: void 0 }, placement: ne.string.def("bottomLeft"), overlay: ne.any, trigger: ne.oneOfType([ne.string, ne.arrayOf(ne.string)]).def("hover"), alignPoint: { type: Boolean, default: void 0 }, showAction: ne.array, hideAction: ne.array, getPopupContainer: Function, visible: { type: Boolean, default: void 0 }, defaultVisible: { type: Boolean, default: !1 }, mouseEnterDelay: ne.number.def(.15), mouseLeaveDelay: ne.number.def(.1) }, emits: ["visibleChange", "overlayClick"], setup(t, e) { let { slots: n, emit: i, expose: r } = e; const o = he(!!t.visible); Te(() => t.visible, d => { d !== void 0 && (o.value = d) }); const s = he(); r({ triggerRef: s }); const l = d => { t.visible === void 0 && (o.value = !1), i("overlayClick", d) }, a = d => { t.visible === void 0 && (o.value = d), i("visibleChange", d) }, c = () => { var d; const p = (d = n.overlay) === null || d === void 0 ? void 0 : d.call(n), g = { prefixCls: `${t.prefixCls}-menu`, onClick: l }; return $(et, { key: Dw }, [t.arrow && $("div", { class: `${t.prefixCls}-arrow` }, null), ai(p, g, !1)]) }, u = E(() => { const { minOverlayWidthMatchTrigger: d = !t.alignPoint } = t; return d }), f = () => { var d; const p = (d = n.default) === null || d === void 0 ? void 0 : d.call(n); return o.value && p ? ai(p[0], { class: t.openClassName || `${t.prefixCls}-open` }, !1) : p }, h = E(() => !t.hideAction && t.trigger.indexOf("contextmenu") !== -1 ? ["click"] : t.hideAction); return () => { const { prefixCls: d, arrow: p, showAction: g, overlayStyle: m, trigger: v, placement: b, align: x, getPopupContainer: w, transitionName: y, animation: C, overlayClassName: O } = t, P = A3(t, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]); return $(Xg, ee(ee({}, P), {}, { prefixCls: d, ref: s, popupClassName: ke(O, { [`${d}-show-arrow`]: p }), popupStyle: m, builtinPlacements: P3, action: v, showAction: g, hideAction: h.value || [], popupPlacement: b, popupAlign: x, popupTransitionName: y, popupAnimation: C, popupVisible: o.value, stretch: u.value ? "minWidth" : "", onPopupVisibleChange: a, getPopupContainer: w }), { popup: c, default: f }) } } }), E3 = t => { const { componentCls: e, colorPrimary: n } = t; return { [e]: { position: "absolute", background: "transparent", pointerEvents: "none", boxSizing: "border-box", color: `var(--wave-color, ${n})`, boxShadow: "0 0 0 0 currentcolor", opacity: .2, "&.wave-motion-appear": { transition: [`box-shadow 0.4s ${t.motionEaseOutCirc}`, `opacity 2s ${t.motionEaseOutCirc}`].join(","), "&-active": { boxShadow: "0 0 0 6px currentcolor", opacity: 0 } } } } }, _3 = zn("Wave", t => [E3(t)]); function R3(t) { const e = (t || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/); return e && e[1] && e[2] && e[3] ? !(e[1] === e[2] && e[2] === e[3]) : !0 } function Ch(t) { return t && t !== "#fff" && t !== "#ffffff" && t !== "rgb(255, 255, 255)" && t !== "rgba(255, 255, 255, 1)" && R3(t) && !/rgba\((?:\d*, ){3}0\)/.test(t) && t !== "transparent" } function I3(t) { const { borderTopColor: e, borderColor: n, backgroundColor: i } = getComputedStyle(t); return Ch(e) ? e : Ch(n) ? n : Ch(i) ? i : null } function Th(t) { return Number.isNaN(t) ? 0 : t } const D3 = ue({ props: { target: zt(), className: String }, setup(t) { const e = oe(null), [n, i] = Je(null), [r, o] = Je([]), [s, l] = Je(0), [a, c] = Je(0), [u, f] = Je(0), [h, d] = Je(0), [p, g] = Je(!1); function m() { const { target: O } = t, P = getComputedStyle(O); i(I3(O)); const M = P.position === "static", { borderLeftWidth: A, borderTopWidth: B } = P; l(M ? O.offsetLeft : Th(-parseFloat(A))), c(M ? O.offsetTop : Th(-parseFloat(B))), f(O.offsetWidth), d(O.offsetHeight); const { borderTopLeftRadius: R, borderTopRightRadius: X, borderBottomLeftRadius: K, borderBottomRightRadius: _ } = P; o([R, X, _, K].map(j => Th(parseFloat(j)))) } let v, b, x; const w = () => { clearTimeout(x), nt.cancel(b), v == null || v.disconnect() }, y = () => { var O; const P = (O = e.value) === null || O === void 0 ? void 0 : O.parentElement; P && (jh(null, P), P.parentElement && P.parentElement.removeChild(P)) }; vt(() => { w(), x = setTimeout(() => { y() }, 5e3); const { target: O } = t; O && (b = nt(() => { m(), g(!0) }), typeof ResizeObserver < "u" && (v = new ResizeObserver(m), v.observe(O))) }), At(() => { w() }); const C = O => { O.propertyName === "opacity" && y() }; return () => { if (!p.value) return null; const O = { left: `${s.value}px`, top: `${a.value}px`, width: `${u.value}px`, height: `${h.value}px`, borderRadius: r.value.map(P => `${P}px`).join(" ") }; return n && (O["--wave-color"] = n.value), $(os, { appear: !0, name: "wave-motion", appearFromClass: "wave-motion-appear", appearActiveClass: "wave-motion-appear", appearToClass: "wave-motion-appear wave-motion-appear-active" }, { default: () => [$("div", { ref: e, class: t.className, style: O, onTransitionend: C }, null)] }) } } }); function B3(t, e) { const n = document.createElement("div"); return n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", t == null || t.insertBefore(n, t == null ? void 0 : t.firstChild), jh($(D3, { target: t, className: e }, null), n), () => { jh(null, n), n.parentElement && n.parentElement.removeChild(n) } } function L3(t, e) { const n = vr(); let i; function r() { var o; const s = Ji(n); i == null || i(), !(!((o = e == null ? void 0 : e.value) === null || o === void 0) && o.disabled || !s) && (i = B3(s, t.value)) } return At(() => { i == null || i() }), r } const Q3 = ue({ compatConfig: { MODE: 3 }, name: "Wave", props: { disabled: Boolean }, setup(t, e) { let { slots: n } = e; const i = vr(), { prefixCls: r, wave: o } = dt("wave", t), [, s] = _3(r), l = L3(E(() => ke(r.value, s.value)), o); let a; const c = () => { Ji(i).removeEventListener("click", a, !0) }; return vt(() => { Te(() => t.disabled, () => { c(), ri(() => { const u = Ji(i); u == null || u.removeEventListener("click", a, !0), !(!u || u.nodeType !== 1 || t.disabled) && (a = f => { f.target.tagName === "INPUT" || !NC(f.target) || !u.getAttribute || u.getAttribute("disabled") || u.disabled || u.className.includes("disabled") || u.className.includes("-leave") || l() }, u.addEventListener("click", a, !0)) }) }, { immediate: !0, flush: "post" }) }), At(() => { c() }), () => { var u; return (u = n.default) === null || u === void 0 ? void 0 : u.call(n)[0] } } }), N3 = () => ({ prefixCls: String, type: String, htmlType: { type: String, default: "button" }, shape: { type: String }, size: { type: String }, loading: { type: [Boolean, Object], default: () => !1 }, disabled: { type: Boolean, default: void 0 }, ghost: { type: Boolean, default: void 0 }, block: { type: Boolean, default: void 0 }, danger: { type: Boolean, default: void 0 }, icon: ne.any, href: String, target: String, title: String, onClick: Zv(), onMousedown: Zv() }), z3 = N3, Mb = t => { t && (t.style.width = "0px", t.style.opacity = "0", t.style.transform = "scale(0)") }, Eb = t => { ri(() => { t && (t.style.width = `${t.scrollWidth}px`, t.style.opacity = "1", t.style.transform = "scale(1)") }) }, _b = t => { t && t.style && (t.style.width = null, t.style.opacity = null, t.style.transform = null) }, W3 = ue({ compatConfig: { MODE: 3 }, name: "LoadingIcon", props: { prefixCls: String, loading: [Boolean, Object], existIcon: Boolean }, setup(t) { return () => { const { existIcon: e, prefixCls: n, loading: i } = t; if (e) return $("span", { class: `${n}-loading-icon` }, [$(bb, null, null)]); const r = !!i; return $(os, { name: `${n}-loading-icon-motion`, onBeforeEnter: Mb, onEnter: Eb, onAfterEnter: _b, onBeforeLeave: Eb, onLeave: o => { setTimeout(() => { Mb(o) }) }, onAfterLeave: _b }, { default: () => [r ? $("span", { class: `${n}-loading-icon` }, [$(bb, null, null)]) : null] }) } } }), Rb = (t, e) => ({ [`> span, > ${t}`]: { "&:not(:last-child)": { [`&, & > ${t}`]: { "&:not(:disabled)": { borderInlineEndColor: e } } }, "&:not(:first-child)": { [`&, & > ${t}`]: { "&:not(:disabled)": { borderInlineStartColor: e } } } } }), H3 = t => {
        const { componentCls: e, fontSize: n, lineWidth: i, colorPrimaryHover: r, colorErrorHover: o } = t; return {
            [`${e}-group`]: [{
                position: "relative", display: "inline-flex", [`> span, > ${e}`]: { "&:not(:last-child)": { [`&, & > ${e}`]: { borderStartEndRadius: 0, borderEndEndRadius: 0 } }, "&:not(:first-child)": { marginInlineStart: -i, [`&, & > ${e}`]: { borderStartStartRadius: 0, borderEndStartRadius: 0 } } }, [e]: {
                    position: "relative", zIndex: 1, [`&:hover,
          &:focus,
          &:active`]: { zIndex: 2 }, "&[disabled]": { zIndex: 0 }
                }, [`${e}-icon-only`]: { fontSize: n }
            }, Rb(`${e}-primary`, r), Rb(`${e}-danger`, o)]
        }
    }, F3 = H3; function j3(t, e) { return { [`&-item:not(${e}-last-item)`]: { marginBottom: -t.lineWidth }, "&-item": { "&:hover,&:focus,&:active": { zIndex: 2 }, "&[disabled]": { zIndex: 0 } } } } function q3(t, e) { return { [`&-item:not(${e}-first-item):not(${e}-last-item)`]: { borderRadius: 0 }, [`&-item${e}-first-item:not(${e}-last-item)`]: { [`&, &${t}-sm, &${t}-lg`]: { borderEndEndRadius: 0, borderEndStartRadius: 0 } }, [`&-item${e}-last-item:not(${e}-first-item)`]: { [`&, &${t}-sm, &${t}-lg`]: { borderStartStartRadius: 0, borderStartEndRadius: 0 } } } } function V3(t) { const e = `${t.componentCls}-compact-vertical`; return { [e]: S(S({}, j3(t, e)), q3(t.componentCls, e)) } } const X3 = t => { const { componentCls: e, iconCls: n } = t; return { [e]: { outline: "none", position: "relative", display: "inline-block", fontWeight: 400, whiteSpace: "nowrap", textAlign: "center", backgroundImage: "none", backgroundColor: "transparent", border: `${t.lineWidth}px ${t.lineType} transparent`, cursor: "pointer", transition: `all ${t.motionDurationMid} ${t.motionEaseInOut}`, userSelect: "none", touchAction: "manipulation", lineHeight: t.lineHeight, color: t.colorText, "> span": { display: "inline-block" }, [`> ${n} + span, > span + ${n}`]: { marginInlineStart: t.marginXS }, "> a": { color: "currentColor" }, "&:not(:disabled)": S({}, _g(t)), [`&-icon-only${e}-compact-item`]: { flex: "none" }, [`&-compact-item${e}-primary`]: { [`&:not([disabled]) + ${e}-compact-item${e}-primary:not([disabled])`]: { position: "relative", "&:before": { position: "absolute", top: -t.lineWidth, insetInlineStart: -t.lineWidth, display: "inline-block", width: t.lineWidth, height: `calc(100% + ${t.lineWidth * 2}px)`, backgroundColor: t.colorPrimaryHover, content: '""' } } }, "&-compact-vertical-item": { [`&${e}-primary`]: { [`&:not([disabled]) + ${e}-compact-vertical-item${e}-primary:not([disabled])`]: { position: "relative", "&:before": { position: "absolute", top: -t.lineWidth, insetInlineStart: -t.lineWidth, display: "inline-block", width: `calc(100% + ${t.lineWidth * 2}px)`, height: t.lineWidth, backgroundColor: t.colorPrimaryHover, content: '""' } } } } } } }, Ei = (t, e) => ({ "&:not(:disabled)": { "&:hover": t, "&:active": e } }), U3 = t => ({ minWidth: t.controlHeight, paddingInlineStart: 0, paddingInlineEnd: 0, borderRadius: "50%" }), G3 = t => ({ borderRadius: t.controlHeight, paddingInlineStart: t.controlHeight / 2, paddingInlineEnd: t.controlHeight / 2 }), hp = t => ({ cursor: "not-allowed", borderColor: t.colorBorder, color: t.colorTextDisabled, backgroundColor: t.colorBgContainerDisabled, boxShadow: "none" }), pu = (t, e, n, i, r, o, s) => ({ [`&${t}-background-ghost`]: S(S({ color: e || void 0, backgroundColor: "transparent", borderColor: n || void 0, boxShadow: "none" }, Ei(S({ backgroundColor: "transparent" }, o), S({ backgroundColor: "transparent" }, s))), { "&:disabled": { cursor: "not-allowed", color: i || void 0, borderColor: r || void 0 } }) }), im = t => ({ "&:disabled": S({}, hp(t)) }), CT = t => S({}, im(t)), gu = t => ({ "&:disabled": { cursor: "not-allowed", color: t.colorTextDisabled } }), TT = t => S(S(S(S(S({}, CT(t)), { backgroundColor: t.colorBgContainer, borderColor: t.colorBorder, boxShadow: `0 ${t.controlOutlineWidth}px 0 ${t.controlTmpOutline}` }), Ei({ color: t.colorPrimaryHover, borderColor: t.colorPrimaryHover }, { color: t.colorPrimaryActive, borderColor: t.colorPrimaryActive })), pu(t.componentCls, t.colorBgContainer, t.colorBgContainer, t.colorTextDisabled, t.colorBorder)), { [`&${t.componentCls}-dangerous`]: S(S(S({ color: t.colorError, borderColor: t.colorError }, Ei({ color: t.colorErrorHover, borderColor: t.colorErrorBorderHover }, { color: t.colorErrorActive, borderColor: t.colorErrorActive })), pu(t.componentCls, t.colorError, t.colorError, t.colorTextDisabled, t.colorBorder)), im(t)) }), K3 = t => S(S(S(S(S({}, CT(t)), { color: t.colorTextLightSolid, backgroundColor: t.colorPrimary, boxShadow: `0 ${t.controlOutlineWidth}px 0 ${t.controlOutline}` }), Ei({ color: t.colorTextLightSolid, backgroundColor: t.colorPrimaryHover }, { color: t.colorTextLightSolid, backgroundColor: t.colorPrimaryActive })), pu(t.componentCls, t.colorPrimary, t.colorPrimary, t.colorTextDisabled, t.colorBorder, { color: t.colorPrimaryHover, borderColor: t.colorPrimaryHover }, { color: t.colorPrimaryActive, borderColor: t.colorPrimaryActive })), { [`&${t.componentCls}-dangerous`]: S(S(S({ backgroundColor: t.colorError, boxShadow: `0 ${t.controlOutlineWidth}px 0 ${t.colorErrorOutline}` }, Ei({ backgroundColor: t.colorErrorHover }, { backgroundColor: t.colorErrorActive })), pu(t.componentCls, t.colorError, t.colorError, t.colorTextDisabled, t.colorBorder, { color: t.colorErrorHover, borderColor: t.colorErrorHover }, { color: t.colorErrorActive, borderColor: t.colorErrorActive })), im(t)) }), Y3 = t => S(S({}, TT(t)), { borderStyle: "dashed" }), Z3 = t => S(S(S({ color: t.colorLink }, Ei({ color: t.colorLinkHover }, { color: t.colorLinkActive })), gu(t)), { [`&${t.componentCls}-dangerous`]: S(S({ color: t.colorError }, Ei({ color: t.colorErrorHover }, { color: t.colorErrorActive })), gu(t)) }), J3 = t => S(S(S({}, Ei({ color: t.colorText, backgroundColor: t.colorBgTextHover }, { color: t.colorText, backgroundColor: t.colorBgTextActive })), gu(t)), { [`&${t.componentCls}-dangerous`]: S(S({ color: t.colorError }, gu(t)), Ei({ color: t.colorErrorHover, backgroundColor: t.colorErrorBg }, { color: t.colorErrorHover, backgroundColor: t.colorErrorBg })) }), ej = t => S(S({}, hp(t)), { [`&${t.componentCls}:hover`]: S({}, hp(t)) }), tj = t => { const { componentCls: e } = t; return { [`${e}-default`]: TT(t), [`${e}-primary`]: K3(t), [`${e}-dashed`]: Y3(t), [`${e}-link`]: Z3(t), [`${e}-text`]: J3(t), [`${e}-disabled`]: ej(t) } }, rm = function (t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ""; const { componentCls: n, iconCls: i, controlHeight: r, fontSize: o, lineHeight: s, lineWidth: l, borderRadius: a, buttonPaddingHorizontal: c } = t, u = Math.max(0, (r - o * s) / 2 - l), f = c - l, h = `${n}-icon-only`; return [{ [`${n}${e}`]: { fontSize: o, height: r, padding: `${u}px ${f}px`, borderRadius: a, [`&${h}`]: { width: r, paddingInlineStart: 0, paddingInlineEnd: 0, [`&${n}-round`]: { width: "auto" }, "> span": { transform: "scale(1.143)" } }, [`&${n}-loading`]: { opacity: t.opacityLoading, cursor: "default" }, [`${n}-loading-icon`]: { transition: `width ${t.motionDurationSlow} ${t.motionEaseInOut}, opacity ${t.motionDurationSlow} ${t.motionEaseInOut}` }, [`&:not(${h}) ${n}-loading-icon > ${i}`]: { marginInlineEnd: t.marginXS } } }, { [`${n}${n}-circle${e}`]: U3(t) }, { [`${n}${n}-round${e}`]: G3(t) }] }, nj = t => rm(t), ij = t => { const e = dn(t, { controlHeight: t.controlHeightSM, padding: t.paddingXS, buttonPaddingHorizontal: 8, borderRadius: t.borderRadiusSM }); return rm(e, `${t.componentCls}-sm`) }, rj = t => { const e = dn(t, { controlHeight: t.controlHeightLG, fontSize: t.fontSizeLG, borderRadius: t.borderRadiusLG }); return rm(e, `${t.componentCls}-lg`) }, oj = t => { const { componentCls: e } = t; return { [e]: { [`&${e}-block`]: { width: "100%" } } } }, sj = zn("Button", t => { const { controlTmpOutline: e, paddingContentHorizontal: n } = t, i = dn(t, { colorOutlineDefault: e, buttonPaddingHorizontal: n }); return [X3(i), ij(i), nj(i), rj(i), oj(i), tj(i), F3(i), r3(t, { focus: !1 }), V3(t)] }), lj = () => ({ prefixCls: String, size: { type: String } }), $T = pT(), dp = ue({ compatConfig: { MODE: 3 }, name: "AButtonGroup", props: lj(), setup(t, e) { let { slots: n } = e; const { prefixCls: i, direction: r } = dt("btn-group", t), [, , o] = Zl(); $T.useProvide(eo({ size: E(() => t.size) })); const s = E(() => { const { size: l } = t; let a = ""; switch (l) { case "large": a = "lg"; break; case "small": a = "sm"; break; case "middle": case void 0: break; default: ii(!l, "Button.Group", "Invalid prop `size`.") }return { [`${i.value}`]: !0, [`${i.value}-${a}`]: a, [`${i.value}-rtl`]: r.value === "rtl", [o.value]: !0 } }); return () => { var l; return $("div", { class: s.value }, [Ft((l = n.default) === null || l === void 0 ? void 0 : l.call(n))]) } } }), Ib = /^[\u4e00-\u9fa5]{2}$/, Db = Ib.test.bind(Ib); function Va(t) { return t === "text" || t === "link" } const ol = ue({ compatConfig: { MODE: 3 }, name: "AButton", inheritAttrs: !1, __ANT_BUTTON: !0, props: to(z3(), { type: "default" }), slots: Object, setup(t, e) { let { slots: n, attrs: i, emit: r, expose: o } = e; const { prefixCls: s, autoInsertSpaceInButton: l, direction: a, size: c } = dt("btn", t), [u, f] = sj(s), h = $T.useInject(), d = Hw(), p = E(() => { var _; return (_ = t.disabled) !== null && _ !== void 0 ? _ : d.value }), g = oe(null), m = oe(void 0); let v = !1; const b = oe(!1), x = oe(!1), w = E(() => l.value !== !1), { compactSize: y, compactItemClassnames: C } = AF(s, a), O = E(() => typeof t.loading == "object" && t.loading.delay ? t.loading.delay || !0 : !!t.loading); Te(O, _ => { clearTimeout(m.value), typeof O.value == "number" ? m.value = setTimeout(() => { b.value = _ }, O.value) : b.value = _ }, { immediate: !0 }); const P = E(() => { const { type: _, shape: j = "default", ghost: W, block: G, danger: ae } = t, ge = s.value, J = { large: "lg", small: "sm", middle: void 0 }, ce = y.value || (h == null ? void 0 : h.size) || c.value, Oe = ce && J[ce] || ""; return [C.value, { [f.value]: !0, [`${ge}`]: !0, [`${ge}-${j}`]: j !== "default" && j, [`${ge}-${_}`]: _, [`${ge}-${Oe}`]: Oe, [`${ge}-loading`]: b.value, [`${ge}-background-ghost`]: W && !Va(_), [`${ge}-two-chinese-chars`]: x.value && w.value, [`${ge}-block`]: G, [`${ge}-dangerous`]: !!ae, [`${ge}-rtl`]: a.value === "rtl" }] }), M = () => { const _ = g.value; if (!_ || l.value === !1) return; const j = _.textContent; v && Db(j) ? x.value || (x.value = !0) : x.value && (x.value = !1) }, A = _ => { if (b.value || p.value) { _.preventDefault(); return } r("click", _) }, B = _ => { r("mousedown", _) }, R = (_, j) => { const W = j ? " " : ""; if (_.type === rs) { let G = _.children.trim(); return Db(G) && (G = G.split("").join(W)), $("span", null, [G]) } return _ }; return hn(() => { ii(!(t.ghost && Va(t.type)), "Button", "`link` or `text` button can't be a `ghost` button.") }), vt(M), is(M), At(() => { m.value && clearTimeout(m.value) }), o({ focus: () => { var _; (_ = g.value) === null || _ === void 0 || _.focus() }, blur: () => { var _; (_ = g.value) === null || _ === void 0 || _.blur() } }), () => { var _, j; const { icon: W = (_ = n.icon) === null || _ === void 0 ? void 0 : _.call(n) } = t, G = Ft((j = n.default) === null || j === void 0 ? void 0 : j.call(n)); v = G.length === 1 && !W && !Va(t.type); const { type: ae, htmlType: ge, href: J, title: ce, target: Oe } = t, Le = b.value ? "loading" : W, Qe = S(S({}, i), { title: ce, disabled: p.value, class: [P.value, i.class, { [`${s.value}-icon-only`]: G.length === 0 && !!Le }], onClick: A, onMousedown: B }); p.value || delete Qe.disabled; const Ae = W && !b.value ? W : $(W3, { existIcon: !!W, prefixCls: s.value, loading: !!b.value }, null), U = G.map(ve => R(ve, v && w.value)); if (J !== void 0) return u($("a", ee(ee({}, Qe), {}, { href: J, target: Oe, ref: g }), [Ae, U])); let pe = $("button", ee(ee({}, Qe), {}, { ref: g, type: ge }), [Ae, U]); if (!Va(ae)) { const ve = function () { return pe }(); pe = $(Q3, { ref: "wave", disabled: !!b.value }, { default: () => [ve] }) } return u(pe) } } }); ol.Group = dp; ol.install = function (t) { return t.component(ol.name, ol), t.component(dp.name, dp), t }; var aj = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" }; const cj = aj; function Bb(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { uj(t, r, n[r]) }) } return t } function uj(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var om = function (e, n) { var i = Bb({}, e, n.attrs); return $(af, Bb({}, i, { icon: cj }), null) }; om.displayName = "EllipsisOutlined"; om.inheritAttrs = !1; const kT = om, PT = Symbol("OverrideContextKey"), AT = () => Ke(PT, void 0), fj = t => { var e, n, i; const { prefixCls: r, mode: o, selectable: s, validator: l, onClick: a, expandIcon: c } = AT() || {}; en(PT, { prefixCls: E(() => { var u, f; return (f = (u = t.prefixCls) === null || u === void 0 ? void 0 : u.value) !== null && f !== void 0 ? f : r == null ? void 0 : r.value }), mode: E(() => { var u, f; return (f = (u = t.mode) === null || u === void 0 ? void 0 : u.value) !== null && f !== void 0 ? f : o == null ? void 0 : o.value }), selectable: E(() => { var u, f; return (f = (u = t.selectable) === null || u === void 0 ? void 0 : u.value) !== null && f !== void 0 ? f : s == null ? void 0 : s.value }), validator: (e = t.validator) !== null && e !== void 0 ? e : l, onClick: (n = t.onClick) !== null && n !== void 0 ? n : a, expandIcon: (i = t.expandIcon) !== null && i !== void 0 ? i : c == null ? void 0 : c.value }) }; function hj(t, e, n, i) { let r = n ? n.call(i, t, e) : void 0; if (r !== void 0) return !!r; if (t === e) return !0; if (typeof t != "object" || !t || typeof e != "object" || !e) return !1; const o = Object.keys(t), s = Object.keys(e); if (o.length !== s.length) return !1; const l = Object.prototype.hasOwnProperty.bind(e); for (let a = 0; a < o.length; a++) { const c = o[a]; if (!l(c)) return !1; const u = t[c], f = e[c]; if (r = n ? n.call(i, u, f, c) : void 0, r === !1 || r === void 0 && u !== f) return !1 } return !0 } function Es(t, e) { return hj(Re(t), Re(e)) } const MT = Symbol("menuContextKey"), ET = t => { en(MT, t) }, Qi = () => Ke(MT), _T = Symbol("ForceRenderKey"), dj = t => { en(_T, t) }, RT = () => Ke(_T, !1), IT = Symbol("menuFirstLevelContextKey"), DT = t => { en(IT, t) }, pj = () => Ke(IT, !0), mu = ue({ compatConfig: { MODE: 3 }, name: "MenuContextProvider", inheritAttrs: !1, props: { mode: { type: String, default: void 0 }, overflowDisabled: { type: Boolean, default: void 0 } }, setup(t, e) { let { slots: n } = e; const i = Qi(), r = S({}, i); return t.mode !== void 0 && (r.mode = Rh(t, "mode")), t.overflowDisabled !== void 0 && (r.overflowDisabled = Rh(t, "overflowDisabled")), ET(r), () => { var o; return (o = n.default) === null || o === void 0 ? void 0 : o.call(n) } } }), gj = ET, mj = Symbol("siderCollapsed"), Xa = "$$__vc-menu-more__key", BT = Symbol("KeyPathContext"), sm = () => Ke(BT, { parentEventKeys: E(() => []), parentKeys: E(() => []), parentInfo: {} }), vj = (t, e, n) => { const { parentEventKeys: i, parentKeys: r } = sm(), o = E(() => [...i.value, t]), s = E(() => [...r.value, e]); return en(BT, { parentEventKeys: o, parentKeys: s, parentInfo: n }), s }, LT = Symbol("measure"), Lb = ue({ compatConfig: { MODE: 3 }, setup(t, e) { let { slots: n } = e; return en(LT, !0), () => { var i; return (i = n.default) === null || i === void 0 ? void 0 : i.call(n) } } }), lm = () => Ke(LT, !1), yj = vj; function QT(t) { const { mode: e, rtl: n, inlineIndent: i } = Qi(); return E(() => e.value !== "inline" ? null : n.value ? { paddingRight: `${t.value * i.value}px` } : { paddingLeft: `${t.value * i.value}px` }) } let bj = 0; const Oj = () => ({ id: String, role: String, disabled: Boolean, danger: Boolean, title: { type: [String, Boolean], default: void 0 }, icon: ne.any, onMouseenter: Function, onMouseleave: Function, onClick: Function, onKeydown: Function, onFocus: Function, originItemValue: zt() }), ts = ue({ compatConfig: { MODE: 3 }, name: "AMenuItem", inheritAttrs: !1, props: Oj(), slots: Object, setup(t, e) { let { slots: n, emit: i, attrs: r } = e; const o = vr(), s = lm(), l = typeof o.vnode.key == "symbol" ? String(o.vnode.key) : o.vnode.key; ii(typeof o.vnode.key != "symbol", "MenuItem", `MenuItem \`:key="${String(l)}"\` not support Symbol type`); const a = `menu_item_${++bj}_$$_${l}`, { parentEventKeys: c, parentKeys: u } = sm(), { prefixCls: f, activeKeys: h, disabled: d, changeActiveKeys: p, rtl: g, inlineCollapsed: m, siderCollapsed: v, onItemClick: b, selectedKeys: x, registerMenuInfo: w, unRegisterMenuInfo: y } = Qi(), C = pj(), O = oe(!1), P = E(() => [...u.value, l]); w(a, { eventKey: a, key: l, parentEventKeys: c, parentKeys: u, isLeaf: !0 }), At(() => { y(a) }), Te(h, () => { O.value = !!h.value.find(J => J === l) }, { immediate: !0 }); const A = E(() => d.value || t.disabled), B = E(() => x.value.includes(l)), R = E(() => { const J = `${f.value}-item`; return { [`${J}`]: !0, [`${J}-danger`]: t.danger, [`${J}-active`]: O.value, [`${J}-selected`]: B.value, [`${J}-disabled`]: A.value } }), X = J => ({ key: l, eventKey: a, keyPath: P.value, eventKeyPath: [...c.value, a], domEvent: J, item: S(S({}, t), r) }), K = J => { if (A.value) return; const ce = X(J); i("click", J), b(ce) }, _ = J => { A.value || (p(P.value), i("mouseenter", J)) }, j = J => { A.value || (p([]), i("mouseleave", J)) }, W = J => { if (i("keydown", J), J.which === Mn.ENTER) { const ce = X(J); i("click", J), b(ce) } }, G = J => { p(P.value), i("focus", J) }, ae = (J, ce) => { const Oe = $("span", { class: `${f.value}-title-content` }, [ce]); return (!J || Gu(ce) && ce.type === "span") && ce && m.value && C && typeof ce == "string" ? $("div", { class: `${f.value}-inline-collapsed-noicon` }, [ce.charAt(0)]) : Oe }, ge = QT(E(() => P.value.length)); return () => { var J, ce, Oe, Le, Qe; if (s) return null; const Ae = (J = t.title) !== null && J !== void 0 ? J : (ce = n.title) === null || ce === void 0 ? void 0 : ce.call(n), U = Ft((Oe = n.default) === null || Oe === void 0 ? void 0 : Oe.call(n)), pe = U.length; let ve = Ae; typeof Ae > "u" ? ve = C && pe ? U : "" : Ae === !1 && (ve = ""); const Pe = { title: ve }; !v.value && !m.value && (Pe.title = null, Pe.open = !1); const Ie = {}; t.role === "option" && (Ie["aria-selected"] = B.value); const Me = (Le = t.icon) !== null && Le !== void 0 ? Le : (Qe = n.icon) === null || Qe === void 0 ? void 0 : Qe.call(n, t); return $($3, ee(ee({}, Pe), {}, { placement: g.value ? "left" : "right", overlayClassName: `${f.value}-inline-collapsed-tooltip` }), { default: () => [$(il.Item, ee(ee(ee({ component: "li" }, r), {}, { id: t.id, style: S(S({}, r.style || {}), ge.value), class: [R.value, { [`${r.class}`]: !!r.class, [`${f.value}-item-only-child`]: (Me ? pe + 1 : pe) === 1 }], role: t.role || "menuitem", tabindex: t.disabled ? null : -1, "data-menu-id": l, "aria-disabled": t.disabled }, Ie), {}, { onMouseenter: _, onMouseleave: j, onClick: K, onKeydown: W, onFocus: G, title: typeof Ae == "string" ? Ae : void 0 }), { default: () => [ai(typeof Me == "function" ? Me(t.originItemValue) : Me, { class: `${f.value}-item-icon` }, !1), ae(Me, U)] })] }) } } }), nr = { adjustX: 1, adjustY: 1 }, Sj = { topLeft: { points: ["bl", "tl"], overflow: nr, offset: [0, -7] }, bottomLeft: { points: ["tl", "bl"], overflow: nr, offset: [0, 7] }, leftTop: { points: ["tr", "tl"], overflow: nr, offset: [-4, 0] }, rightTop: { points: ["tl", "tr"], overflow: nr, offset: [4, 0] } }, xj = { topLeft: { points: ["bl", "tl"], overflow: nr, offset: [0, -7] }, bottomLeft: { points: ["tl", "bl"], overflow: nr, offset: [0, 7] }, rightTop: { points: ["tr", "tl"], overflow: nr, offset: [-4, 0] }, leftTop: { points: ["tl", "tr"], overflow: nr, offset: [4, 0] } }, wj = { horizontal: "bottomLeft", vertical: "rightTop", "vertical-left": "rightTop", "vertical-right": "leftTop" }, Qb = ue({ compatConfig: { MODE: 3 }, name: "PopupTrigger", inheritAttrs: !1, props: { prefixCls: String, mode: String, visible: Boolean, popupClassName: String, popupOffset: Array, disabled: Boolean, onVisibleChange: Function }, slots: Object, emits: ["visibleChange"], setup(t, e) { let { slots: n, emit: i } = e; const r = oe(!1), { getPopupContainer: o, rtl: s, subMenuOpenDelay: l, subMenuCloseDelay: a, builtinPlacements: c, triggerSubMenuAction: u, forceSubMenuRender: f, motion: h, defaultMotions: d, rootClassName: p } = Qi(), g = RT(), m = E(() => s.value ? S(S({}, xj), c.value) : S(S({}, Sj), c.value)), v = E(() => wj[t.mode]), b = oe(); Te(() => t.visible, y => { nt.cancel(b.value), b.value = nt(() => { r.value = y }) }, { immediate: !0 }), At(() => { nt.cancel(b.value) }); const x = y => { i("visibleChange", y) }, w = E(() => { var y, C; const O = h.value || ((y = d.value) === null || y === void 0 ? void 0 : y[t.mode]) || ((C = d.value) === null || C === void 0 ? void 0 : C.other), P = typeof O == "function" ? O() : O; return P ? eT(P.name, { css: !0 }) : void 0 }); return () => { const { prefixCls: y, popupClassName: C, mode: O, popupOffset: P, disabled: M } = t; return $(Xg, { prefixCls: y, popupClassName: ke(`${y}-popup`, { [`${y}-rtl`]: s.value }, C, p.value), stretch: O === "horizontal" ? "minWidth" : null, getPopupContainer: o.value, builtinPlacements: m.value, popupPlacement: v.value, popupVisible: r.value, popupAlign: P && { offset: P }, action: M ? [] : [u.value], mouseEnterDelay: l.value, mouseLeaveDelay: a.value, onPopupVisibleChange: x, forceRender: g || f.value, popupAnimation: w.value }, { popup: n.popup, default: n.default }) } } }), NT = (t, e) => { let { slots: n, attrs: i } = e; var r; const { prefixCls: o, mode: s } = Qi(); return $("ul", ee(ee({}, i), {}, { class: ke(o.value, `${o.value}-sub`, `${o.value}-${s.value === "inline" ? "inline" : "vertical"}`), "data-menu-list": !0 }), [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]) }; NT.displayName = "SubMenuList"; const zT = NT, Cj = ue({ compatConfig: { MODE: 3 }, name: "InlineSubMenuList", inheritAttrs: !1, props: { id: String, open: Boolean, keyPath: Array }, setup(t, e) { let { slots: n } = e; const i = E(() => "inline"), { motion: r, mode: o, defaultMotions: s } = Qi(), l = E(() => o.value === i.value), a = he(!l.value), c = E(() => l.value ? t.open : !1); Te(o, () => { l.value && (a.value = !1) }, { flush: "post" }); const u = E(() => { var f, h; const d = r.value || ((f = s.value) === null || f === void 0 ? void 0 : f[i.value]) || ((h = s.value) === null || h === void 0 ? void 0 : h.other), p = typeof d == "function" ? d() : d; return S(S({}, p), { appear: t.keyPath.length <= 1 }) }); return () => { var f; return a.value ? null : $(mu, { mode: i.value }, { default: () => [$(os, u.value, { default: () => [Bp($(zT, { id: t.id }, { default: () => [(f = n.default) === null || f === void 0 ? void 0 : f.call(n)] }), [[g1, c.value]])] })] }) } } }); let Nb = 0; const Tj = () => ({ icon: ne.any, title: ne.any, disabled: Boolean, level: Number, popupClassName: String, popupOffset: Array, internalPopupClose: Boolean, eventKey: String, expandIcon: Function, theme: String, onMouseenter: Function, onMouseleave: Function, onTitleClick: Function, originItemValue: zt() }), ns = ue({ compatConfig: { MODE: 3 }, name: "ASubMenu", inheritAttrs: !1, props: Tj(), slots: Object, setup(t, e) { let { slots: n, attrs: i, emit: r } = e; var o, s; DT(!1); const l = lm(), a = vr(), c = typeof a.vnode.key == "symbol" ? String(a.vnode.key) : a.vnode.key; ii(typeof a.vnode.key != "symbol", "SubMenu", `SubMenu \`:key="${String(c)}"\` not support Symbol type`); const u = jd(c) ? c : `sub_menu_${++Nb}_$$_not_set_key`, f = (o = t.eventKey) !== null && o !== void 0 ? o : jd(c) ? `sub_menu_${++Nb}_$$_${c}` : u, { parentEventKeys: h, parentInfo: d, parentKeys: p } = sm(), g = E(() => [...p.value, u]), m = oe([]), v = { eventKey: f, key: u, parentEventKeys: h, childrenEventKeys: m, parentKeys: p }; (s = d.childrenEventKeys) === null || s === void 0 || s.value.push(f), At(() => { var I; d.childrenEventKeys && (d.childrenEventKeys.value = (I = d.childrenEventKeys) === null || I === void 0 ? void 0 : I.value.filter(Q => Q != f)) }), yj(f, u, v); const { prefixCls: b, activeKeys: x, disabled: w, changeActiveKeys: y, mode: C, inlineCollapsed: O, openKeys: P, overflowDisabled: M, onOpenChange: A, registerMenuInfo: B, unRegisterMenuInfo: R, selectedSubMenuKeys: X, expandIcon: K, theme: _ } = Qi(), j = c != null, W = !l && (RT() || !j); dj(W), (l && j || !l && !j || W) && (B(f, v), At(() => { R(f) })); const G = E(() => `${b.value}-submenu`), ae = E(() => w.value || t.disabled), ge = oe(), J = oe(), ce = E(() => P.value.includes(u)), Oe = E(() => !M.value && ce.value), Le = E(() => X.value.includes(u)), Qe = oe(!1); Te(x, () => { Qe.value = !!x.value.find(I => I === u) }, { immediate: !0 }); const Ae = I => { ae.value || (r("titleClick", I, u), C.value === "inline" && A(u, !ce.value)) }, U = I => { ae.value || (y(g.value), r("mouseenter", I)) }, pe = I => { ae.value || (y([]), r("mouseleave", I)) }, ve = QT(E(() => g.value.length)), Pe = I => { C.value !== "inline" && A(u, I) }, Ie = () => { y(g.value) }, Me = f && `${f}-popup`, T = E(() => ke(b.value, `${b.value}-${t.theme || _.value}`, t.popupClassName)), k = (I, Q) => { if (!Q) return O.value && !p.value.length && I && typeof I == "string" ? $("div", { class: `${b.value}-inline-collapsed-noicon` }, [I.charAt(0)]) : $("span", { class: `${b.value}-title-content` }, [I]); const H = Gu(I) && I.type === "span"; return $(et, null, [ai(typeof Q == "function" ? Q(t.originItemValue) : Q, { class: `${b.value}-item-icon` }, !1), H ? I : $("span", { class: `${b.value}-title-content` }, [I])]) }, D = E(() => C.value !== "inline" && g.value.length > 1 ? "vertical" : C.value), V = E(() => C.value === "horizontal" ? "vertical" : C.value), q = E(() => D.value === "horizontal" ? "vertical" : D.value), L = () => { var I, Q; const H = G.value, N = (I = t.icon) !== null && I !== void 0 ? I : (Q = n.icon) === null || Q === void 0 ? void 0 : Q.call(n, t), te = t.expandIcon || n.expandIcon || K.value, Y = k(Do(n, t, "title"), N); return $("div", { style: ve.value, class: `${H}-title`, tabindex: ae.value ? null : -1, ref: ge, title: typeof Y == "string" ? Y : null, "data-menu-id": u, "aria-expanded": Oe.value, "aria-haspopup": !0, "aria-controls": Me, "aria-disabled": ae.value, onClick: Ae, onFocus: Ie }, [Y, C.value !== "horizontal" && te ? te(S(S({}, t), { isOpen: Oe.value })) : $("i", { class: `${H}-arrow` }, null)]) }; return () => { var I; if (l) return j ? (I = n.default) === null || I === void 0 ? void 0 : I.call(n) : null; const Q = G.value; let H = () => null; if (!M.value && C.value !== "inline") { const N = C.value === "horizontal" ? [0, 8] : [10, 0]; H = () => $(Qb, { mode: D.value, prefixCls: Q, visible: !t.internalPopupClose && Oe.value, popupClassName: T.value, popupOffset: t.popupOffset || N, disabled: ae.value, onVisibleChange: Pe }, { default: () => [L()], popup: () => $(mu, { mode: q.value }, { default: () => [$(zT, { id: Me, ref: J }, { default: n.default })] }) }) } else H = () => $(Qb, null, { default: L }); return $(mu, { mode: V.value }, { default: () => [$(il.Item, ee(ee({ component: "li" }, i), {}, { role: "none", class: ke(Q, `${Q}-${C.value}`, i.class, { [`${Q}-open`]: Oe.value, [`${Q}-active`]: Qe.value, [`${Q}-selected`]: Le.value, [`${Q}-disabled`]: ae.value }), onMouseenter: U, onMouseleave: pe, "data-submenu-id": u }), { default: () => $(et, null, [H(), !M.value && $(Cj, { id: Me, open: Oe.value, keyPath: g.value }, { default: n.default })]) })] }) } } }); function WT(t, e) { return t.classList ? t.classList.contains(e) : ` ${t.className} `.indexOf(` ${e} `) > -1 } function zb(t, e) { t.classList ? t.classList.add(e) : WT(t, e) || (t.className = `${t.className} ${e}`) } function Wb(t, e) { if (t.classList) t.classList.remove(e); else if (WT(t, e)) { const n = t.className; t.className = ` ${n} `.replace(` ${e} `, " ") } } const $j = function () { let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; return { name: t, appear: e, css: !0, onBeforeEnter: n => { n.style.height = "0px", n.style.opacity = "0", zb(n, t) }, onEnter: n => { ri(() => { n.style.height = `${n.scrollHeight}px`, n.style.opacity = "1" }) }, onAfterEnter: n => { n && (Wb(n, t), n.style.height = null, n.style.opacity = null) }, onBeforeLeave: n => { zb(n, t), n.style.height = `${n.offsetHeight}px`, n.style.opacity = null }, onLeave: n => { setTimeout(() => { n.style.height = "0px", n.style.opacity = "0" }) }, onAfterLeave: n => { n && (Wb(n, t), n.style && (n.style.height = null, n.style.opacity = null)) } } }, kj = $j, Pj = () => ({ title: ne.any, originItemValue: zt() }), vu = ue({ compatConfig: { MODE: 3 }, name: "AMenuItemGroup", inheritAttrs: !1, props: Pj(), slots: Object, setup(t, e) { let { slots: n, attrs: i } = e; const { prefixCls: r } = Qi(), o = E(() => `${r.value}-item-group`), s = lm(); return () => { var l, a; return s ? (l = n.default) === null || l === void 0 ? void 0 : l.call(n) : $("li", ee(ee({}, i), {}, { onClick: c => c.stopPropagation(), class: o.value }), [$("div", { title: typeof t.title == "string" ? t.title : void 0, class: `${o.value}-title` }, [Do(n, t, "title")]), $("ul", { class: `${o.value}-list` }, [(a = n.default) === null || a === void 0 ? void 0 : a.call(n)])]) } } }), Aj = () => ({ prefixCls: String, dashed: Boolean }), yu = ue({ compatConfig: { MODE: 3 }, name: "AMenuDivider", props: Aj(), setup(t) { const { prefixCls: e } = Qi(), n = E(() => ({ [`${e.value}-item-divider`]: !0, [`${e.value}-item-divider-dashed`]: !!t.dashed })); return () => $("li", { class: n.value }, null) } }); var Mj = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; function pp(t, e, n) { return (t || []).map((i, r) => { if (i && typeof i == "object") { const o = i, { label: s, children: l, key: a, type: c } = o, u = Mj(o, ["label", "children", "key", "type"]), f = a ?? `tmp-${r}`, h = n ? n.parentKeys.slice() : [], d = [], p = { eventKey: f, key: f, parentEventKeys: he(h), parentKeys: he(h), childrenEventKeys: he(d), isLeaf: !1 }; if (l || c === "group") { if (c === "group") { const m = pp(l, e, n); return $(vu, ee(ee({ key: f }, u), {}, { title: s, originItemValue: i }), { default: () => [m] }) } e.set(f, p), n && n.childrenEventKeys.push(f); const g = pp(l, e, { childrenEventKeys: d, parentKeys: [].concat(h, f) }); return $(ns, ee(ee({ key: f }, u), {}, { title: s, originItemValue: i }), { default: () => [g] }) } return c === "divider" ? $(yu, ee({ key: f }, u), null) : (p.isLeaf = !0, e.set(f, p), $(ts, ee(ee({ key: f }, u), {}, { originItemValue: i }), { default: () => [s] })) } return null }).filter(i => i) } function Ej(t) { const e = oe([]), n = oe(!1), i = oe(new Map); return Te(() => t.items, () => { const r = new Map; n.value = !1, t.items ? (n.value = !0, e.value = pp(t.items, r)) : e.value = void 0, i.value = r }, { immediate: !0, deep: !0 }), { itemsNodes: e, store: i, hasItmes: n } } const _j = t => {
        const { componentCls: e, motionDurationSlow: n, menuHorizontalHeight: i, colorSplit: r, lineWidth: o, lineType: s, menuItemPaddingInline: l } = t; return {
            [`${e}-horizontal`]: {
                lineHeight: `${i}px`, border: 0, borderBottom: `${o}px ${s} ${r}`, boxShadow: "none", "&::after": { display: "block", clear: "both", height: 0, content: '"\\20"' }, [`${e}-item, ${e}-submenu`]: { position: "relative", display: "inline-block", verticalAlign: "bottom", paddingInline: l }, [`> ${e}-item:hover,
        > ${e}-item-active,
        > ${e}-submenu ${e}-submenu-title:hover`]: { backgroundColor: "transparent" }, [`${e}-item, ${e}-submenu-title`]: { transition: [`border-color ${n}`, `background ${n}`].join(",") }, [`${e}-submenu-arrow`]: { display: "none" }
            }
        }
    }, Rj = _j, Ij = t => {
        let { componentCls: e, menuArrowOffset: n } = t; return {
            [`${e}-rtl`]: { direction: "rtl" }, [`${e}-submenu-rtl`]: { transformOrigin: "100% 0" }, [`${e}-rtl${e}-vertical,
    ${e}-submenu-rtl ${e}-vertical`]: { [`${e}-submenu-arrow`]: { "&::before": { transform: `rotate(-45deg) translateY(-${n})` }, "&::after": { transform: `rotate(45deg) translateY(${n})` } } }
        }
    }, Dj = Ij, Hb = t => S({}, dC(t)), Bj = (t, e) => { const { componentCls: n, colorItemText: i, colorItemTextSelected: r, colorGroupTitle: o, colorItemBg: s, colorSubItemBg: l, colorItemBgSelected: a, colorActiveBarHeight: c, colorActiveBarWidth: u, colorActiveBarBorderSize: f, motionDurationSlow: h, motionEaseInOut: d, motionEaseOut: p, menuItemPaddingInline: g, motionDurationMid: m, colorItemTextHover: v, lineType: b, colorSplit: x, colorItemTextDisabled: w, colorDangerItemText: y, colorDangerItemTextHover: C, colorDangerItemTextSelected: O, colorDangerItemBgActive: P, colorDangerItemBgSelected: M, colorItemBgHover: A, menuSubMenuBg: B, colorItemTextSelectedHorizontal: R, colorItemBgSelectedHorizontal: X } = t; return { [`${n}-${e}`]: { color: i, background: s, [`&${n}-root:focus-visible`]: S({}, Hb(t)), [`${n}-item-group-title`]: { color: o }, [`${n}-submenu-selected`]: { [`> ${n}-submenu-title`]: { color: r } }, [`${n}-item-disabled, ${n}-submenu-disabled`]: { color: `${w} !important` }, [`${n}-item:hover, ${n}-submenu-title:hover`]: { [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: { color: v } }, [`&:not(${n}-horizontal)`]: { [`${n}-item:not(${n}-item-selected)`]: { "&:hover": { backgroundColor: A }, "&:active": { backgroundColor: a } }, [`${n}-submenu-title`]: { "&:hover": { backgroundColor: A }, "&:active": { backgroundColor: a } } }, [`${n}-item-danger`]: { color: y, [`&${n}-item:hover`]: { [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: { color: C } }, [`&${n}-item:active`]: { background: P } }, [`${n}-item a`]: { "&, &:hover": { color: "inherit" } }, [`${n}-item-selected`]: { color: r, [`&${n}-item-danger`]: { color: O }, ["a, a:hover"]: { color: "inherit" } }, [`& ${n}-item-selected`]: { backgroundColor: a, [`&${n}-item-danger`]: { backgroundColor: M } }, [`${n}-item, ${n}-submenu-title`]: { [`&:not(${n}-item-disabled):focus-visible`]: S({}, Hb(t)) }, [`&${n}-submenu > ${n}`]: { backgroundColor: B }, [`&${n}-popup > ${n}`]: { backgroundColor: s }, [`&${n}-horizontal`]: S(S({}, e === "dark" ? { borderBottom: 0 } : {}), { [`> ${n}-item, > ${n}-submenu`]: { top: f, marginTop: -f, marginBottom: 0, borderRadius: 0, "&::after": { position: "absolute", insetInline: g, bottom: 0, borderBottom: `${c}px solid transparent`, transition: `border-color ${h} ${d}`, content: '""' }, ["&:hover, &-active, &-open"]: { "&::after": { borderBottomWidth: c, borderBottomColor: R } }, ["&-selected"]: { color: R, backgroundColor: X, "&::after": { borderBottomWidth: c, borderBottomColor: R } } } }), [`&${n}-root`]: { [`&${n}-inline, &${n}-vertical`]: { borderInlineEnd: `${f}px ${b} ${x}` } }, [`&${n}-inline`]: { [`${n}-sub${n}-inline`]: { background: l }, [`${n}-item, ${n}-submenu-title`]: f && u ? { width: `calc(100% + ${f}px)` } : {}, [`${n}-item`]: { position: "relative", "&::after": { position: "absolute", insetBlock: 0, insetInlineEnd: 0, borderInlineEnd: `${u}px solid ${r}`, transform: "scaleY(0.0001)", opacity: 0, transition: [`transform ${m} ${p}`, `opacity ${m} ${p}`].join(","), content: '""' }, [`&${n}-item-danger`]: { "&::after": { borderInlineEndColor: O } } }, [`${n}-selected, ${n}-item-selected`]: { "&::after": { transform: "scaleY(1)", opacity: 1, transition: [`transform ${m} ${d}`, `opacity ${m} ${d}`].join(",") } } } } } }, Fb = Bj, jb = t => {
        const { componentCls: e, menuItemHeight: n, itemMarginInline: i, padding: r, menuArrowSize: o, marginXS: s, marginXXS: l } = t, a = r + o + s; return {
            [`${e}-item`]: { position: "relative" }, [`${e}-item, ${e}-submenu-title`]: { height: n, lineHeight: `${n}px`, paddingInline: r, overflow: "hidden", textOverflow: "ellipsis", marginInline: i, marginBlock: l, width: `calc(100% - ${i * 2}px)` }, [`${e}-submenu`]: { paddingBottom: .02 }, [`> ${e}-item,
            > ${e}-submenu > ${e}-submenu-title`]: { height: n, lineHeight: `${n}px` }, [`${e}-item-group-list ${e}-submenu-title,
            ${e}-submenu-title`]: { paddingInlineEnd: a }
        }
    }, Lj = t => {
        const { componentCls: e, iconCls: n, menuItemHeight: i, colorTextLightSolid: r, dropdownWidth: o, controlHeightLG: s, motionDurationMid: l, motionEaseOut: a, paddingXL: c, fontSizeSM: u, fontSizeLG: f, motionDurationSlow: h, paddingXS: d, boxShadowSecondary: p } = t, g = { height: i, lineHeight: `${i}px`, listStylePosition: "inside", listStyleType: "disc" }; return [{ [e]: { ["&-inline, &-vertical"]: S({ [`&${e}-root`]: { boxShadow: "none" } }, jb(t)) }, [`${e}-submenu-popup`]: { [`${e}-vertical`]: S(S({}, jb(t)), { boxShadow: p }) } }, { [`${e}-submenu-popup ${e}-vertical${e}-sub`]: { minWidth: o, maxHeight: `calc(100vh - ${s * 2.5}px)`, padding: "0", overflow: "hidden", borderInlineEnd: 0, "&:not([class*='-active'])": { overflowX: "hidden", overflowY: "auto" } } }, { [`${e}-inline`]: { width: "100%", [`&${e}-root`]: { [`${e}-item, ${e}-submenu-title`]: { display: "flex", alignItems: "center", transition: [`border-color ${h}`, `background ${h}`, `padding ${l} ${a}`].join(","), [`> ${e}-title-content`]: { flex: "auto", minWidth: 0, overflow: "hidden", textOverflow: "ellipsis" }, "> *": { flex: "none" } } }, [`${e}-sub${e}-inline`]: { padding: 0, border: 0, borderRadius: 0, boxShadow: "none", [`& > ${e}-submenu > ${e}-submenu-title`]: g, [`& ${e}-item-group-title`]: { paddingInlineStart: c } }, [`${e}-item`]: g } }, {
            [`${e}-inline-collapsed`]: {
                width: i * 2, [`&${e}-root`]: { [`${e}-item, ${e}-submenu ${e}-submenu-title`]: { [`> ${e}-inline-collapsed-noicon`]: { fontSize: f, textAlign: "center" } } }, [`> ${e}-item,
          > ${e}-item-group > ${e}-item-group-list > ${e}-item,
          > ${e}-item-group > ${e}-item-group-list > ${e}-submenu > ${e}-submenu-title,
          > ${e}-submenu > ${e}-submenu-title`]: {
                    insetInlineStart: 0, paddingInline: `calc(50% - ${u}px)`, textOverflow: "clip", [`
            ${e}-submenu-arrow,
            ${e}-submenu-expand-icon
          `]: { opacity: 0 }, [`${e}-item-icon, ${n}`]: { margin: 0, fontSize: f, lineHeight: `${i}px`, "+ span": { display: "inline-block", opacity: 0 } }
                }, [`${e}-item-icon, ${n}`]: { display: "inline-block" }, "&-tooltip": { pointerEvents: "none", [`${e}-item-icon, ${n}`]: { display: "none" }, "a, a:hover": { color: r } }, [`${e}-item-group-title`]: S(S({}, ef), { paddingInline: d })
            }
        }]
    }, Qj = Lj, qb = t => { const { componentCls: e, fontSize: n, motionDurationSlow: i, motionDurationMid: r, motionEaseInOut: o, motionEaseOut: s, iconCls: l, controlHeightSM: a } = t; return { [`${e}-item, ${e}-submenu-title`]: { position: "relative", display: "block", margin: 0, whiteSpace: "nowrap", cursor: "pointer", transition: [`border-color ${i}`, `background ${i}`, `padding ${i} ${o}`].join(","), [`${e}-item-icon, ${l}`]: { minWidth: n, fontSize: n, transition: [`font-size ${r} ${s}`, `margin ${i} ${o}`, `color ${i}`].join(","), "+ span": { marginInlineStart: a - n, opacity: 1, transition: [`opacity ${i} ${o}`, `margin ${i}`, `color ${i}`].join(",") } }, [`${e}-item-icon`]: S({}, LL()), [`&${e}-item-only-child`]: { [`> ${l}, > ${e}-item-icon`]: { marginInlineEnd: 0 } } }, [`${e}-item-disabled, ${e}-submenu-disabled`]: { background: "none !important", cursor: "not-allowed", "&::after": { borderColor: "transparent !important" }, a: { color: "inherit !important" }, [`> ${e}-submenu-title`]: { color: "inherit !important", cursor: "not-allowed" } } } }, Vb = t => { const { componentCls: e, motionDurationSlow: n, motionEaseInOut: i, borderRadius: r, menuArrowSize: o, menuArrowOffset: s } = t; return { [`${e}-submenu`]: { ["&-expand-icon, &-arrow"]: { position: "absolute", top: "50%", insetInlineEnd: t.margin, width: o, color: "currentcolor", transform: "translateY(-50%)", transition: `transform ${n} ${i}, opacity ${n}` }, "&-arrow": { "&::before, &::after": { position: "absolute", width: o * .6, height: o * .15, backgroundColor: "currentcolor", borderRadius: r, transition: [`background ${n} ${i}`, `transform ${n} ${i}`, `top ${n} ${i}`, `color ${n} ${i}`].join(","), content: '""' }, "&::before": { transform: `rotate(45deg) translateY(-${s})` }, "&::after": { transform: `rotate(-45deg) translateY(${s})` } } } } }, Nj = t => {
        const { antCls: e, componentCls: n, fontSize: i, motionDurationSlow: r, motionDurationMid: o, motionEaseInOut: s, lineHeight: l, paddingXS: a, padding: c, colorSplit: u, lineWidth: f, zIndexPopup: h, borderRadiusLG: d, radiusSubMenuItem: p, menuArrowSize: g, menuArrowOffset: m, lineType: v, menuPanelMaskInset: b } = t; return [{ "": { [`${n}`]: S(S({}, Zo()), { ["&-hidden"]: { display: "none" } }) }, [`${n}-submenu-hidden`]: { display: "none" } }, {
            [n]: S(S(S(S(S(S(S({}, Yl(t)), Zo()), { marginBottom: 0, paddingInlineStart: 0, fontSize: i, lineHeight: 0, listStyle: "none", outline: "none", transition: `width ${r} cubic-bezier(0.2, 0, 0, 1) 0s`, ["ul, ol"]: { margin: 0, padding: 0, listStyle: "none" }, ["&-overflow"]: { display: "flex", [`${n}-item`]: { flex: "none" } }, [`${n}-item, ${n}-submenu, ${n}-submenu-title`]: { borderRadius: t.radiusItem }, [`${n}-item-group-title`]: { padding: `${a}px ${c}px`, fontSize: i, lineHeight: l, transition: `all ${r}` }, [`&-horizontal ${n}-submenu`]: { transition: [`border-color ${r} ${s}`, `background ${r} ${s}`].join(",") }, [`${n}-submenu, ${n}-submenu-inline`]: { transition: [`border-color ${r} ${s}`, `background ${r} ${s}`, `padding ${o} ${s}`].join(",") }, [`${n}-submenu ${n}-sub`]: { cursor: "initial", transition: [`background ${r} ${s}`, `padding ${r} ${s}`].join(",") }, [`${n}-title-content`]: { transition: `color ${r}` }, [`${n}-item a`]: { "&::before": { position: "absolute", inset: 0, backgroundColor: "transparent", content: '""' } }, [`${n}-item-divider`]: { overflow: "hidden", lineHeight: 0, borderColor: u, borderStyle: v, borderWidth: 0, borderTopWidth: f, marginBlock: f, padding: 0, "&-dashed": { borderStyle: "dashed" } } }), qb(t)), { [`${n}-item-group`]: { [`${n}-item-group-list`]: { margin: 0, padding: 0, [`${n}-item, ${n}-submenu-title`]: { paddingInline: `${i * 2}px ${c}px` } } }, "&-submenu": { "&-popup": { position: "absolute", zIndex: h, background: "transparent", borderRadius: d, boxShadow: "none", transformOrigin: "0 0", "&::before": { position: "absolute", inset: `${b}px 0 0`, zIndex: -1, width: "100%", height: "100%", opacity: 0, content: '""' } }, "&-placement-rightTop::before": { top: 0, insetInlineStart: b }, [`> ${n}`]: S(S(S({ borderRadius: d }, qb(t)), Vb(t)), { [`${n}-item, ${n}-submenu > ${n}-submenu-title`]: { borderRadius: p }, [`${n}-submenu-title::after`]: { transition: `transform ${r} ${s}` } }) } }), Vb(t)), {
                [`&-inline-collapsed ${n}-submenu-arrow,
        &-inline ${n}-submenu-arrow`]: { "&::before": { transform: `rotate(-45deg) translateX(${m})` }, "&::after": { transform: `rotate(45deg) translateX(-${m})` } }, [`${n}-submenu-open${n}-submenu-inline > ${n}-submenu-title > ${n}-submenu-arrow`]: { transform: `translateY(-${g * .2}px)`, "&::after": { transform: `rotate(-45deg) translateX(-${m})` }, "&::before": { transform: `rotate(45deg) translateX(${m})` } }
            })
        }, { [`${e}-layout-header`]: { [n]: { lineHeight: "inherit" } } }]
    }, zj = (t, e) => zn("Menu", (i, r) => { let { overrideComponentToken: o } = r; if ((e == null ? void 0 : e.value) === !1) return []; const { colorBgElevated: s, colorPrimary: l, colorError: a, colorErrorHover: c, colorTextLightSolid: u } = i, { controlHeightLG: f, fontSize: h } = i, d = h / 7 * 5, p = dn(i, { menuItemHeight: f, menuItemPaddingInline: i.margin, menuArrowSize: d, menuHorizontalHeight: f * 1.15, menuArrowOffset: `${d * .25}px`, menuPanelMaskInset: -7, menuSubMenuBg: s }), g = new _t(u).setAlpha(.65).toRgbString(), m = dn(p, { colorItemText: g, colorItemTextHover: u, colorGroupTitle: g, colorItemTextSelected: u, colorItemBg: "#001529", colorSubItemBg: "#000c17", colorItemBgActive: "transparent", colorItemBgSelected: l, colorActiveBarWidth: 0, colorActiveBarHeight: 0, colorActiveBarBorderSize: 0, colorItemTextDisabled: new _t(u).setAlpha(.25).toRgbString(), colorDangerItemText: a, colorDangerItemTextHover: c, colorDangerItemTextSelected: u, colorDangerItemBgActive: a, colorDangerItemBgSelected: a, menuSubMenuBg: "#001529", colorItemTextSelectedHorizontal: u, colorItemBgSelectedHorizontal: l }, S({}, o)); return [Nj(p), Rj(p), Qj(p), Fb(p, "light"), Fb(m, "dark"), Dj(p), t3(p), du(p, "slide-up"), du(p, "slide-down"), ST(p, "zoom-big")] }, i => { const { colorPrimary: r, colorError: o, colorTextDisabled: s, colorErrorBg: l, colorText: a, colorTextDescription: c, colorBgContainer: u, colorFillAlter: f, colorFillContent: h, lineWidth: d, lineWidthBold: p, controlItemBgActive: g, colorBgTextHover: m } = i; return { dropdownWidth: 160, zIndexPopup: i.zIndexPopupBase + 50, radiusItem: i.borderRadiusLG, radiusSubMenuItem: i.borderRadiusSM, colorItemText: a, colorItemTextHover: a, colorItemTextHoverHorizontal: r, colorGroupTitle: c, colorItemTextSelected: r, colorItemTextSelectedHorizontal: r, colorItemBg: u, colorItemBgHover: m, colorItemBgActive: h, colorSubItemBg: f, colorItemBgSelected: g, colorItemBgSelectedHorizontal: "transparent", colorActiveBarWidth: 0, colorActiveBarHeight: p, colorActiveBarBorderSize: d, colorItemTextDisabled: s, colorDangerItemText: o, colorDangerItemTextHover: o, colorDangerItemTextSelected: o, colorDangerItemBgActive: l, colorDangerItemBgSelected: l, itemMarginInline: i.marginXXS } })(t), Wj = () => ({ id: String, prefixCls: String, items: Array, disabled: Boolean, inlineCollapsed: Boolean, disabledOverflow: Boolean, forceSubMenuRender: Boolean, openKeys: Array, selectedKeys: Array, activeKey: String, selectable: { type: Boolean, default: !0 }, multiple: { type: Boolean, default: !1 }, tabindex: { type: [Number, String] }, motion: Object, role: String, theme: { type: String, default: "light" }, mode: { type: String, default: "vertical" }, inlineIndent: { type: Number, default: 24 }, subMenuOpenDelay: { type: Number, default: 0 }, subMenuCloseDelay: { type: Number, default: .1 }, builtinPlacements: { type: Object }, triggerSubMenuAction: { type: String, default: "hover" }, getPopupContainer: Function, expandIcon: Function, onOpenChange: Function, onSelect: Function, onDeselect: Function, onClick: [Function, Array], onFocus: Function, onBlur: Function, onMousedown: Function, "onUpdate:openKeys": Function, "onUpdate:selectedKeys": Function, "onUpdate:activeKey": Function }), Xb = [], sr = ue({ compatConfig: { MODE: 3 }, name: "AMenu", inheritAttrs: !1, props: Wj(), slots: Object, setup(t, e) { let { slots: n, emit: i, attrs: r } = e; const { direction: o, getPrefixCls: s } = dt("menu", t), l = AT(), a = E(() => { var U; return s("menu", t.prefixCls || ((U = l == null ? void 0 : l.prefixCls) === null || U === void 0 ? void 0 : U.value)) }), [c, u] = zj(a, E(() => !l)), f = oe(new Map), h = Ke(mj, he(void 0)), d = E(() => h.value !== void 0 ? h.value : t.inlineCollapsed), { itemsNodes: p } = Ej(t), g = oe(!1); vt(() => { g.value = !0 }), hn(() => { ii(!(t.inlineCollapsed === !0 && t.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline."), ii(!(h.value !== void 0 && t.inlineCollapsed === !0), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.") }); const m = he([]), v = he([]), b = he({}); Te(f, () => { const U = {}; for (const pe of f.value.values()) U[pe.key] = pe; b.value = U }, { flush: "post" }), hn(() => { if (t.activeKey !== void 0) { let U = []; const pe = t.activeKey ? b.value[t.activeKey] : void 0; pe && t.activeKey !== void 0 ? U = wh([].concat(gt(pe.parentKeys), t.activeKey)) : U = [], Es(m.value, U) || (m.value = U) } }), Te(() => t.selectedKeys, U => { U && (v.value = U.slice()) }, { immediate: !0, deep: !0 }); const x = he([]); Te([b, v], () => { let U = []; v.value.forEach(pe => { const ve = b.value[pe]; ve && (U = U.concat(gt(ve.parentKeys))) }), U = wh(U), Es(x.value, U) || (x.value = U) }, { immediate: !0 }); const w = U => { if (t.selectable) { const { key: pe } = U, ve = v.value.includes(pe); let Pe; t.multiple ? ve ? Pe = v.value.filter(Me => Me !== pe) : Pe = [...v.value, pe] : Pe = [pe]; const Ie = S(S({}, U), { selectedKeys: Pe }); Es(Pe, v.value) || (t.selectedKeys === void 0 && (v.value = Pe), i("update:selectedKeys", Pe), ve && t.multiple ? i("deselect", Ie) : i("select", Ie)) } A.value !== "inline" && !t.multiple && y.value.length && X(Xb) }, y = he([]); Te(() => t.openKeys, function () { let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : y.value; Es(y.value, U) || (y.value = U.slice()) }, { immediate: !0, deep: !0 }); let C; const O = U => { clearTimeout(C), C = setTimeout(() => { t.activeKey === void 0 && (m.value = U), i("update:activeKey", U[U.length - 1]) }) }, P = E(() => !!t.disabled), M = E(() => o.value === "rtl"), A = he("vertical"), B = oe(!1); hn(() => { var U; (t.mode === "inline" || t.mode === "vertical") && d.value ? (A.value = "vertical", B.value = d.value) : (A.value = t.mode, B.value = !1), !((U = l == null ? void 0 : l.mode) === null || U === void 0) && U.value && (A.value = l.mode.value) }); const R = E(() => A.value === "inline"), X = U => { y.value = U, i("update:openKeys", U), i("openChange", U) }, K = he(y.value), _ = oe(!1); Te(y, () => { R.value && (K.value = y.value) }, { immediate: !0 }), Te(R, () => { if (!_.value) { _.value = !0; return } R.value ? y.value = K.value : X(Xb) }, { immediate: !0 }); const j = E(() => ({ [`${a.value}`]: !0, [`${a.value}-root`]: !0, [`${a.value}-${A.value}`]: !0, [`${a.value}-inline-collapsed`]: B.value, [`${a.value}-rtl`]: M.value, [`${a.value}-${t.theme}`]: !0 })), W = E(() => s()), G = E(() => ({ horizontal: { name: `${W.value}-slide-up` }, inline: kj(`${W.value}-motion-collapse`), other: { name: `${W.value}-zoom-big` } })); DT(!0); const ae = function () { let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; const pe = [], ve = f.value; return U.forEach(Pe => { const { key: Ie, childrenEventKeys: Me } = ve.get(Pe); pe.push(Ie, ...ae(gt(Me))) }), pe }, ge = U => { var pe; i("click", U), w(U), (pe = l == null ? void 0 : l.onClick) === null || pe === void 0 || pe.call(l) }, J = (U, pe) => { var ve; const Pe = ((ve = b.value[U]) === null || ve === void 0 ? void 0 : ve.childrenEventKeys) || []; let Ie = y.value.filter(Me => Me !== U); if (pe) Ie.push(U); else if (A.value !== "inline") { const Me = ae(gt(Pe)); Ie = wh(Ie.filter(T => !Me.includes(T))) } Es(y, Ie) || X(Ie) }, ce = (U, pe) => { f.value.set(U, pe), f.value = new Map(f.value) }, Oe = U => { f.value.delete(U), f.value = new Map(f.value) }, Le = he(0), Qe = E(() => { var U; return t.expandIcon || n.expandIcon || !((U = l == null ? void 0 : l.expandIcon) === null || U === void 0) && U.value ? pe => { let ve = t.expandIcon || n.expandIcon; return ve = typeof ve == "function" ? ve(pe) : ve, ai(ve, { class: `${a.value}-submenu-expand-icon` }, !1) } : null }); gj({ prefixCls: a, activeKeys: m, openKeys: y, selectedKeys: v, changeActiveKeys: O, disabled: P, rtl: M, mode: A, inlineIndent: E(() => t.inlineIndent), subMenuCloseDelay: E(() => t.subMenuCloseDelay), subMenuOpenDelay: E(() => t.subMenuOpenDelay), builtinPlacements: E(() => t.builtinPlacements), triggerSubMenuAction: E(() => t.triggerSubMenuAction), getPopupContainer: E(() => t.getPopupContainer), inlineCollapsed: B, theme: E(() => t.theme), siderCollapsed: h, defaultMotions: E(() => g.value ? G.value : null), motion: E(() => g.value ? t.motion : null), overflowDisabled: oe(void 0), onOpenChange: J, onItemClick: ge, registerMenuInfo: ce, unRegisterMenuInfo: Oe, selectedSubMenuKeys: x, expandIcon: Qe, forceSubMenuRender: E(() => t.forceSubMenuRender), rootClassName: u }); const Ae = () => { var U; return p.value || Ft((U = n.default) === null || U === void 0 ? void 0 : U.call(n)) }; return () => { var U; const pe = Ae(), ve = Le.value >= pe.length - 1 || A.value !== "horizontal" || t.disabledOverflow, Pe = Me => A.value !== "horizontal" || t.disabledOverflow ? Me : Me.map((T, k) => $(mu, { key: T.key, overflowDisabled: k > Le.value }, { default: () => T })), Ie = ((U = n.overflowedIndicator) === null || U === void 0 ? void 0 : U.call(n)) || $(kT, null, null); return c($(il, ee(ee({}, r), {}, { onMousedown: t.onMousedown, prefixCls: `${a.value}-overflow`, component: "ul", itemComponent: ts, class: [j.value, r.class, u.value], role: "menu", id: t.id, data: Pe(pe), renderRawItem: Me => Me, renderRawRest: Me => { const T = Me.length, k = T ? pe.slice(-T) : null; return $(et, null, [$(ns, { eventKey: Xa, key: Xa, title: Ie, disabled: ve, internalPopupClose: T === 0 }, { default: () => k }), $(Lb, null, { default: () => [$(ns, { eventKey: Xa, key: Xa, title: Ie, disabled: ve, internalPopupClose: T === 0 }, { default: () => k })] })]) }, maxCount: A.value !== "horizontal" || t.disabledOverflow ? il.INVALIDATE : il.RESPONSIVE, ssr: "full", "data-menu-list": !0, onVisibleChange: Me => { Le.value = Me } }), { default: () => [$(LO, { to: "body" }, { default: () => [$("div", { style: { display: "none" }, "aria-hidden": !0 }, [$(Lb, null, { default: () => [Pe(Ae())] })])] })] })) } } }); sr.install = function (t) { return t.component(sr.name, sr), t.component(ts.name, ts), t.component(ns.name, ns), t.component(yu.name, yu), t.component(vu.name, vu), t }; sr.Item = ts; sr.Divider = yu; sr.SubMenu = ns; sr.ItemGroup = vu; function Hj(t) { const e = oe(), n = oe(!1); function i() { for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)o[s] = arguments[s]; n.value || (nt.cancel(e.value), e.value = nt(() => { t(...o) })) } return At(() => { n.value = !0, nt.cancel(e.value) }), i } function Fj(t) { const e = oe([]), n = oe(typeof t == "function" ? t() : t), i = Hj(() => { let o = n.value; e.value.forEach(s => { o = s(o) }), e.value = [], n.value = o }); function r(o) { e.value.push(o), i() } return [n, r] } const jj = ue({ compatConfig: { MODE: 3 }, name: "TabNode", props: { id: { type: String }, prefixCls: { type: String }, tab: { type: Object }, active: { type: Boolean }, closable: { type: Boolean }, editable: { type: Object }, onClick: { type: Function }, onResize: { type: Function }, renderWrapper: { type: Function }, removeAriaLabel: { type: String }, onFocus: { type: Function } }, emits: ["click", "resize", "remove", "focus"], setup(t, e) { let { expose: n, attrs: i } = e; const r = he(); function o(a) { var c; !((c = t.tab) === null || c === void 0) && c.disabled || t.onClick(a) } n({ domRef: r }); function s(a) { var c; a.preventDefault(), a.stopPropagation(), t.editable.onEdit("remove", { key: (c = t.tab) === null || c === void 0 ? void 0 : c.key, event: a }) } const l = E(() => { var a; return t.editable && t.closable !== !1 && !(!((a = t.tab) === null || a === void 0) && a.disabled) }); return () => { var a; const { prefixCls: c, id: u, active: f, tab: { key: h, tab: d, disabled: p, closeIcon: g }, renderWrapper: m, removeAriaLabel: v, editable: b, onFocus: x } = t, w = `${c}-tab`, y = $("div", { key: h, ref: r, class: ke(w, { [`${w}-with-remove`]: l.value, [`${w}-active`]: f, [`${w}-disabled`]: p }), style: i.style, onClick: o }, [$("div", { role: "tab", "aria-selected": f, id: u && `${u}-tab-${h}`, class: `${w}-btn`, "aria-controls": u && `${u}-panel-${h}`, "aria-disabled": p, tabindex: p ? null : 0, onClick: C => { C.stopPropagation(), o(C) }, onKeydown: C => { [Mn.SPACE, Mn.ENTER].includes(C.which) && (C.preventDefault(), o(C)) }, onFocus: x }, [typeof d == "function" ? d() : d]), l.value && $("button", { type: "button", "aria-label": v || "remove", tabindex: 0, class: `${w}-remove`, onClick: C => { C.stopPropagation(), s(C) } }, [(g == null ? void 0 : g()) || ((a = b.removeIcon) === null || a === void 0 ? void 0 : a.call(b)) || "×"])]); return m ? m(y) : y } } }), Ub = { width: 0, height: 0, left: 0, top: 0 }; function qj(t, e) { const n = he(new Map); return hn(() => { var i, r; const o = new Map, s = t.value, l = e.value.get((i = s[0]) === null || i === void 0 ? void 0 : i.key) || Ub, a = l.left + l.width; for (let c = 0; c < s.length; c += 1) { const { key: u } = s[c]; let f = e.value.get(u); f || (f = e.value.get((r = s[c - 1]) === null || r === void 0 ? void 0 : r.key) || Ub); const h = o.get(u) || S({}, f); h.right = a - h.left - h.width, o.set(u, h) } n.value = new Map(o) }), n } const HT = ue({ compatConfig: { MODE: 3 }, name: "AddButton", inheritAttrs: !1, props: { prefixCls: String, editable: { type: Object }, locale: { type: Object, default: void 0 } }, setup(t, e) { let { expose: n, attrs: i } = e; const r = he(); return n({ domRef: r }), () => { const { prefixCls: o, editable: s, locale: l } = t; return !s || s.showAdd === !1 ? null : $("button", { ref: r, type: "button", class: `${o}-nav-add`, style: i.style, "aria-label": (l == null ? void 0 : l.addAriaLabel) || "Add tab", onClick: a => { s.onEdit("add", { event: a }) } }, [s.addIcon ? s.addIcon() : "+"]) } } }), Vj = { prefixCls: { type: String }, id: { type: String }, tabs: { type: Object }, rtl: { type: Boolean }, tabBarGutter: { type: Number }, activeKey: { type: [String, Number] }, mobile: { type: Boolean }, moreIcon: ne.any, moreTransitionName: { type: String }, editable: { type: Object }, locale: { type: Object, default: void 0 }, removeAriaLabel: String, onTabClick: { type: Function }, popupClassName: String, getPopupContainer: An() }, Xj = ue({ compatConfig: { MODE: 3 }, name: "OperationNode", inheritAttrs: !1, props: Vj, emits: ["tabClick"], slots: Object, setup(t, e) { let { attrs: n, slots: i } = e; const [r, o] = Je(!1), [s, l] = Je(null), a = d => { const p = t.tabs.filter(v => !v.disabled); let g = p.findIndex(v => v.key === s.value) || 0; const m = p.length; for (let v = 0; v < m; v += 1) { g = (g + d + m) % m; const b = p[g]; if (!b.disabled) { l(b.key); return } } }, c = d => { const { which: p } = d; if (!r.value) { [Mn.DOWN, Mn.SPACE, Mn.ENTER].includes(p) && (o(!0), d.preventDefault()); return } switch (p) { case Mn.UP: a(-1), d.preventDefault(); break; case Mn.DOWN: a(1), d.preventDefault(); break; case Mn.ESC: o(!1); break; case Mn.SPACE: case Mn.ENTER: s.value !== null && t.onTabClick(s.value, d); break } }, u = E(() => `${t.id}-more-popup`), f = E(() => s.value !== null ? `${u.value}-${s.value}` : null), h = (d, p) => { d.preventDefault(), d.stopPropagation(), t.editable.onEdit("remove", { key: p, event: d }) }; return vt(() => { Te(s, () => { const d = document.getElementById(f.value); d && d.scrollIntoView && d.scrollIntoView(!1) }, { flush: "post", immediate: !0 }) }), Te(r, () => { r.value || l(null) }), fj({}), () => { var d; const { prefixCls: p, id: g, tabs: m, locale: v, mobile: b, moreIcon: x = ((d = i.moreIcon) === null || d === void 0 ? void 0 : d.call(i)) || $(kT, null, null), moreTransitionName: w, editable: y, tabBarGutter: C, rtl: O, onTabClick: P, popupClassName: M } = t; if (!m.length) return null; const A = `${p}-dropdown`, B = v == null ? void 0 : v.dropdownAriaLabel, R = { [O ? "marginRight" : "marginLeft"]: C }; m.length || (R.visibility = "hidden", R.order = 1); const X = ke({ [`${A}-rtl`]: O, [`${M}`]: !0 }), K = b ? null : $(M3, { prefixCls: A, trigger: ["hover"], visible: r.value, transitionName: w, onVisibleChange: o, overlayClassName: X, mouseEnterDelay: .1, mouseLeaveDelay: .1, getPopupContainer: t.getPopupContainer }, { overlay: () => $(sr, { onClick: _ => { let { key: j, domEvent: W } = _; P(j, W), o(!1) }, id: u.value, tabindex: -1, role: "listbox", "aria-activedescendant": f.value, selectedKeys: [s.value], "aria-label": B !== void 0 ? B : "expanded dropdown" }, { default: () => [m.map(_ => { var j, W; const G = y && _.closable !== !1 && !_.disabled; return $(ts, { key: _.key, id: `${u.value}-${_.key}`, role: "option", "aria-controls": g && `${g}-panel-${_.key}`, disabled: _.disabled }, { default: () => [$("span", null, [typeof _.tab == "function" ? _.tab() : _.tab]), G && $("button", { type: "button", "aria-label": t.removeAriaLabel || "remove", tabindex: 0, class: `${A}-menu-item-remove`, onClick: ae => { ae.stopPropagation(), h(ae, _.key) } }, [((j = _.closeIcon) === null || j === void 0 ? void 0 : j.call(_)) || ((W = y.removeIcon) === null || W === void 0 ? void 0 : W.call(y)) || "×"])] }) })] }), default: () => $("button", { type: "button", class: `${p}-nav-more`, style: R, tabindex: -1, "aria-hidden": "true", "aria-haspopup": "listbox", "aria-controls": u.value, id: `${g}-more`, "aria-expanded": r.value, onKeydown: c }, [x]) }); return $("div", { class: ke(`${p}-nav-operations`, n.class), style: n.style }, [K, $(HT, { prefixCls: p, locale: v, editable: y }, null)]) } } }), FT = Symbol("tabsContextKey"), Uj = t => { en(FT, t) }, jT = () => Ke(FT, { tabs: he([]), prefixCls: he() }), Gj = .1, Gb = .01, bc = 20, Kb = Math.pow(.995, bc); function Kj(t, e) { const [n, i] = Je(), [r, o] = Je(0), [s, l] = Je(0), [a, c] = Je(), u = he(); function f(y) { const { screenX: C, screenY: O } = y.touches[0]; i({ x: C, y: O }), clearInterval(u.value) } function h(y) { if (!n.value) return; y.preventDefault(); const { screenX: C, screenY: O } = y.touches[0], P = C - n.value.x, M = O - n.value.y; e(P, M), i({ x: C, y: O }); const A = Date.now(); l(A - r.value), o(A), c({ x: P, y: M }) } function d() { if (!n.value) return; const y = a.value; if (i(null), c(null), y) { const C = y.x / s.value, O = y.y / s.value, P = Math.abs(C), M = Math.abs(O); if (Math.max(P, M) < Gj) return; let A = C, B = O; u.value = setInterval(() => { if (Math.abs(A) < Gb && Math.abs(B) < Gb) { clearInterval(u.value); return } A *= Kb, B *= Kb, e(A * bc, B * bc) }, bc) } } const p = he(); function g(y) { const { deltaX: C, deltaY: O } = y; let P = 0; const M = Math.abs(C), A = Math.abs(O); M === A ? P = p.value === "x" ? C : O : M > A ? (P = C, p.value = "x") : (P = O, p.value = "y"), e(-P, -P) && y.preventDefault() } const m = he({ onTouchStart: f, onTouchMove: h, onTouchEnd: d, onWheel: g }); function v(y) { m.value.onTouchStart(y) } function b(y) { m.value.onTouchMove(y) } function x(y) { m.value.onTouchEnd(y) } function w(y) { m.value.onWheel(y) } vt(() => { var y, C; document.addEventListener("touchmove", b, { passive: !1 }), document.addEventListener("touchend", x, { passive: !1 }), (y = t.value) === null || y === void 0 || y.addEventListener("touchstart", v, { passive: !1 }), (C = t.value) === null || C === void 0 || C.addEventListener("wheel", w, { passive: !1 }) }), At(() => { document.removeEventListener("touchmove", b), document.removeEventListener("touchend", x) }) } function Yb(t, e) { const n = he(t); function i(r) { const o = typeof r == "function" ? r(n.value) : r; o !== n.value && e(o, n.value), n.value = o } return [n, i] } const Yj = () => { const t = he(new Map), e = n => i => { t.value.set(n, i) }; return XO(() => { t.value = new Map }), [e, t] }, Zj = Yj, Zb = { width: 0, height: 0, left: 0, top: 0, right: 0 }, Jj = () => ({ id: { type: String }, tabPosition: { type: String }, activeKey: { type: [String, Number] }, rtl: { type: Boolean }, animated: zt(), editable: zt(), moreIcon: ne.any, moreTransitionName: { type: String }, mobile: { type: Boolean }, tabBarGutter: { type: Number }, renderTabBar: { type: Function }, locale: zt(), popupClassName: String, getPopupContainer: An(), onTabClick: { type: Function }, onTabScroll: { type: Function } }), e8 = (t, e) => { const { offsetWidth: n, offsetHeight: i, offsetTop: r, offsetLeft: o } = t, { width: s, height: l, x: a, y: c } = t.getBoundingClientRect(); return Math.abs(s - n) < 1 ? [s, l, a - e.x, c - e.y] : [n, i, o, r] }, Jb = ue({ compatConfig: { MODE: 3 }, name: "TabNavList", inheritAttrs: !1, props: Jj(), slots: Object, emits: ["tabClick", "tabScroll"], setup(t, e) { let { attrs: n, slots: i } = e; const { tabs: r, prefixCls: o } = jT(), s = oe(), l = oe(), a = oe(), c = oe(), [u, f] = Zj(), h = E(() => t.tabPosition === "top" || t.tabPosition === "bottom"), [d, p] = Yb(0, (L, I) => { h.value && t.onTabScroll && t.onTabScroll({ direction: L > I ? "left" : "right" }) }), [g, m] = Yb(0, (L, I) => { !h.value && t.onTabScroll && t.onTabScroll({ direction: L > I ? "top" : "bottom" }) }), [v, b] = Je(0), [x, w] = Je(0), [y, C] = Je(null), [O, P] = Je(null), [M, A] = Je(0), [B, R] = Je(0), [X, K] = Fj(new Map), _ = qj(r, X), j = E(() => `${o.value}-nav-operations-hidden`), W = oe(0), G = oe(0); hn(() => { h.value ? t.rtl ? (W.value = 0, G.value = Math.max(0, v.value - y.value)) : (W.value = Math.min(0, y.value - v.value), G.value = 0) : (W.value = Math.min(0, O.value - x.value), G.value = 0) }); const ae = L => L < W.value ? W.value : L > G.value ? G.value : L, ge = oe(), [J, ce] = Je(), Oe = () => { ce(Date.now()) }, Le = () => { clearTimeout(ge.value) }, Qe = (L, I) => { L(Q => ae(Q + I)) }; Kj(s, (L, I) => { if (h.value) { if (y.value >= v.value) return !1; Qe(p, L) } else { if (O.value >= x.value) return !1; Qe(m, I) } return Le(), Oe(), !0 }), Te(J, () => { Le(), J.value && (ge.value = setTimeout(() => { ce(0) }, 100)) }); const Ae = function () { let L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : t.activeKey; const I = _.value.get(L) || { width: 0, height: 0, left: 0, right: 0, top: 0 }; if (h.value) { let Q = d.value; t.rtl ? I.right < d.value ? Q = I.right : I.right + I.width > d.value + y.value && (Q = I.right + I.width - y.value) : I.left < -d.value ? Q = -I.left : I.left + I.width > -d.value + y.value && (Q = -(I.left + I.width - y.value)), m(0), p(ae(Q)) } else { let Q = g.value; I.top < -g.value ? Q = -I.top : I.top + I.height > -g.value + O.value && (Q = -(I.top + I.height - O.value)), p(0), m(ae(Q)) } }, U = oe(0), pe = oe(0); hn(() => { let L, I, Q, H, N, te; const Y = _.value;["top", "bottom"].includes(t.tabPosition) ? (L = "width", H = y.value, N = v.value, te = M.value, I = t.rtl ? "right" : "left", Q = Math.abs(d.value)) : (L = "height", H = O.value, N = v.value, te = B.value, I = "top", Q = -g.value); let re = H; N + te > H && N < H && (re = H - te); const fe = r.value; if (!fe.length) return [U.value, pe.value] = [0, 0]; const Se = fe.length; let Ee = Se; for (let Fe = 0; Fe < Se; Fe += 1) { const je = Y.get(fe[Fe].key) || Zb; if (je[I] + je[L] > Q + re) { Ee = Fe - 1; break } } let ye = 0; for (let Fe = Se - 1; Fe >= 0; Fe -= 1)if ((Y.get(fe[Fe].key) || Zb)[I] < Q) { ye = Fe + 1; break } return [U.value, pe.value] = [ye, Ee] }); const ve = () => { K(() => { var L; const I = new Map, Q = (L = l.value) === null || L === void 0 ? void 0 : L.getBoundingClientRect(); return r.value.forEach(H => { let { key: N } = H; const te = f.value.get(N), Y = (te == null ? void 0 : te.$el) || te; if (Y) { const [re, fe, Se, Ee] = e8(Y, Q); I.set(N, { width: re, height: fe, left: Se, top: Ee }) } }), I }) }; Te(() => r.value.map(L => L.key).join("%%"), () => { ve() }, { flush: "post" }); const Pe = () => { var L, I, Q, H, N; const te = ((L = s.value) === null || L === void 0 ? void 0 : L.offsetWidth) || 0, Y = ((I = s.value) === null || I === void 0 ? void 0 : I.offsetHeight) || 0, re = ((Q = c.value) === null || Q === void 0 ? void 0 : Q.$el) || {}, fe = re.offsetWidth || 0, Se = re.offsetHeight || 0; C(te), P(Y), A(fe), R(Se); const Ee = (((H = l.value) === null || H === void 0 ? void 0 : H.offsetWidth) || 0) - fe, ye = (((N = l.value) === null || N === void 0 ? void 0 : N.offsetHeight) || 0) - Se; b(Ee), w(ye), ve() }, Ie = E(() => [...r.value.slice(0, U.value), ...r.value.slice(pe.value + 1)]), [Me, T] = Je(), k = E(() => _.value.get(t.activeKey)), D = oe(), V = () => { nt.cancel(D.value) }; Te([k, h, () => t.rtl], () => { const L = {}; k.value && (h.value ? (t.rtl ? L.right = Ts(k.value.right) : L.left = Ts(k.value.left), L.width = Ts(k.value.width)) : (L.top = Ts(k.value.top), L.height = Ts(k.value.height))), V(), D.value = nt(() => { T(L) }) }), Te([() => t.activeKey, k, _, h], () => { Ae() }, { flush: "post" }), Te([() => t.rtl, () => t.tabBarGutter, () => t.activeKey, () => r.value], () => { Pe() }, { flush: "post" }); const q = L => { let { position: I, prefixCls: Q, extra: H } = L; if (!H) return null; const N = H == null ? void 0 : H({ position: I }); return N ? $("div", { class: `${Q}-extra-content` }, [N]) : null }; return At(() => { Le(), V() }), () => { const { id: L, animated: I, activeKey: Q, rtl: H, editable: N, locale: te, tabPosition: Y, tabBarGutter: re, onTabClick: fe } = t, { class: Se, style: Ee } = n, ye = o.value, Fe = !!Ie.value.length, je = `${ye}-nav-wrap`; let Dt, Ot, Ni, ps; h.value ? H ? (Ot = d.value > 0, Dt = d.value + y.value < v.value) : (Dt = d.value < 0, Ot = -d.value + y.value < v.value) : (Ni = g.value < 0, ps = -g.value + O.value < x.value); const pt = {}; Y === "top" || Y === "bottom" ? pt[H ? "marginRight" : "marginLeft"] = typeof re == "number" ? `${re}px` : re : pt.marginTop = typeof re == "number" ? `${re}px` : re; const tn = r.value.map((so, ZT) => { const { key: gs } = so; return $(jj, { id: L, prefixCls: ye, key: gs, tab: so, style: ZT === 0 ? void 0 : pt, closable: so.closable, editable: N, active: gs === Q, removeAriaLabel: te == null ? void 0 : te.removeAriaLabel, ref: u(gs), onClick: JT => { fe(gs, JT) }, onFocus: () => { Ae(gs), Oe(), s.value && (H || (s.value.scrollLeft = 0), s.value.scrollTop = 0) } }, i) }); return $("div", { role: "tablist", class: ke(`${ye}-nav`, Se), style: Ee, onKeydown: () => { Oe() } }, [$(q, { position: "left", prefixCls: ye, extra: i.leftExtra }, null), $(nu, { onResize: Pe }, { default: () => [$("div", { class: ke(je, { [`${je}-ping-left`]: Dt, [`${je}-ping-right`]: Ot, [`${je}-ping-top`]: Ni, [`${je}-ping-bottom`]: ps }), ref: s }, [$(nu, { onResize: Pe }, { default: () => [$("div", { ref: l, class: `${ye}-nav-list`, style: { transform: `translate(${d.value}px, ${g.value}px)`, transition: J.value ? "none" : void 0 } }, [tn, $(HT, { ref: c, prefixCls: ye, locale: te, editable: N, style: S(S({}, tn.length === 0 ? void 0 : pt), { visibility: Fe ? "hidden" : null }) }, null), $("div", { class: ke(`${ye}-ink-bar`, { [`${ye}-ink-bar-animated`]: I.inkBar }), style: Me.value }, null)])] })])] }), $(Xj, ee(ee({}, t), {}, { removeAriaLabel: te == null ? void 0 : te.removeAriaLabel, ref: a, prefixCls: ye, tabs: Ie.value, class: !Fe && j.value }), bT(i, ["moreIcon"])), $(q, { position: "right", prefixCls: ye, extra: i.rightExtra }, null), $(q, { position: "right", prefixCls: ye, extra: i.tabBarExtraContent }, null)]) } } }), t8 = ue({ compatConfig: { MODE: 3 }, name: "TabPanelList", inheritAttrs: !1, props: { activeKey: { type: [String, Number] }, id: { type: String }, rtl: { type: Boolean }, animated: { type: Object, default: void 0 }, tabPosition: { type: String }, destroyInactiveTabPane: { type: Boolean } }, setup(t) { const { tabs: e, prefixCls: n } = jT(); return () => { const { id: i, activeKey: r, animated: o, tabPosition: s, rtl: l, destroyInactiveTabPane: a } = t, c = o.tabPane, u = n.value, f = e.value.findIndex(h => h.key === r); return $("div", { class: `${u}-content-holder` }, [$("div", { class: [`${u}-content`, `${u}-content-${s}`, { [`${u}-content-animated`]: c }], style: f && c ? { [l ? "marginRight" : "marginLeft"]: `-${f}00%` } : null }, [e.value.map(h => ai(h.node, { key: h.key, prefixCls: u, tabKey: h.key, id: i, animated: c, active: h.key === r, destroyInactiveTabPane: a }))])]) } } }); var n8 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" }; const i8 = n8; function eO(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(n).filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable }))), i.forEach(function (r) { r8(t, r, n[r]) }) } return t } function r8(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var am = function (e, n) { var i = eO({}, e, n.attrs); return $(af, eO({}, i, { icon: i8 }), null) }; am.displayName = "PlusOutlined"; am.inheritAttrs = !1; const o8 = am, s8 = t => { const { componentCls: e, motionDurationSlow: n } = t; return [{ [e]: { [`${e}-switch`]: { "&-appear, &-enter": { transition: "none", "&-start": { opacity: 0 }, "&-active": { opacity: 1, transition: `opacity ${n}` } }, "&-leave": { position: "absolute", transition: "none", inset: 0, "&-start": { opacity: 1 }, "&-active": { opacity: 0, transition: `opacity ${n}` } } } } }, [du(t, "slide-up"), du(t, "slide-down")]] }, l8 = s8, a8 = t => { const { componentCls: e, tabsCardHorizontalPadding: n, tabsCardHeadBackground: i, tabsCardGutter: r, colorSplit: o } = t; return { [`${e}-card`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab`]: { margin: 0, padding: n, background: i, border: `${t.lineWidth}px ${t.lineType} ${o}`, transition: `all ${t.motionDurationSlow} ${t.motionEaseInOut}` }, [`${e}-tab-active`]: { color: t.colorPrimary, background: t.colorBgContainer }, [`${e}-ink-bar`]: { visibility: "hidden" } }, [`&${e}-top, &${e}-bottom`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab + ${e}-tab`]: { marginLeft: { _skip_check_: !0, value: `${r}px` } } } }, [`&${e}-top`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab`]: { borderRadius: `${t.borderRadiusLG}px ${t.borderRadiusLG}px 0 0` }, [`${e}-tab-active`]: { borderBottomColor: t.colorBgContainer } } }, [`&${e}-bottom`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab`]: { borderRadius: `0 0 ${t.borderRadiusLG}px ${t.borderRadiusLG}px` }, [`${e}-tab-active`]: { borderTopColor: t.colorBgContainer } } }, [`&${e}-left, &${e}-right`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab + ${e}-tab`]: { marginTop: `${r}px` } } }, [`&${e}-left`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab`]: { borderRadius: { _skip_check_: !0, value: `${t.borderRadiusLG}px 0 0 ${t.borderRadiusLG}px` } }, [`${e}-tab-active`]: { borderRightColor: { _skip_check_: !0, value: t.colorBgContainer } } } }, [`&${e}-right`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab`]: { borderRadius: { _skip_check_: !0, value: `0 ${t.borderRadiusLG}px ${t.borderRadiusLG}px 0` } }, [`${e}-tab-active`]: { borderLeftColor: { _skip_check_: !0, value: t.colorBgContainer } } } } } } }, c8 = t => { const { componentCls: e, tabsHoverColor: n, dropdownEdgeChildVerticalPadding: i } = t; return { [`${e}-dropdown`]: S(S({}, Yl(t)), { position: "absolute", top: -9999, left: { _skip_check_: !0, value: -9999 }, zIndex: t.zIndexPopup, display: "block", "&-hidden": { display: "none" }, [`${e}-dropdown-menu`]: { maxHeight: t.tabsDropdownHeight, margin: 0, padding: `${i}px 0`, overflowX: "hidden", overflowY: "auto", textAlign: { _skip_check_: !0, value: "left" }, listStyleType: "none", backgroundColor: t.colorBgContainer, backgroundClip: "padding-box", borderRadius: t.borderRadiusLG, outline: "none", boxShadow: t.boxShadowSecondary, "&-item": S(S({}, ef), { display: "flex", alignItems: "center", minWidth: t.tabsDropdownWidth, margin: 0, padding: `${t.paddingXXS}px ${t.paddingSM}px`, color: t.colorText, fontWeight: "normal", fontSize: t.fontSize, lineHeight: t.lineHeight, cursor: "pointer", transition: `all ${t.motionDurationSlow}`, "> span": { flex: 1, whiteSpace: "nowrap" }, "&-remove": { flex: "none", marginLeft: { _skip_check_: !0, value: t.marginSM }, color: t.colorTextDescription, fontSize: t.fontSizeSM, background: "transparent", border: 0, cursor: "pointer", "&:hover": { color: n } }, "&:hover": { background: t.controlItemBgHover }, "&-disabled": { "&, &:hover": { color: t.colorTextDisabled, background: "transparent", cursor: "not-allowed" } } }) } }) } }, u8 = t => {
        const { componentCls: e, margin: n, colorSplit: i } = t; return {
            [`${e}-top, ${e}-bottom`]: {
                flexDirection: "column", [`> ${e}-nav, > div > ${e}-nav`]: {
                    margin: `0 0 ${n}px 0`, "&::before": { position: "absolute", right: { _skip_check_: !0, value: 0 }, left: { _skip_check_: !0, value: 0 }, borderBottom: `${t.lineWidth}px ${t.lineType} ${i}`, content: "''" }, [`${e}-ink-bar`]: {
                        height: t.lineWidthBold, "&-animated": {
                            transition: `width ${t.motionDurationSlow}, left ${t.motionDurationSlow},
            right ${t.motionDurationSlow}`
                        }
                    }, [`${e}-nav-wrap`]: { "&::before, &::after": { top: 0, bottom: 0, width: t.controlHeight }, "&::before": { left: { _skip_check_: !0, value: 0 }, boxShadow: t.boxShadowTabsOverflowLeft }, "&::after": { right: { _skip_check_: !0, value: 0 }, boxShadow: t.boxShadowTabsOverflowRight }, [`&${e}-nav-wrap-ping-left::before`]: { opacity: 1 }, [`&${e}-nav-wrap-ping-right::after`]: { opacity: 1 } }
                }
            }, [`${e}-top`]: {
                [`> ${e}-nav,
        > div > ${e}-nav`]: { "&::before": { bottom: 0 }, [`${e}-ink-bar`]: { bottom: 0 } }
            }, [`${e}-bottom`]: { [`> ${e}-nav, > div > ${e}-nav`]: { order: 1, marginTop: `${n}px`, marginBottom: 0, "&::before": { top: 0 }, [`${e}-ink-bar`]: { top: 0 } }, [`> ${e}-content-holder, > div > ${e}-content-holder`]: { order: 0 } }, [`${e}-left, ${e}-right`]: { [`> ${e}-nav, > div > ${e}-nav`]: { flexDirection: "column", minWidth: t.controlHeight * 1.25, [`${e}-tab`]: { padding: `${t.paddingXS}px ${t.paddingLG}px`, textAlign: "center" }, [`${e}-tab + ${e}-tab`]: { margin: `${t.margin}px 0 0 0` }, [`${e}-nav-wrap`]: { flexDirection: "column", "&::before, &::after": { right: { _skip_check_: !0, value: 0 }, left: { _skip_check_: !0, value: 0 }, height: t.controlHeight }, "&::before": { top: 0, boxShadow: t.boxShadowTabsOverflowTop }, "&::after": { bottom: 0, boxShadow: t.boxShadowTabsOverflowBottom }, [`&${e}-nav-wrap-ping-top::before`]: { opacity: 1 }, [`&${e}-nav-wrap-ping-bottom::after`]: { opacity: 1 } }, [`${e}-ink-bar`]: { width: t.lineWidthBold, "&-animated": { transition: `height ${t.motionDurationSlow}, top ${t.motionDurationSlow}` } }, [`${e}-nav-list, ${e}-nav-operations`]: { flex: "1 0 auto", flexDirection: "column" } } }, [`${e}-left`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-ink-bar`]: { right: { _skip_check_: !0, value: 0 } } }, [`> ${e}-content-holder, > div > ${e}-content-holder`]: { marginLeft: { _skip_check_: !0, value: `-${t.lineWidth}px` }, borderLeft: { _skip_check_: !0, value: `${t.lineWidth}px ${t.lineType} ${t.colorBorder}` }, [`> ${e}-content > ${e}-tabpane`]: { paddingLeft: { _skip_check_: !0, value: t.paddingLG } } } }, [`${e}-right`]: { [`> ${e}-nav, > div > ${e}-nav`]: { order: 1, [`${e}-ink-bar`]: { left: { _skip_check_: !0, value: 0 } } }, [`> ${e}-content-holder, > div > ${e}-content-holder`]: { order: 0, marginRight: { _skip_check_: !0, value: -t.lineWidth }, borderRight: { _skip_check_: !0, value: `${t.lineWidth}px ${t.lineType} ${t.colorBorder}` }, [`> ${e}-content > ${e}-tabpane`]: { paddingRight: { _skip_check_: !0, value: t.paddingLG } } } }
        }
    }, f8 = t => { const { componentCls: e, padding: n } = t; return { [e]: { "&-small": { [`> ${e}-nav`]: { [`${e}-tab`]: { padding: `${t.paddingXS}px 0`, fontSize: t.fontSize } } }, "&-large": { [`> ${e}-nav`]: { [`${e}-tab`]: { padding: `${n}px 0`, fontSize: t.fontSizeLG } } } }, [`${e}-card`]: { [`&${e}-small`]: { [`> ${e}-nav`]: { [`${e}-tab`]: { padding: `${t.paddingXXS * 1.5}px ${n}px` } }, [`&${e}-bottom`]: { [`> ${e}-nav ${e}-tab`]: { borderRadius: `0 0 ${t.borderRadius}px ${t.borderRadius}px` } }, [`&${e}-top`]: { [`> ${e}-nav ${e}-tab`]: { borderRadius: `${t.borderRadius}px ${t.borderRadius}px 0 0` } }, [`&${e}-right`]: { [`> ${e}-nav ${e}-tab`]: { borderRadius: { _skip_check_: !0, value: `0 ${t.borderRadius}px ${t.borderRadius}px 0` } } }, [`&${e}-left`]: { [`> ${e}-nav ${e}-tab`]: { borderRadius: { _skip_check_: !0, value: `${t.borderRadius}px 0 0 ${t.borderRadius}px` } } } }, [`&${e}-large`]: { [`> ${e}-nav`]: { [`${e}-tab`]: { padding: `${t.paddingXS}px ${n}px ${t.paddingXXS * 1.5}px` } } } } } }, h8 = t => { const { componentCls: e, tabsActiveColor: n, tabsHoverColor: i, iconCls: r, tabsHorizontalGutter: o } = t, s = `${e}-tab`; return { [s]: { position: "relative", display: "inline-flex", alignItems: "center", padding: `${t.paddingSM}px 0`, fontSize: `${t.fontSize}px`, background: "transparent", border: 0, outline: "none", cursor: "pointer", "&-btn, &-remove": S({ "&:focus:not(:focus-visible), &:active": { color: n } }, _g(t)), "&-btn": { outline: "none", transition: "all 0.3s" }, "&-remove": { flex: "none", marginRight: { _skip_check_: !0, value: -t.marginXXS }, marginLeft: { _skip_check_: !0, value: t.marginXS }, color: t.colorTextDescription, fontSize: t.fontSizeSM, background: "transparent", border: "none", outline: "none", cursor: "pointer", transition: `all ${t.motionDurationSlow}`, "&:hover": { color: t.colorTextHeading } }, "&:hover": { color: i }, [`&${s}-active ${s}-btn`]: { color: t.colorPrimary, textShadow: t.tabsActiveTextShadow }, [`&${s}-disabled`]: { color: t.colorTextDisabled, cursor: "not-allowed" }, [`&${s}-disabled ${s}-btn, &${s}-disabled ${e}-remove`]: { "&:focus, &:active": { color: t.colorTextDisabled } }, [`& ${s}-remove ${r}`]: { margin: 0 }, [r]: { marginRight: { _skip_check_: !0, value: t.marginSM } } }, [`${s} + ${s}`]: { margin: { _skip_check_: !0, value: `0 0 0 ${o}px` } } } }, d8 = t => { const { componentCls: e, tabsHorizontalGutter: n, iconCls: i, tabsCardGutter: r } = t; return { [`${e}-rtl`]: { direction: "rtl", [`${e}-nav`]: { [`${e}-tab`]: { margin: { _skip_check_: !0, value: `0 0 0 ${n}px` }, [`${e}-tab:last-of-type`]: { marginLeft: { _skip_check_: !0, value: 0 } }, [i]: { marginRight: { _skip_check_: !0, value: 0 }, marginLeft: { _skip_check_: !0, value: `${t.marginSM}px` } }, [`${e}-tab-remove`]: { marginRight: { _skip_check_: !0, value: `${t.marginXS}px` }, marginLeft: { _skip_check_: !0, value: `-${t.marginXXS}px` }, [i]: { margin: 0 } } } }, [`&${e}-left`]: { [`> ${e}-nav`]: { order: 1 }, [`> ${e}-content-holder`]: { order: 0 } }, [`&${e}-right`]: { [`> ${e}-nav`]: { order: 0 }, [`> ${e}-content-holder`]: { order: 1 } }, [`&${e}-card${e}-top, &${e}-card${e}-bottom`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-tab + ${e}-tab`]: { marginRight: { _skip_check_: !0, value: `${r}px` }, marginLeft: { _skip_check_: !0, value: 0 } } } } }, [`${e}-dropdown-rtl`]: { direction: "rtl" }, [`${e}-menu-item`]: { [`${e}-dropdown-rtl`]: { textAlign: { _skip_check_: !0, value: "right" } } } } }, p8 = t => { const { componentCls: e, tabsCardHorizontalPadding: n, tabsCardHeight: i, tabsCardGutter: r, tabsHoverColor: o, tabsActiveColor: s, colorSplit: l } = t; return { [e]: S(S(S(S({}, Yl(t)), { display: "flex", [`> ${e}-nav, > div > ${e}-nav`]: { position: "relative", display: "flex", flex: "none", alignItems: "center", [`${e}-nav-wrap`]: { position: "relative", display: "flex", flex: "auto", alignSelf: "stretch", overflow: "hidden", whiteSpace: "nowrap", transform: "translate(0)", "&::before, &::after": { position: "absolute", zIndex: 1, opacity: 0, transition: `opacity ${t.motionDurationSlow}`, content: "''", pointerEvents: "none" } }, [`${e}-nav-list`]: { position: "relative", display: "flex", transition: `opacity ${t.motionDurationSlow}` }, [`${e}-nav-operations`]: { display: "flex", alignSelf: "stretch" }, [`${e}-nav-operations-hidden`]: { position: "absolute", visibility: "hidden", pointerEvents: "none" }, [`${e}-nav-more`]: { position: "relative", padding: n, background: "transparent", border: 0, "&::after": { position: "absolute", right: { _skip_check_: !0, value: 0 }, bottom: 0, left: { _skip_check_: !0, value: 0 }, height: t.controlHeightLG / 8, transform: "translateY(100%)", content: "''" } }, [`${e}-nav-add`]: S({ minWidth: `${i}px`, marginLeft: { _skip_check_: !0, value: `${r}px` }, padding: `0 ${t.paddingXS}px`, background: "transparent", border: `${t.lineWidth}px ${t.lineType} ${l}`, borderRadius: `${t.borderRadiusLG}px ${t.borderRadiusLG}px 0 0`, outline: "none", cursor: "pointer", color: t.colorText, transition: `all ${t.motionDurationSlow} ${t.motionEaseInOut}`, "&:hover": { color: o }, "&:active, &:focus:not(:focus-visible)": { color: s } }, _g(t)) }, [`${e}-extra-content`]: { flex: "none" }, [`${e}-ink-bar`]: { position: "absolute", background: t.colorPrimary, pointerEvents: "none" } }), h8(t)), { [`${e}-content`]: { position: "relative", display: "flex", width: "100%", ["&-animated"]: { transition: "margin 0.3s" } }, [`${e}-content-holder`]: { flex: "auto", minWidth: 0, minHeight: 0 }, [`${e}-tabpane`]: { outline: "none", flex: "none", width: "100%" } }), [`${e}-centered`]: { [`> ${e}-nav, > div > ${e}-nav`]: { [`${e}-nav-wrap`]: { [`&:not([class*='${e}-nav-wrap-ping'])`]: { justifyContent: "center" } } } } } }, g8 = zn("Tabs", t => { const e = t.controlHeightLG, n = dn(t, { tabsHoverColor: t.colorPrimaryHover, tabsActiveColor: t.colorPrimaryActive, tabsCardHorizontalPadding: `${(e - Math.round(t.fontSize * t.lineHeight)) / 2 - t.lineWidth}px ${t.padding}px`, tabsCardHeight: e, tabsCardGutter: t.marginXXS / 2, tabsHorizontalGutter: 32, tabsCardHeadBackground: t.colorFillAlter, dropdownEdgeChildVerticalPadding: t.paddingXXS, tabsActiveTextShadow: "0 0 0.25px currentcolor", tabsDropdownHeight: 200, tabsDropdownWidth: 120 }); return [f8(n), d8(n), u8(n), c8(n), a8(n), p8(n), l8(n)] }, t => ({ zIndexPopup: t.zIndexPopupBase + 50 })); let tO = 0; const qT = () => ({ prefixCls: { type: String }, id: { type: String }, popupClassName: String, getPopupContainer: An(), activeKey: { type: [String, Number] }, defaultActiveKey: { type: [String, Number] }, direction: So(), animated: el([Boolean, Object]), renderTabBar: An(), tabBarGutter: { type: Number }, tabBarStyle: zt(), tabPosition: So(), destroyInactiveTabPane: Nr(), hideAdd: Boolean, type: So(), size: So(), centered: Boolean, onEdit: An(), onChange: An(), onTabClick: An(), onTabScroll: An(), "onUpdate:activeKey": An(), locale: zt(), onPrevClick: An(), onNextClick: An(), tabBarExtraContent: ne.any }); function m8(t) { return t.map(e => { if (Gu(e)) { const n = S({}, e.props || {}); for (const [h, d] of Object.entries(n)) delete n[h], n[Xu(h)] = d; const i = e.children || {}, r = e.key !== void 0 ? e.key : void 0, { tab: o = i.tab, disabled: s, forceRender: l, closable: a, animated: c, active: u, destroyInactiveTabPane: f } = n; return S(S({ key: r }, n), { node: e, closeIcon: i.closeIcon, tab: o, disabled: s === "" || s, forceRender: l === "" || l, closable: a === "" || a, animated: c === "" || c, active: u === "" || u, destroyInactiveTabPane: f === "" || f }) } return null }).filter(e => e) } const v8 = ue({ compatConfig: { MODE: 3 }, name: "InternalTabs", inheritAttrs: !1, props: S(S({}, to(qT(), { tabPosition: "top", animated: { inkBar: !0, tabPane: !1 } })), { tabs: Vd() }), slots: Object, setup(t, e) { let { attrs: n, slots: i } = e; ii(t.onPrevClick === void 0 && t.onNextClick === void 0, "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead."), ii(t.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead."), ii(i.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead."); const { prefixCls: r, direction: o, size: s, rootPrefixCls: l, getPopupContainer: a } = dt("tabs", t), [c, u] = g8(r), f = E(() => o.value === "rtl"), h = E(() => { const { animated: O, tabPosition: P } = t; return O === !1 || ["left", "right"].includes(P) ? { inkBar: !1, tabPane: !1 } : O === !0 ? { inkBar: !0, tabPane: !0 } : S({ inkBar: !0, tabPane: !1 }, typeof O == "object" ? O : {}) }), [d, p] = Je(!1); vt(() => { p(CW()) }); const [g, m] = fb(() => { var O; return (O = t.tabs[0]) === null || O === void 0 ? void 0 : O.key }, { value: E(() => t.activeKey), defaultValue: t.defaultActiveKey }), [v, b] = Je(() => t.tabs.findIndex(O => O.key === g.value)); hn(() => { var O; let P = t.tabs.findIndex(M => M.key === g.value); P === -1 && (P = Math.max(0, Math.min(v.value, t.tabs.length - 1)), m((O = t.tabs[P]) === null || O === void 0 ? void 0 : O.key)), b(P) }); const [x, w] = fb(null, { value: E(() => t.id) }), y = E(() => d.value && !["left", "right"].includes(t.tabPosition) ? "top" : t.tabPosition); vt(() => { t.id || (w(`rc-tabs-${tO}`), tO += 1) }); const C = (O, P) => { var M, A; (M = t.onTabClick) === null || M === void 0 || M.call(t, O, P); const B = O !== g.value; m(O), B && ((A = t.onChange) === null || A === void 0 || A.call(t, O)) }; return Uj({ tabs: E(() => t.tabs), prefixCls: r }), () => { const { id: O, type: P, tabBarGutter: M, tabBarStyle: A, locale: B, destroyInactiveTabPane: R, renderTabBar: X = i.renderTabBar, onTabScroll: K, hideAdd: _, centered: j } = t, W = { id: x.value, activeKey: g.value, animated: h.value, tabPosition: y.value, rtl: f.value, mobile: d.value }; let G; P === "editable-card" && (G = { onEdit: (ce, Oe) => { let { key: Le, event: Qe } = Oe; var Ae; (Ae = t.onEdit) === null || Ae === void 0 || Ae.call(t, ce === "add" ? Qe : Le, ce) }, removeIcon: () => $(uH, null, null), addIcon: i.addIcon ? i.addIcon : () => $(o8, null, null), showAdd: _ !== !0 }); let ae; const ge = S(S({}, W), { moreTransitionName: `${l.value}-slide-up`, editable: G, locale: B, tabBarGutter: M, onTabClick: C, onTabScroll: K, style: A, getPopupContainer: a.value, popupClassName: ke(t.popupClassName, u.value) }); X ? ae = X(S(S({}, ge), { DefaultTabBar: Jb })) : ae = $(Jb, ge, bT(i, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"])); const J = r.value; return c($("div", ee(ee({}, n), {}, { id: O, class: ke(J, `${J}-${y.value}`, { [u.value]: !0, [`${J}-${s.value}`]: s.value, [`${J}-card`]: ["card", "editable-card"].includes(P), [`${J}-editable-card`]: P === "editable-card", [`${J}-centered`]: j, [`${J}-mobile`]: d.value, [`${J}-editable`]: P === "editable-card", [`${J}-rtl`]: f.value }, n.class) }), [ae, $(t8, ee(ee({ destroyInactiveTabPane: R }, W), {}, { animated: h.value }), null)])) } } }), Qo = ue({ compatConfig: { MODE: 3 }, name: "ATabs", inheritAttrs: !1, props: to(qT(), { tabPosition: "top", animated: { inkBar: !0, tabPane: !1 } }), slots: Object, setup(t, e) { let { attrs: n, slots: i, emit: r } = e; const o = s => { r("update:activeKey", s), r("change", s) }; return () => { var s; const l = m8(Ft((s = i.default) === null || s === void 0 ? void 0 : s.call(i))); return $(v8, ee(ee(ee({}, Ig(t, ["onUpdate:activeKey"])), n), {}, { onChange: o, tabs: l }), i) } } }), y8 = () => ({ tab: ne.any, disabled: { type: Boolean }, forceRender: { type: Boolean }, closable: { type: Boolean }, animated: { type: Boolean }, active: { type: Boolean }, destroyInactiveTabPane: { type: Boolean }, prefixCls: { type: String }, tabKey: { type: [String, Number] }, id: { type: String } }), gp = ue({ compatConfig: { MODE: 3 }, name: "ATabPane", inheritAttrs: !1, __ANT_TAB_PANE: !0, props: y8(), slots: Object, setup(t, e) { let { attrs: n, slots: i } = e; const r = he(t.forceRender); Te([() => t.active, () => t.destroyInactiveTabPane], () => { t.active ? r.value = !0 : t.destroyInactiveTabPane && (r.value = !1) }, { immediate: !0 }); const o = E(() => t.active ? {} : t.animated ? { visibility: "hidden", height: 0, overflowY: "hidden" } : { display: "none" }); return () => { var s; const { prefixCls: l, forceRender: a, id: c, active: u, tabKey: f } = t; return $("div", { id: c && `${c}-panel-${f}`, role: "tabpanel", tabindex: u ? 0 : -1, "aria-labelledby": c && `${c}-tab-${f}`, "aria-hidden": !u, style: [o.value, n.style], class: [`${l}-tabpane`, u && `${l}-tabpane-active`, n.class] }, [(u || r.value || a) && ((s = i.default) === null || s === void 0 ? void 0 : s.call(i))]) } } }); Qo.TabPane = gp; Qo.install = function (t) { return t.component(Qo.name, Qo), t.component(gp.name, gp), t }; const b8 = t => {
        const { antCls: e, componentCls: n, cardHeadHeight: i, cardPaddingBase: r, cardHeadTabsMarginBottom: o } = t; return S(S({ display: "flex", justifyContent: "center", flexDirection: "column", minHeight: i, marginBottom: -1, padding: `0 ${r}px`, color: t.colorTextHeading, fontWeight: t.fontWeightStrong, fontSize: t.fontSizeLG, background: "transparent", borderBottom: `${t.lineWidth}px ${t.lineType} ${t.colorBorderSecondary}`, borderRadius: `${t.borderRadiusLG}px ${t.borderRadiusLG}px 0 0` }, Zo()), {
            "&-wrapper": { width: "100%", display: "flex", alignItems: "center" }, "&-title": S(S({ display: "inline-block", flex: 1 }, ef), {
                [`
          > ${n}-typography,
          > ${n}-typography-edit-content
        `]: { insetInlineStart: 0, marginTop: 0, marginBottom: 0 }
            }), [`${e}-tabs-top`]: { clear: "both", marginBottom: o, color: t.colorText, fontWeight: "normal", fontSize: t.fontSize, "&-bar": { borderBottom: `${t.lineWidth}px ${t.lineType} ${t.colorBorderSecondary}` } }
        })
    }, O8 = t => {
        const { cardPaddingBase: e, colorBorderSecondary: n, cardShadow: i, lineWidth: r } = t; return {
            width: "33.33%", padding: e, border: 0, borderRadius: 0, boxShadow: `
      ${r}px 0 0 0 ${n},
      0 ${r}px 0 0 ${n},
      ${r}px ${r}px 0 0 ${n},
      ${r}px 0 0 0 ${n} inset,
      0 ${r}px 0 0 ${n} inset;
    `, transition: `all ${t.motionDurationMid}`, "&-hoverable:hover": { position: "relative", zIndex: 1, boxShadow: i }
        }
    }, S8 = t => { const { componentCls: e, iconCls: n, cardActionsLiMargin: i, cardActionsIconSize: r, colorBorderSecondary: o } = t; return S(S({ margin: 0, padding: 0, listStyle: "none", background: t.colorBgContainer, borderTop: `${t.lineWidth}px ${t.lineType} ${o}`, display: "flex", borderRadius: `0 0 ${t.borderRadiusLG}px ${t.borderRadiusLG}px ` }, Zo()), { "& > li": { margin: i, color: t.colorTextDescription, textAlign: "center", "> span": { position: "relative", display: "block", minWidth: t.cardActionsIconSize * 2, fontSize: t.fontSize, lineHeight: t.lineHeight, cursor: "pointer", "&:hover": { color: t.colorPrimary, transition: `color ${t.motionDurationMid}` }, [`a:not(${e}-btn), > ${n}`]: { display: "inline-block", width: "100%", color: t.colorTextDescription, lineHeight: `${t.fontSize * t.lineHeight}px`, transition: `color ${t.motionDurationMid}`, "&:hover": { color: t.colorPrimary } }, [`> ${n}`]: { fontSize: r, lineHeight: `${r * t.lineHeight}px` } }, "&:not(:last-child)": { borderInlineEnd: `${t.lineWidth}px ${t.lineType} ${o}` } } }) }, x8 = t => S(S({ margin: `-${t.marginXXS}px 0`, display: "flex" }, Zo()), { "&-avatar": { paddingInlineEnd: t.padding }, "&-detail": { overflow: "hidden", flex: 1, "> div:not(:last-child)": { marginBottom: t.marginXS } }, "&-title": S({ color: t.colorTextHeading, fontWeight: t.fontWeightStrong, fontSize: t.fontSizeLG }, ef), "&-description": { color: t.colorTextDescription } }), w8 = t => { const { componentCls: e, cardPaddingBase: n, colorFillAlter: i } = t; return { [`${e}-head`]: { padding: `0 ${n}px`, background: i, "&-title": { fontSize: t.fontSize } }, [`${e}-body`]: { padding: `${t.padding}px ${n}px` } } }, C8 = t => { const { componentCls: e } = t; return { overflow: "hidden", [`${e}-body`]: { userSelect: "none" } } }, T8 = t => { const { componentCls: e, cardShadow: n, cardHeadPadding: i, colorBorderSecondary: r, boxShadow: o, cardPaddingBase: s } = t; return { [e]: S(S({}, Yl(t)), { position: "relative", background: t.colorBgContainer, borderRadius: t.borderRadiusLG, [`&:not(${e}-bordered)`]: { boxShadow: o }, [`${e}-head`]: b8(t), [`${e}-extra`]: { marginInlineStart: "auto", color: "", fontWeight: "normal", fontSize: t.fontSize }, [`${e}-body`]: S({ padding: s, borderRadius: ` 0 0 ${t.borderRadiusLG}px ${t.borderRadiusLG}px` }, Zo()), [`${e}-grid`]: O8(t), [`${e}-cover`]: { "> *": { display: "block", width: "100%" }, img: { borderRadius: `${t.borderRadiusLG}px ${t.borderRadiusLG}px 0 0` } }, [`${e}-actions`]: S8(t), [`${e}-meta`]: x8(t) }), [`${e}-bordered`]: { border: `${t.lineWidth}px ${t.lineType} ${r}`, [`${e}-cover`]: { marginTop: -1, marginInlineStart: -1, marginInlineEnd: -1 } }, [`${e}-hoverable`]: { cursor: "pointer", transition: `box-shadow ${t.motionDurationMid}, border-color ${t.motionDurationMid}`, "&:hover": { borderColor: "transparent", boxShadow: n } }, [`${e}-contain-grid`]: { [`${e}-body`]: { display: "flex", flexWrap: "wrap" }, [`&:not(${e}-loading) ${e}-body`]: { marginBlockStart: -t.lineWidth, marginInlineStart: -t.lineWidth, padding: 0 } }, [`${e}-contain-tabs`]: { [`> ${e}-head`]: { [`${e}-head-title, ${e}-extra`]: { paddingTop: i } } }, [`${e}-type-inner`]: w8(t), [`${e}-loading`]: C8(t), [`${e}-rtl`]: { direction: "rtl" } } }, $8 = t => { const { componentCls: e, cardPaddingSM: n, cardHeadHeightSM: i } = t; return { [`${e}-small`]: { [`> ${e}-head`]: { minHeight: i, padding: `0 ${n}px`, fontSize: t.fontSize, [`> ${e}-head-wrapper`]: { [`> ${e}-extra`]: { fontSize: t.fontSize } } }, [`> ${e}-body`]: { padding: n } }, [`${e}-small${e}-contain-tabs`]: { [`> ${e}-head`]: { [`${e}-head-title, ${e}-extra`]: { minHeight: i, paddingTop: 0, display: "flex", alignItems: "center" } } } } }, k8 = zn("Card", t => { const e = dn(t, { cardShadow: t.boxShadowCard, cardHeadHeight: t.fontSizeLG * t.lineHeightLG + t.padding * 2, cardHeadHeightSM: t.fontSize * t.lineHeight + t.paddingXS * 2, cardHeadPadding: t.padding, cardPaddingBase: t.paddingLG, cardHeadTabsMarginBottom: -t.padding - t.lineWidth, cardActionsLiMargin: `${t.paddingSM}px 0`, cardActionsIconSize: t.fontSize, cardPaddingSM: 12 }); return [T8(e), $8(e)] }), P8 = () => ({ prefixCls: String, width: { type: [Number, String] } }), A8 = ue({ compatConfig: { MODE: 3 }, name: "SkeletonTitle", props: P8(), setup(t) { return () => { const { prefixCls: e, width: n } = t, i = typeof n == "number" ? `${n}px` : n; return $("h3", { class: e, style: { width: i } }, null) } } }), cm = A8, M8 = () => ({ prefixCls: String, width: { type: [Number, String, Array] }, rows: Number }), E8 = ue({ compatConfig: { MODE: 3 }, name: "SkeletonParagraph", props: M8(), setup(t) { const e = n => { const { width: i, rows: r = 2 } = t; if (Array.isArray(i)) return i[n]; if (r - 1 === n) return i }; return () => { const { prefixCls: n, rows: i } = t, r = [...Array(i)].map((o, s) => { const l = e(s); return $("li", { key: s, style: { width: typeof l == "number" ? `${l}px` : l } }, null) }); return $("ul", { class: n }, [r]) } } }), _8 = E8, uf = () => ({ prefixCls: String, size: [String, Number], shape: String, active: { type: Boolean, default: void 0 } }), VT = t => { const { prefixCls: e, size: n, shape: i } = t, r = ke({ [`${e}-lg`]: n === "large", [`${e}-sm`]: n === "small" }), o = ke({ [`${e}-circle`]: i === "circle", [`${e}-square`]: i === "square", [`${e}-round`]: i === "round" }), s = typeof n == "number" ? { width: `${n}px`, height: `${n}px`, lineHeight: `${n}px` } : {}; return $("span", { class: ke(e, r, o), style: s }, null) }; VT.displayName = "SkeletonElement"; const ff = VT, R8 = new rt("ant-skeleton-loading", { "0%": { transform: "translateX(-37.5%)" }, "100%": { transform: "translateX(37.5%)" } }), hf = t => ({ height: t, lineHeight: `${t}px` }), No = t => S({ width: t }, hf(t)), I8 = t => ({ position: "relative", zIndex: 0, overflow: "hidden", background: "transparent", "&::after": { position: "absolute", top: 0, insetInlineEnd: "-150%", bottom: 0, insetInlineStart: "-150%", background: t.skeletonLoadingBackground, animationName: R8, animationDuration: t.skeletonLoadingMotionDuration, animationTimingFunction: "ease", animationIterationCount: "infinite", content: '""' } }), $h = t => S({ width: t * 5, minWidth: t * 5 }, hf(t)), D8 = t => { const { skeletonAvatarCls: e, color: n, controlHeight: i, controlHeightLG: r, controlHeightSM: o } = t; return { [`${e}`]: S({ display: "inline-block", verticalAlign: "top", background: n }, No(i)), [`${e}${e}-circle`]: { borderRadius: "50%" }, [`${e}${e}-lg`]: S({}, No(r)), [`${e}${e}-sm`]: S({}, No(o)) } }, B8 = t => { const { controlHeight: e, borderRadiusSM: n, skeletonInputCls: i, controlHeightLG: r, controlHeightSM: o, color: s } = t; return { [`${i}`]: S({ display: "inline-block", verticalAlign: "top", background: s, borderRadius: n }, $h(e)), [`${i}-lg`]: S({}, $h(r)), [`${i}-sm`]: S({}, $h(o)) } }, nO = t => S({ width: t }, hf(t)), L8 = t => { const { skeletonImageCls: e, imageSizeBase: n, color: i, borderRadiusSM: r } = t; return { [`${e}`]: S(S({ display: "flex", alignItems: "center", justifyContent: "center", verticalAlign: "top", background: i, borderRadius: r }, nO(n * 2)), { [`${e}-path`]: { fill: "#bfbfbf" }, [`${e}-svg`]: S(S({}, nO(n)), { maxWidth: n * 4, maxHeight: n * 4 }), [`${e}-svg${e}-svg-circle`]: { borderRadius: "50%" } }), [`${e}${e}-circle`]: { borderRadius: "50%" } } }, kh = (t, e, n) => { const { skeletonButtonCls: i } = t; return { [`${n}${i}-circle`]: { width: e, minWidth: e, borderRadius: "50%" }, [`${n}${i}-round`]: { borderRadius: e } } }, Ph = t => S({ width: t * 2, minWidth: t * 2 }, hf(t)), Q8 = t => { const { borderRadiusSM: e, skeletonButtonCls: n, controlHeight: i, controlHeightLG: r, controlHeightSM: o, color: s } = t; return S(S(S(S(S({ [`${n}`]: S({ display: "inline-block", verticalAlign: "top", background: s, borderRadius: e, width: i * 2, minWidth: i * 2 }, Ph(i)) }, kh(t, i, n)), { [`${n}-lg`]: S({}, Ph(r)) }), kh(t, r, `${n}-lg`)), { [`${n}-sm`]: S({}, Ph(o)) }), kh(t, o, `${n}-sm`)) }, N8 = t => {
        const { componentCls: e, skeletonAvatarCls: n, skeletonTitleCls: i, skeletonParagraphCls: r, skeletonButtonCls: o, skeletonInputCls: s, skeletonImageCls: l, controlHeight: a, controlHeightLG: c, controlHeightSM: u, color: f, padding: h, marginSM: d, borderRadius: p, skeletonTitleHeight: g, skeletonBlockRadius: m, skeletonParagraphLineHeight: v, controlHeightXS: b, skeletonParagraphMarginTop: x } = t; return {
            [`${e}`]: { display: "table", width: "100%", [`${e}-header`]: { display: "table-cell", paddingInlineEnd: h, verticalAlign: "top", [`${n}`]: S({ display: "inline-block", verticalAlign: "top", background: f }, No(a)), [`${n}-circle`]: { borderRadius: "50%" }, [`${n}-lg`]: S({}, No(c)), [`${n}-sm`]: S({}, No(u)) }, [`${e}-content`]: { display: "table-cell", width: "100%", verticalAlign: "top", [`${i}`]: { width: "100%", height: g, background: f, borderRadius: m, [`+ ${r}`]: { marginBlockStart: u } }, [`${r}`]: { padding: 0, "> li": { width: "100%", height: v, listStyle: "none", background: f, borderRadius: m, "+ li": { marginBlockStart: b } } }, [`${r}> li:last-child:not(:first-child):not(:nth-child(2))`]: { width: "61%" } }, [`&-round ${e}-content`]: { [`${i}, ${r} > li`]: { borderRadius: p } } }, [`${e}-with-avatar ${e}-content`]: { [`${i}`]: { marginBlockStart: d, [`+ ${r}`]: { marginBlockStart: x } } }, [`${e}${e}-element`]: S(S(S(S({ display: "inline-block", width: "auto" }, Q8(t)), D8(t)), B8(t)), L8(t)), [`${e}${e}-block`]: { width: "100%", [`${o}`]: { width: "100%" }, [`${s}`]: { width: "100%" } }, [`${e}${e}-active`]: {
                [`
        ${i},
        ${r} > li,
        ${n},
        ${o},
        ${s},
        ${l}
      `]: S({}, I8(t))
            }
        }
    }, ea = zn("Skeleton", t => { const { componentCls: e } = t, n = dn(t, { skeletonAvatarCls: `${e}-avatar`, skeletonTitleCls: `${e}-title`, skeletonParagraphCls: `${e}-paragraph`, skeletonButtonCls: `${e}-button`, skeletonInputCls: `${e}-input`, skeletonImageCls: `${e}-image`, imageSizeBase: t.controlHeight * 1.5, skeletonTitleHeight: t.controlHeight / 2, skeletonBlockRadius: t.borderRadiusSM, skeletonParagraphLineHeight: t.controlHeight / 2, skeletonParagraphMarginTop: t.marginLG + t.marginXXS, borderRadius: 100, skeletonLoadingBackground: `linear-gradient(90deg, ${t.color} 25%, ${t.colorGradientEnd} 37%, ${t.color} 63%)`, skeletonLoadingMotionDuration: "1.4s" }); return [N8(n)] }, t => { const { colorFillContent: e, colorFill: n } = t; return { color: e, colorGradientEnd: n } }), z8 = () => ({ active: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: void 0 }, prefixCls: String, avatar: { type: [Boolean, Object], default: void 0 }, title: { type: [Boolean, Object], default: void 0 }, paragraph: { type: [Boolean, Object], default: void 0 }, round: { type: Boolean, default: void 0 } }); function Ah(t) { return t && typeof t == "object" ? t : {} } function W8(t, e) { return t && !e ? { size: "large", shape: "square" } : { size: "large", shape: "circle" } } function H8(t, e) { return !t && e ? { width: "38%" } : t && e ? { width: "50%" } : {} } function F8(t, e) { const n = {}; return (!t || !e) && (n.width = "61%"), !t && e ? n.rows = 3 : n.rows = 2, n } const j8 = ue({ compatConfig: { MODE: 3 }, name: "ASkeleton", props: to(z8(), { avatar: !1, title: !0, paragraph: !0 }), setup(t, e) { let { slots: n } = e; const { prefixCls: i, direction: r } = dt("skeleton", t), [o, s] = ea(i); return () => { var l; const { loading: a, avatar: c, title: u, paragraph: f, active: h, round: d } = t, p = i.value; if (a || t.loading === void 0) { const g = !!c || c === "", m = !!u || u === "", v = !!f || f === ""; let b; if (g) { const y = S(S({ prefixCls: `${p}-avatar` }, W8(m, v)), Ah(c)); b = $("div", { class: `${p}-header` }, [$(ff, y, null)]) } let x; if (m || v) { let y; if (m) { const O = S(S({ prefixCls: `${p}-title` }, H8(g, v)), Ah(u)); y = $(cm, O, null) } let C; if (v) { const O = S(S({ prefixCls: `${p}-paragraph` }, F8(g, m)), Ah(f)); C = $(_8, O, null) } x = $("div", { class: `${p}-content` }, [y, C]) } const w = ke(p, { [`${p}-with-avatar`]: g, [`${p}-active`]: h, [`${p}-rtl`]: r.value === "rtl", [`${p}-round`]: d, [s.value]: !0 }); return o($("div", { class: w }, [b, x])) } return (l = n.default) === null || l === void 0 ? void 0 : l.call(n) } } }), qt = j8, q8 = () => S(S({}, uf()), { size: String, block: Boolean }), V8 = ue({ compatConfig: { MODE: 3 }, name: "ASkeletonButton", props: to(q8(), { size: "default" }), setup(t) { const { prefixCls: e } = dt("skeleton", t), [n, i] = ea(e), r = E(() => ke(e.value, `${e.value}-element`, { [`${e.value}-active`]: t.active, [`${e.value}-block`]: t.block }, i.value)); return () => n($("div", { class: r.value }, [$(ff, ee(ee({}, t), {}, { prefixCls: `${e.value}-button` }), null)])) } }), XT = V8, X8 = ue({ compatConfig: { MODE: 3 }, name: "ASkeletonInput", props: S(S({}, Ig(uf(), ["shape"])), { size: String, block: Boolean }), setup(t) { const { prefixCls: e } = dt("skeleton", t), [n, i] = ea(e), r = E(() => ke(e.value, `${e.value}-element`, { [`${e.value}-active`]: t.active, [`${e.value}-block`]: t.block }, i.value)); return () => n($("div", { class: r.value }, [$(ff, ee(ee({}, t), {}, { prefixCls: `${e.value}-input` }), null)])) } }), UT = X8, U8 = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", G8 = ue({ compatConfig: { MODE: 3 }, name: "ASkeletonImage", props: Ig(uf(), ["size", "shape", "active"]), setup(t) { const { prefixCls: e } = dt("skeleton", t), [n, i] = ea(e), r = E(() => ke(e.value, `${e.value}-element`, i.value)); return () => n($("div", { class: r.value }, [$("div", { class: `${e.value}-image` }, [$("svg", { viewBox: "0 0 1098 1024", xmlns: "http://www.w3.org/2000/svg", class: `${e.value}-image-svg` }, [$("path", { d: U8, class: `${e.value}-image-path` }, null)])])])) } }), GT = G8, K8 = () => S(S({}, uf()), { shape: String }), Y8 = ue({ compatConfig: { MODE: 3 }, name: "ASkeletonAvatar", props: to(K8(), { size: "default", shape: "circle" }), setup(t) { const { prefixCls: e } = dt("skeleton", t), [n, i] = ea(e), r = E(() => ke(e.value, `${e.value}-element`, { [`${e.value}-active`]: t.active }, i.value)); return () => n($("div", { class: r.value }, [$(ff, ee(ee({}, t), {}, { prefixCls: `${e.value}-avatar` }), null)])) } }), KT = Y8; qt.Button = XT; qt.Avatar = KT; qt.Input = UT; qt.Image = GT; qt.Title = cm; qt.install = function (t) { return t.component(qt.name, qt), t.component(qt.Button.name, XT), t.component(qt.Avatar.name, KT), t.component(qt.Input.name, UT), t.component(qt.Image.name, GT), t.component(qt.Title.name, cm), t }; const { TabPane: Z8 } = Qo, J8 = () => ({ prefixCls: String, title: ne.any, extra: ne.any, bordered: { type: Boolean, default: !0 }, bodyStyle: { type: Object, default: void 0 }, headStyle: { type: Object, default: void 0 }, loading: { type: Boolean, default: !1 }, hoverable: { type: Boolean, default: !1 }, type: { type: String }, size: { type: String }, actions: ne.any, tabList: { type: Array }, tabBarExtraContent: ne.any, activeTabKey: String, defaultActiveTabKey: String, cover: ne.any, onTabChange: { type: Function } }), eq = ue({ compatConfig: { MODE: 3 }, name: "ACard", inheritAttrs: !1, props: J8(), slots: Object, setup(t, e) { let { slots: n, attrs: i } = e; const { prefixCls: r, direction: o, size: s } = dt("card", t), [l, a] = k8(r), c = h => h.map((p, g) => wn(p) && !$g(p) || !wn(p) ? $("li", { style: { width: `${100 / h.length}%` }, key: `action-${g}` }, [$("span", null, [p])]) : null), u = h => { var d; (d = t.onTabChange) === null || d === void 0 || d.call(t, h) }, f = function () { let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], d; return h.forEach(p => { p && uF(p.type) && p.type.__ANT_CARD_GRID && (d = !0) }), d }; return () => { var h, d, p, g, m, v; const { headStyle: b = {}, bodyStyle: x = {}, loading: w, bordered: y = !0, type: C, tabList: O, hoverable: P, activeTabKey: M, defaultActiveTabKey: A, tabBarExtraContent: B = $s((h = n.tabBarExtraContent) === null || h === void 0 ? void 0 : h.call(n)), title: R = $s((d = n.title) === null || d === void 0 ? void 0 : d.call(n)), extra: X = $s((p = n.extra) === null || p === void 0 ? void 0 : p.call(n)), actions: K = $s((g = n.actions) === null || g === void 0 ? void 0 : g.call(n)), cover: _ = $s((m = n.cover) === null || m === void 0 ? void 0 : m.call(n)) } = t, j = Ft((v = n.default) === null || v === void 0 ? void 0 : v.call(n)), W = r.value, G = { [`${W}`]: !0, [a.value]: !0, [`${W}-loading`]: w, [`${W}-bordered`]: y, [`${W}-hoverable`]: !!P, [`${W}-contain-grid`]: f(j), [`${W}-contain-tabs`]: O && O.length, [`${W}-${s.value}`]: s.value, [`${W}-type-${C}`]: !!C, [`${W}-rtl`]: o.value === "rtl" }, ae = $(qt, { loading: !0, active: !0, paragraph: { rows: 4 }, title: !1 }, { default: () => [j] }), ge = M !== void 0, J = { size: "large", [ge ? "activeKey" : "defaultActiveKey"]: ge ? M : A, onChange: u, class: `${W}-head-tabs` }; let ce; const Oe = O && O.length ? $(Qo, J, { default: () => [O.map(U => { const { tab: pe, slots: ve } = U, Pe = ve == null ? void 0 : ve.tab; ii(!ve, "Card", "tabList slots is deprecated, Please use `customTab` instead."); let Ie = pe !== void 0 ? pe : n[Pe] ? n[Pe](U) : null; return Ie = tN(n, "customTab", U, () => [Ie]), $(Z8, { tab: Ie, key: U.key, disabled: U.disabled }, null) })], rightExtra: B ? () => B : null }) : null; (R || X || Oe) && (ce = $("div", { class: `${W}-head`, style: b }, [$("div", { class: `${W}-head-wrapper` }, [R && $("div", { class: `${W}-head-title` }, [R]), X && $("div", { class: `${W}-extra` }, [X])]), Oe])); const Le = _ ? $("div", { class: `${W}-cover` }, [_]) : null, Qe = $("div", { class: `${W}-body`, style: x }, [w ? ae : j]), Ae = K && K.length ? $("ul", { class: `${W}-actions` }, [c(K)]) : null; return l($("div", ee(ee({ ref: "cardContainerRef" }, i), {}, { class: [G, i.class] }), [ce, Le, j && j.length ? Qe : null, Ae])) } } }), zo = eq, tq = () => ({ prefixCls: String, title: rh(), description: rh(), avatar: rh() }), mp = ue({ compatConfig: { MODE: 3 }, name: "ACardMeta", props: tq(), slots: Object, setup(t, e) { let { slots: n } = e; const { prefixCls: i } = dt("card", t); return () => { const r = { [`${i.value}-meta`]: !0 }, o = Do(n, t, "avatar"), s = Do(n, t, "title"), l = Do(n, t, "description"), a = o ? $("div", { class: `${i.value}-meta-avatar` }, [o]) : null, c = s ? $("div", { class: `${i.value}-meta-title` }, [s]) : null, u = l ? $("div", { class: `${i.value}-meta-description` }, [l]) : null, f = c || u ? $("div", { class: `${i.value}-meta-detail` }, [c, u]) : null; return $("div", { class: r }, [a, f]) } } }), nq = () => ({ prefixCls: String, hoverable: { type: Boolean, default: !0 } }), vp = ue({ compatConfig: { MODE: 3 }, name: "ACardGrid", __ANT_CARD_GRID: !0, props: nq(), setup(t, e) { let { slots: n } = e; const { prefixCls: i } = dt("card", t), r = E(() => ({ [`${i.value}-grid`]: !0, [`${i.value}-grid-hoverable`]: t.hoverable })); return () => { var o; return $("div", { class: r.value }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]) } } }); zo.Meta = mp; zo.Grid = vp; zo.install = function (t) { return t.component(zo.name, zo), t.component(mp.name, mp), t.component(vp.name, vp), t }; const iq = () => si() && window.document.documentElement; let Ua; const rq = () => { if (!iq()) return !1; if (Ua !== void 0) return Ua; const t = document.createElement("div"); return t.style.display = "flex", t.style.flexDirection = "column", t.style.rowGap = "1px", t.appendChild(document.createElement("div")), t.appendChild(document.createElement("div")), document.body.appendChild(t), Ua = t.scrollHeight === 1, document.body.removeChild(t), Ua }, oq = () => { const t = oe(!1); return vt(() => { t.value = rq() }), t }, YT = Symbol("rowContextKey"), sq = t => { en(YT, t) }, lq = () => Ke(YT, { gutter: E(() => { }), wrap: E(() => { }), supportFlexGap: E(() => { }) }), aq = t => { const { componentCls: e } = t; return { [e]: { display: "flex", flexFlow: "row wrap", minWidth: 0, "&::before, &::after": { display: "flex" }, "&-no-wrap": { flexWrap: "nowrap" }, "&-start": { justifyContent: "flex-start" }, "&-center": { justifyContent: "center" }, "&-end": { justifyContent: "flex-end" }, "&-space-between": { justifyContent: "space-between" }, "&-space-around ": { justifyContent: "space-around" }, "&-space-evenly ": { justifyContent: "space-evenly" }, "&-top": { alignItems: "flex-start" }, "&-middle": { alignItems: "center" }, "&-bottom": { alignItems: "flex-end" } } } }, cq = t => { const { componentCls: e } = t; return { [e]: { position: "relative", maxWidth: "100%", minHeight: 1 } } }, uq = (t, e) => { const { componentCls: n, gridColumns: i } = t, r = {}; for (let o = i; o >= 0; o--)o === 0 ? (r[`${n}${e}-${o}`] = { display: "none" }, r[`${n}-push-${o}`] = { insetInlineStart: "auto" }, r[`${n}-pull-${o}`] = { insetInlineEnd: "auto" }, r[`${n}${e}-push-${o}`] = { insetInlineStart: "auto" }, r[`${n}${e}-pull-${o}`] = { insetInlineEnd: "auto" }, r[`${n}${e}-offset-${o}`] = { marginInlineEnd: 0 }, r[`${n}${e}-order-${o}`] = { order: 0 }) : (r[`${n}${e}-${o}`] = { display: "block", flex: `0 0 ${o / i * 100}%`, maxWidth: `${o / i * 100}%` }, r[`${n}${e}-push-${o}`] = { insetInlineStart: `${o / i * 100}%` }, r[`${n}${e}-pull-${o}`] = { insetInlineEnd: `${o / i * 100}%` }, r[`${n}${e}-offset-${o}`] = { marginInlineStart: `${o / i * 100}%` }, r[`${n}${e}-order-${o}`] = { order: o }); return r }, yp = (t, e) => uq(t, e), fq = (t, e, n) => ({ [`@media (min-width: ${e}px)`]: S({}, yp(t, n)) }), hq = zn("Grid", t => [aq(t)]), dq = zn("Grid", t => { const e = dn(t, { gridColumns: 24 }), n = { "-sm": e.screenSMMin, "-md": e.screenMDMin, "-lg": e.screenLGMin, "-xl": e.screenXLMin, "-xxl": e.screenXXLMin }; return [cq(e), yp(e, ""), yp(e, "-xs"), Object.keys(n).map(i => fq(e, n[i], i)).reduce((i, r) => S(S({}, i), r), {})] }), pq = () => ({ align: el([String, Object]), justify: el([String, Object]), prefixCls: String, gutter: el([Number, Array, Object], 0), wrap: { type: Boolean, default: void 0 } }), gq = ue({ compatConfig: { MODE: 3 }, name: "ARow", inheritAttrs: !1, props: pq(), setup(t, e) { let { slots: n, attrs: i } = e; const { prefixCls: r, direction: o } = dt("row", t), [s, l] = hq(r); let a; const c = s3(), u = he({ xs: !0, sm: !0, md: !0, lg: !0, xl: !0, xxl: !0 }), f = he({ xs: !1, sm: !1, md: !1, lg: !1, xl: !1, xxl: !1 }), h = x => E(() => { if (typeof t[x] == "string") return t[x]; if (typeof t[x] != "object") return ""; for (let w = 0; w < ja.length; w++) { const y = ja[w]; if (!f.value[y]) continue; const C = t[x][y]; if (C !== void 0) return C } return "" }), d = h("align"), p = h("justify"), g = oq(); vt(() => { a = c.value.subscribe(x => { f.value = x; const w = t.gutter || 0; (!Array.isArray(w) && typeof w == "object" || Array.isArray(w) && (typeof w[0] == "object" || typeof w[1] == "object")) && (u.value = x) }) }), At(() => { c.value.unsubscribe(a) }); const m = E(() => { const x = [void 0, void 0], { gutter: w = 0 } = t; return (Array.isArray(w) ? w : [w, void 0]).forEach((C, O) => { if (typeof C == "object") for (let P = 0; P < ja.length; P++) { const M = ja[P]; if (u.value[M] && C[M] !== void 0) { x[O] = C[M]; break } } else x[O] = C }), x }); sq({ gutter: m, supportFlexGap: g, wrap: E(() => t.wrap) }); const v = E(() => ke(r.value, { [`${r.value}-no-wrap`]: t.wrap === !1, [`${r.value}-${p.value}`]: p.value, [`${r.value}-${d.value}`]: d.value, [`${r.value}-rtl`]: o.value === "rtl" }, i.class, l.value)), b = E(() => { const x = m.value, w = {}, y = x[0] != null && x[0] > 0 ? `${x[0] / -2}px` : void 0, C = x[1] != null && x[1] > 0 ? `${x[1] / -2}px` : void 0; return y && (w.marginLeft = y, w.marginRight = y), g.value ? w.rowGap = `${x[1]}px` : C && (w.marginTop = C, w.marginBottom = C), w }); return () => { var x; return s($("div", ee(ee({}, i), {}, { class: v.value, style: S(S({}, b.value), i.style) }), [(x = n.default) === null || x === void 0 ? void 0 : x.call(n)])) } } }), mq = gq; function vq(t) { return typeof t == "number" ? `${t} ${t} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(t) ? `0 0 ${t}` : t } const yq = () => ({ span: [String, Number], order: [String, Number], offset: [String, Number], push: [String, Number], pull: [String, Number], xs: { type: [String, Number, Object], default: void 0 }, sm: { type: [String, Number, Object], default: void 0 }, md: { type: [String, Number, Object], default: void 0 }, lg: { type: [String, Number, Object], default: void 0 }, xl: { type: [String, Number, Object], default: void 0 }, xxl: { type: [String, Number, Object], default: void 0 }, prefixCls: String, flex: [String, Number] }), bq = ["xs", "sm", "md", "lg", "xl", "xxl"], Oq = ue({ compatConfig: { MODE: 3 }, name: "ACol", inheritAttrs: !1, props: yq(), setup(t, e) { let { slots: n, attrs: i } = e; const { gutter: r, supportFlexGap: o, wrap: s } = lq(), { prefixCls: l, direction: a } = dt("col", t), [c, u] = dq(l), f = E(() => { const { span: d, order: p, offset: g, push: m, pull: v } = t, b = l.value; let x = {}; return bq.forEach(w => { let y = {}; const C = t[w]; typeof C == "number" ? y.span = C : typeof C == "object" && (y = C || {}), x = S(S({}, x), { [`${b}-${w}-${y.span}`]: y.span !== void 0, [`${b}-${w}-order-${y.order}`]: y.order || y.order === 0, [`${b}-${w}-offset-${y.offset}`]: y.offset || y.offset === 0, [`${b}-${w}-push-${y.push}`]: y.push || y.push === 0, [`${b}-${w}-pull-${y.pull}`]: y.pull || y.pull === 0, [`${b}-rtl`]: a.value === "rtl" }) }), ke(b, { [`${b}-${d}`]: d !== void 0, [`${b}-order-${p}`]: p, [`${b}-offset-${g}`]: g, [`${b}-push-${m}`]: m, [`${b}-pull-${v}`]: v }, x, i.class, u.value) }), h = E(() => { const { flex: d } = t, p = r.value, g = {}; if (p && p[0] > 0) { const m = `${p[0] / 2}px`; g.paddingLeft = m, g.paddingRight = m } if (p && p[1] > 0 && !o.value) { const m = `${p[1] / 2}px`; g.paddingTop = m, g.paddingBottom = m } return d && (g.flex = vq(d), s.value === !1 && !g.minWidth && (g.minWidth = 0)), g }); return () => { var d; return c($("div", ee(ee({}, i), {}, { class: f.value, style: [h.value, i.style] }), [(d = n.default) === null || d === void 0 ? void 0 : d.call(n)])) } } }), ho = Kl(Oq), iO = Kl(mq), Sq = (t, e) => { const n = t.__vccOpts || t; for (const [i, r] of e) n[i] = r; return n }, xq = {
        __name: "App", setup(t) {
            const e = he(""), n = he(""), i = he(null); he(null); const r = he(null), o = he(!1), s = he("Try it!"), l = he({ title: "Python Editor", extra: "..." }); let a = null, c = null, u = null; vt(() => { const g = _e.create({ doc: n.value, extensions: [Zf, rB(), hw(), FS()] }); a = new ie({ state: g, parent: document.getElementById("editor") }), c = new ie({ state: _e.create({ extensions: [Zf] }), parent: document.getElementById("output") }), u = new ie({ state: _e.create({ extensions: [Zf] }), parent: document.getElementById("input") }), e.value = window.location.href, window.location.href.indexOf("snippets") != -1 && f(window.location.href) }); async function f(g) { let m = g.split("?src=")[1]; m = window.location.origin + "/playground/" + m, m.endsWith("/") ? m = m.slice(0, -1) + ".py" : m.endsWith(".py") || (m += ".py"), console.log(m); let v = m.replace(".py", ".input"), b = m.replace(".py", ".output"); try { const x = await fetch(m); if (x.ok) { const w = await x.text(); n.value = w, h(w, a) } else console.error("Failed to fetch file:", x.statusText) } catch (x) { console.error("Error fetching file:", x) } try { const x = await fetch(v); if (x.ok) { const w = await x.text(); w[0] != "<" && h(w, u) } else console.error("Failed to fetch file:", x.statusText) } catch (x) { console.error("Error fetching file:", x) } try { const x = await fetch(b); if (x.ok) { const w = await x.text(); w[0] != "<" && h(w, c) } else console.error("Failed to fetch file:", x.statusText) } catch (x) { console.error("Error fetching file:", x) } } function h(g, m) { if (m) { const v = m.state.update({ changes: { from: 0, to: m.state.doc.length, insert: g } }); m.dispatch(v) } else console.error("view is not initialized") } async function d(g) { return new Promise((m, v) => { const b = document.createElement("script"); b.src = g, b.onload = m, b.onerror = v, document.head.appendChild(b) }) } async function p() {
                if (!o.value) { l.value.extra = "loading environment...", d("https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js").then(async () => { i.value = await window.loadPyodide(), window.pyodide = i.value, await i.value.loadPackage("micropip"), l.value.extra = "ready", console.log("Pyodide loaded"), o.value = !0, s.value = "Run" }); return } if (i.value) {
                    let g = u.state.doc.toString(); g = g.split(`
`).map(x => x + `
`).join(""), i.value.globals.set("code", a.state.doc.toString()), i.value.globals.set("input_data", g), console.log(a.state.doc.toString()); const m = a.state.doc.toString(); l.value.extra = "loading packages...", await i.value.loadPackagesFromImports(m), l.value.extra = "ready", i.value.runPython(`
            import sys
            import io
            
            def input(prompt=''):
                res = sys.stdin.readline().strip()
                sys.stdout.write(prompt + res + '\\n')
                return res
                
            sys.stdin = io.StringIO(input_data)
            sys.stdout = io.StringIO()
            sys.stderr = io.StringIO()
            try:
                exec(code)
            except Exception as e:
                sys.stderr.write(str(e) + '\\n')
        `); const v = i.value.globals.get("sys").stdout.getvalue(), b = i.value.globals.get("sys").stderr.getvalue(); b ? (console.error(`Python error:
`+ b), document.getElementById("output").style.borderColor = "red") : document.getElementById("output").style.borderColor = "green", c.dispatch({ changes: { from: 0, to: c.state.doc.length, insert: v + b } })
                } else console.error("Pyodide is not loaded")
            } return (g, m) => (jk(), Xk(gt(zo), { title: l.value.title }, { extra: kn(() => [Wh(Mh(l.value.extra), 1)]), default: kn(() => [$(gt(iO), null, { default: kn(() => [$(gt(ho), { span: 24 }, { default: kn(() => m[0] || (m[0] = [Ya("div", { id: "editor", style: { border: "2px solid navy", "border-radius": "5px" } }, null, -1)])), _: 1 }), $(gt(ho), { span: 24 }, { default: kn(() => [$(gt(iO), { style: { "margin-top": "10px", display: "flex", "align-items": "center" } }, { default: kn(() => [$(gt(ho), { span: 18 }, { default: kn(() => m[1] || (m[1] = [Ya("div", { id: "input", style: { border: "2px solid grey", "border-radius": "5px" } }, null, -1)])), _: 1 }), $(gt(ho), { span: 3, style: { display: "flex", "align-items": "center" } }), $(gt(ho), { span: 3, style: { display: "flex", "align-items": "center" } }, { default: kn(() => [$(gt(ol), { ref: r.value, type: "primary", onClick: p, style: { width: "100%" } }, { default: kn(() => [Wh(Mh(s.value), 1)]), _: 1 }, 512)]), _: 1 })]), _: 1 })]), _: 1 }), $(gt(ho), { span: 24 }, { default: kn(() => m[2] || (m[2] = [Ya("div", { id: "output", style: { border: "2px solid grey", "border-radius": "5px" } }, null, -1)])), _: 1 })]), _: 1 })]), _: 1 }, 8, ["title"]))
        }
    }, wq = Sq(xq, [["__scopeId", "data-v-67ab9f4a"]]); DP(wq).mount("#app")
}); export default Cq();
